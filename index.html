<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Art Attack!</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.4/dist/jsQR.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Indie+Flower&family=Patrick+Hand&family=VT323&family=Playfair+Display:wght@700&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Patrick Hand', cursive;
            background-color: #f7e7d8;
            color: #5d4037;
            overflow: hidden; /* Prevent scrollbars */
        }

        canvas {
            border: 2px solid #5d4037;
            background-color: #fcf6e7;
            touch-action: none;
            display: block; /* Removes bottom margin */
            cursor: pointer;
        }

        #pie-clock-canvas {
            background-color: transparent;
            border: none;
        }

        .font-handwritten {
            font-family: 'Indie Flower', cursive;
        }

        .customer-bubble {
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid #5d4037;
            box-shadow: 4px 4px 0px 0px #5d4037;
        }

        .btn-style {
            background-color: #5d4037;
            color: #f7e7d8;
            border: 2px solid #5d4037;
            box-shadow: 4px 4px 0px 0px #5d4037;
            transition: all 0.1s;
        }

        .btn-style:active {
            box-shadow: 0px 0px 0px 0px #5d4037;
            transform: translate(4px, 4px);
        }

        .btn-style:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tooltip {
            visibility: hidden;
            background-color: #5d4037;
            color: #f7e7d8;
            padding: 5px 10px;
            border-radius: 8px;
            position: absolute;
            z-index: 100;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .item-tooltip:hover .tooltip {
            visibility: visible;
        }

        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fcf6e7;
            border: 2px solid #5d4037;
            padding: 2rem;
            z-index: 2000;
            box-shadow: 8px 8px 0px 0px #5d4037;
            text-align: center;
        }

        #clipboard-panel {
            max-width: 420px; /* Increased width */
            height: 90vh; /* Increased height */
            max-height: 800px;
            position: fixed;
            top: 5vh;
            right: 0;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 3000;
        }

        #clipboard-panel.open {
            transform: translateX(0);
        }

        .phone-app-screen {
            color: #5d4037;
            /* The background is now the paper, so this isn't needed */
            /* background-color: #f7e7d8; */
        }

        /* Toggle Switch Styles */
        .toggle-checkbox:checked {
            background-color: #22c55e; /* green-500 */
            border-color: #166534; /* green-800 */
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #f7e7d8;
        }

        /* Newspaper Styles */
        .font-playfair { font-family: 'Playfair Display', serif; }
        .font-merriweather { font-family: 'Merriweather', serif; }
        #newspaper-modal { z-index: 5000; }
        .newspaper-container {
            max-height: 90vh;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAMqADAAQAAAABAAAAMgAAAADXPWSMAAAAcUlEQVR4Ae3aQQ0AIAwEQf//6G0pAh5Ej5oJo0yS9ACCeM3Gk2SoeDPZfGk2gT1BtybYt2T7Jtm3ZNsm2bdk2ybZt2TbJtm3ZNsm2bdk2ybZt2TbJtm3ZNsm2bdk2ybZt2TbJtm3ZNsm2bdk2ybZt2TbJtm3ZNsm2bdk2ybZt2TbJtm3ZNsm2bdk2ybZt2TbJvQG4AAdx4c33/AAAAAElFTkSuQmCC');
            background-repeat: repeat;
        }

        /* Companion Mode Styles */
        body.companion-mode #game-ui,
        body.companion-mode #game-canvas,
        body.companion-mode #message-box {
            display: none !important;
        }

        body.companion-mode {
            background-color: #000; /* Black background for the phone */
        }

        body.companion-mode #clipboard-panel.force-hidden {
            display: none !important;
        }

        body.companion-mode #companion-header {
            display: flex !important;
        }

        body.companion-mode #clipboard-panel {
            display: block !important; /* Ensure it's visible */
            transform: translateX(0) !important; /* Override the hiding transform */
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            max-width: none !important;
            max-height: none !important;
            z-index: 9999 !important;
            border-radius: 0 !important; /* No rounded corners on fullscreen */
        }

        /* Hide the physical "close" button on the phone UI in companion mode,
           but keep the back button functional. */
        body.companion-mode #close-phone {
            display: none !important;
        }

        #companion-sync-btn.phone-connected {
            background-color: #22c55e; /* green-500 */
        }
    </style>
</head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J8RVJQNL5Y"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J8RVJQNL5Y');
</script>
<body class="p-4 flex flex-col items-center justify-center h-screen">

    <!-- The main container for the game canvas and its overlay UI -->
    <div id="game-container" class="relative w-full flex-grow">
        <!-- The UI that sits on top of the canvas -->
        <div id="game-ui" class="absolute top-4 left-4 z-10 flex items-center space-x-4">
             <div class="relative overflow-hidden p-3 text-xl border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm">
                 $<span id="cash-display">0</span>
                 <div id="cash-progress-bar" class="absolute bottom-0 left-0 h-1/5 bg-green-500 transition-all duration-200" style="width: 0%;"></div>
             </div>
             <div class="p-3 text-xl border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm">
                 Day: <span id="day-display">1</span>
             </div>
              <div class="relative overflow-hidden p-3 text-xl border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm">
                 Points: <span id="shop-points-display">0</span>
                 <div id="points-progress-bar" class="absolute bottom-0 left-0 h-1/5 bg-blue-500 transition-all duration-200" style="width: 0%;"></div>
             </div>
             <button id="start-day-btn" class="btn-style px-6 py-3 rounded-lg text-xl hidden">Start Day</button>
             <canvas id="pie-clock-canvas" width="50" height="50"></canvas>
            <div class="flex space-x-2">
                <button id="pause-play-btn" class="p-3 border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm w-16 h-16 flex items-center justify-center">
                    <svg id="play-icon" class="w-8 h-8 text-amber-900 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M6.3 2.841A1.5 1.5 0 0 0 4 4.11V15.89a1.5 1.5 0 0 0 2.3 1.269l9.344-5.89a1.5 1.5 0 0 0 0-2.538L6.3 2.84Z"></path></svg>
                    <svg id="pause-icon" class="w-8 h-8 text-amber-900" fill="currentColor" viewBox="0 0 20 20"><path d="M5.75 4.5a.75.75 0 0 0-.75.75v9.5c0 .414.336.75.75.75h1.5a.75.75 0 0 0 .75-.75V5.25a.75.75 0 0 0-.75-.75h-1.5zM12.75 4.5a.75.75 0 0 0-.75.75v9.5c0 .414.336.75.75.75h1.5a.75.75 0 0 0 .75-.75V5.25a.75.75 0 0 0-.75-.75h-1.5z"></path></svg>
                </button>
                <button id="double-time-btn" class="p-3 border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm w-16 h-16 flex items-center justify-center">
                    <svg class="w-8 h-8 text-amber-900" fill="currentColor" viewBox="0 0 20 20"><path d="M15.243 12.132a.75.75 0 0 1 0 1.06l-4.25 4.25a.75.75 0 0 1-1.06-1.061L13.633 13H4.75a.75.75 0 0 1 0-1.5h8.883l-3.7-3.7a.75.75 0 0 1 1.06-1.06l4.25 4.25a.75.75 0 0 1-.001 1.061z M8.75 3.75a.75.75 0 0 0-1.5 0v12.5a.75.75 0 0 0 1.5 0V3.75z"></path></svg>
                </button>
                <button id="companion-sync-btn" class="p-3 border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm w-16 h-16 flex items-center justify-center" title="Companion Sync">
                    <svg class="w-8 h-8 text-amber-900" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                </button>
            </div>
            <div id="basket-container" class="relative">
                <div id="basket-icon-container" class="relative p-3 border-2 border-amber-900 rounded-lg bg-amber-100/80 shadow-md backdrop-blur-sm cursor-pointer flex items-center justify-center w-16 h-16">
                    <svg class="w-8 h-8 text-amber-900" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                    <div id="basket-item-count" class="absolute -top-2 -right-2 bg-red-600 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center font-bold">0</div>
                </div>
                <div id="basket-contents" class="hidden absolute top-full left-0 mt-2 w-48 bg-amber-100/90 border-2 border-amber-900 rounded-lg shadow-lg p-2 z-20">
                    <!-- Basket items will be populated here -->
                </div>
            </div>
        </div>

        <!-- Canvas for the game -->
        <canvas id="game-canvas" class="rounded-lg shadow-xl w-full h-full"></canvas>

        <!-- Hidden canvas for generating the sprite sheet -->
        <canvas id="spriteSheetCanvas" width="270" height="270" style="display:none;"></canvas>

        <!-- Clipboard Panel -->
        <div id="clipboard-panel" class="w-full p-2">
            <!-- The Clipboard itself -->
            <div class="relative w-full h-full bg-amber-800 border-4 border-amber-900 rounded-lg shadow-xl pt-16">
                <!-- The Clip -->
                <div class="absolute top-0 left-1/2 -translate-x-1/2 -translate-y-1/2 w-40 h-20 bg-slate-400 border-4 border-slate-600 rounded-lg shadow-md">
                    <div class="w-full h-full bg-gradient-to-b from-slate-300 to-slate-500 rounded-md"></div>
                    <div class="absolute bottom-2 left-1/2 -translate-x-1/2 w-8 h-3 bg-slate-600 rounded-sm"></div>
                </div>

                <!-- The Paper -->
                <div id="clipboard-paper" class="bg-amber-50 rounded-lg h-full flex flex-col overflow-hidden m-2 p-2 border-2 border-amber-900/20">
                    <!-- Companion-only Header -->
                    <div id="companion-header" class="hidden justify-between items-center px-2 pb-2 text-amber-900 text-lg font-bold border-b-2 border-amber-800/20">
                        <div id="companion-funds">Funds: $--</div>
                        <div id="companion-points">Points: --</div>
                    </div>

                    <!-- Header Buttons -->
                    <div class="flex-shrink-0 pt-4 pb-4 flex justify-center items-center space-x-4">
                        <button id="phone-back-btn" class="btn-style px-6 py-2">Back</button>
                        <button id="close-phone" class="btn-style bg-red-700 hover:bg-red-600 px-6 py-2">Close</button>
                    </div>
                    <!-- Apps Grid -->
                    <div id="phone-apps-grid" class="grid grid-cols-4 gap-x-2 gap-y-4 p-4 flex-grow overflow-y-auto">
                        <!-- App icons will be populated here by JS -->
                    </div>

                    <!-- Nested App Screens -->
                    <div id="phone-app-screens" class="flex-grow overflow-y-auto hidden p-4 space-y-4">
                    <!-- Companion Sync Screen (for Companion Device) -->
                    <div id="companion-sync-screen" class="phone-app-screen hidden h-full flex flex-col items-center justify-center text-center p-4">
                        <h2 class="text-3xl font-handwritten mb-4">Companion Sync</h2>
                        <p id="companion-instructions" class="mb-4">To connect, please use your device's camera to scan the QR code on the main game screen.</p>
                        <!-- The input and manual connect button are removed -->
                        <p id="companion-status" class="mt-4 text-sm text-amber-800/80">Waiting for QR code scan...</p>
                    </div>
                    <!-- Settings Panel -->
                    <div id="settings-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Settings</h2>
                        <div class="space-y-4">
                            <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                                <label for="developer-toggle" class="text-lg">Developer Mode</label>
                                <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="developer-toggle" id="developer-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                    <label for="developer-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                </div>
                            </div>
                            <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                                <label for="continuous-toggle" class="text-lg">Continuous Day</label>
                                <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="continuous-toggle" id="continuous-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                    <label for="continuous-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                </div>
                            </div>
                            <button id="settings-open-market-style-modal-btn" class="btn-style w-full py-2">Market Style</button>
                            <button id="new-game-btn" class="btn-style w-full py-2">Start New Game</button>
                        </div>
                    </div>

                    <!-- Unlocks Panel -->
                    <div id="unlocks-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Unlocks</h2>
                        <div class="space-y-4">
                            <div>
                                <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Employees</h3>
                                <div id="unlocks-employees" class="space-y-2"></div>
                            </div>
                            <div>
                                <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Shelves</h3>
                                <div id="unlocks-shelves" class="space-y-2"></div>
                            </div>
                             <div>
                                <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Facilities</h3>
                                <div id="unlocks-facilities" class="space-y-2"></div>
                            </div>
                            <div>
                                <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Storage</h3>
                                <div id="unlocks-storage" class="space-y-2"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Restock Panel -->
                    <div id="restock-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Order Supplies</h2>
                        <div id="restock-grid" class="space-y-2"></div>
                    </div>

                    <!-- Order Quantity Modal -->
                    <div id="order-quantity-modal" class="phone-app-screen hidden">
                        <h2 id="order-quantity-item-name" class="text-3xl font-handwritten mb-4">Order Item</h2>
                        <div class="space-y-4 p-4 bg-white/30 rounded-md">
                            <div>
                                <span class="text-xl">Cost per item:</span>
                                <span id="order-quantity-item-cost" class="text-xl font-handwritten">$0.00</span>
                            </div>
                            <div class="flex items-center justify-center space-x-2">
                                <span class="text-xl">Quantity:</span>
                                <button id="order-quantity-minus-5" class="btn-style qty-btn text-lg px-3 py-1">-5</button>
                                <button id="order-quantity-minus-1" class="btn-style qty-btn text-lg px-3 py-1">-1</button>
                                <input type="number" min="0" id="order-quantity-input" data-item="" class="w-20 p-1 text-center border-2 border-amber-800 rounded-md bg-white/80">
                                <button id="order-quantity-plus-1" class="btn-style qty-btn text-lg px-3 py-1">+1</button>
                                <button id="order-quantity-plus-5" class="btn-style qty-btn text-lg px-3 py-1">+5</button>
                            </div>
                        </div>
                        <div class="mt-6 text-center">
                            <button id="order-quantity-done-btn" class="btn-style px-6 py-2">Done</button>
                        </div>
                    </div>

                    <!-- Shelf Assignment Panel -->
                    <div id="shelf-assignment-panel" class="phone-app-screen hidden">
                        <h2 id="shelf-assignment-title" class="text-3xl font-handwritten mb-4">Shelf Assignments</h2>
                        <div id="shelf-assignment-grid" class="grid grid-cols-2 gap-2"></div>
                    </div>

                    <!-- Shelf Panel -->
                    <div id="shelf-panel" class="phone-app-screen hidden">
                        <h2 id="shelf-title" class="text-3xl font-handwritten mb-4">Manage Shelf</h2>
                        <div id="shelf-grid" class="grid grid-cols-1 gap-4"></div>
                    </div>

                    <!-- Storage Panel -->
                    <div id="storage-panel" class="phone-app-screen hidden">
                        <h2 id="storage-title" class="text-3xl font-handwritten mb-4">Manage Storage</h2>
                        <div id="storage-grid" class="grid grid-cols-2 gap-2"></div>
                    </div>

                    <!-- Assignment Panel -->
                    <div id="assignment-panel" class="phone-app-screen hidden">
                        <h2 id="assignment-title" class="text-2xl font-handwritten mb-4">Assign Item</h2>
                        <div id="assignment-grid" class="grid grid-cols-2 gap-2"></div>
                    </div>

                    <!-- Employees Panel -->
                    <div id="employees-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Manage Employees</h2>
                        <div id="employee-list" class="space-y-2"></div>
                    </div>

                    <!-- Customers Panel -->
                    <div id="customers-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Customers</h2>
                        <div class="flex border-b-2 border-amber-800/30 mb-2">
                            <button id="in-store-customers-btn" class="flex-1 p-2 bg-amber-800/20 rounded-t-md">In Store</button>
                            <button id="all-customers-btn" class="flex-1 p-2 bg-amber-800/20 rounded-t-md bg-opacity-50">All</button>
                        </div>
                        <div id="in-store-customer-list" class="space-y-2"></div>
                        <div id="all-customer-list" class="hidden flex-col space-y-2"></div>
                    </div>

                    <!-- Items Panel -->
                    <div id="items-panel" class="phone-app-screen hidden">
                        <h2 class="text-3xl font-handwritten mb-4">Toggle Items</h2>
                        <div id="items-toggle-grid" class="space-y-2"></div>
                    </div>
                </div>

                <!-- Companion Control Footer -->
                <div id="companion-control-footer" class="hidden mt-auto pt-2 border-t-2 border-amber-800/30 flex justify-around items-center">
                    <button id="companion-pause-play-btn" class="btn-style p-3 flex items-center justify-center w-32">
                        <svg id="companion-play-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M6.3 2.841A1.5 1.5 0 0 0 4 4.11V15.89a1.5 1.5 0 0 0 2.3 1.269l9.344-5.89a1.5 1.5 0 0 0 0-2.538L6.3 2.84Z"></path></svg>
                        <svg id="companion-pause-icon" class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M5.75 4.5a.75.75 0 0 0-.75.75v9.5c0 .414.336.75.75.75h1.5a.75.75 0 0 0 .75-.75V5.25a.75.75 0 0 0-.75-.75h-1.5zM12.75 4.5a.75.75 0 0 0-.75.75v9.5c0 .414.336.75.75.75h1.5a.75.75 0 0 0 .75-.75V5.25a.75.75 0 0 0-.75-.75h-1.5z"></path></svg>
                        <span id="companion-pause-play-text" class="ml-2">Pause</span>
                    </button>
                    <button id="companion-double-time-btn" class="btn-style p-3 flex items-center justify-center w-32">
                         <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M15.243 12.132a.75.75 0 0 1 0 1.06l-4.25 4.25a.75.75 0 0 1-1.06-1.061L13.633 13H4.75a.75.75 0 0 1 0-1.5h8.883l-3.7-3.7a.75.75 0 0 1 1.06-1.06l4.25 4.25a.75.75 0 0 1-.001 1.061z M8.75 3.75a.75.75 0 0 0-1.5 0v12.5a.75.75 0 0 0 1.5 0V3.75z"></path></svg>
                         <span id="companion-double-time-text" class="ml-2">2x Time</span>
                    </button>
                </div>

                <!-- Shared Order Footer -->
                <div id="order-footer" class="hidden mt-auto pt-2 border-t-2 border-amber-800/30 flex justify-between items-center">
                    <span class="text-xl">Total: $<span id="restock-total">0.00</span></span>
                    <button id="place-order-btn" class="btn-style px-4 py-2">Place Order</button>
                </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Message Box -->
    <div id="message-box" class="hidden rounded-lg">
        <p id="message-text" class="text-lg"></p>
        <button id="message-ok-btn" class="btn-style mt-4 px-4 py-2 rounded-lg">OK</button>
    </div>

    <!-- Host Sync Modal (for Host Device) -->
    <div id="host-sync-modal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-5000">
        <div class="bg-amber-100 w-full max-w-md p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col items-center">
            <h2 class="text-3xl font-handwritten text-center mb-4">Companion Sync</h2>
            <p class="mb-4 text-center">Scan this QR code with your companion device to sync.</p>
            <canvas id="qr-code-canvas" class="border-4 border-amber-800/50 rounded-lg"></canvas>
            <p id="host-status" class="mt-4 mb-6 text-sm text-center">Waiting for connection...</p>
            <div class="flex space-x-4">
                <button id="host-sync-close-btn" class="btn-style px-6 py-2">Close</button>
                <a id="open-in-tab-btn" href="#" target="_blank" class="btn-style bg-blue-600 hover:bg-blue-500 px-6 py-2 hidden">Open in Tab</a>
            </div>
        </div>
    </div>

    <!-- New Game Screen -->
    <div id="new-game-screen" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-3000">
        <div class="relative bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col">
            <button id="close-new-game-screen" class="absolute top-2 right-2 text-3xl font-bold text-amber-900 hover:text-red-700">&times;</button>
            <h1 class="text-5xl font-handwritten text-center mb-4">Art Attack!</h1>
            <h2 class="text-3xl font-handwritten text-center mb-6">Start a New Game</h2>
            <div class="space-y-4">
                <button id="new-game-standard" class="btn-style p-4 text-xl w-full">Standard Unlocks</button>
                <div class="grid grid-cols-2 gap-4">
                    <div class="flex flex-col space-y-4">
                        <button id="new-game-dev" class="btn-style p-4 text-xl">Developer Mode</button>
                        <button id="new-game-casual" class="btn-style p-4 text-xl">Casual</button>
                    </div>
                    <div class="flex flex-col space-y-4">
                        <button id="new-game-family" class="btn-style p-4 text-xl">Family Store</button>
                        <button id="new-game-specialty" class="btn-style p-4 text-xl">Specialty Store</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Dev Mode Options Screen -->
    <div id="dev-mode-screen" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-3000">
        <div class="bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col">
            <h2 class="text-3xl font-handwritten text-center mb-6">Developer Options</h2>
            <div class="space-y-4 mb-6">
                <!-- Toggle Switches -->
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="dev-unlocks-label" for="dev-unlocks-toggle" class="text-lg">Standard</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="dev-unlocks-toggle" id="dev-unlocks-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="dev-unlocks-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="dev-supplies-label" for="dev-supplies-toggle" class="text-lg">Standard Costs</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="dev-supplies-toggle" id="dev-supplies-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="dev-supplies-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="dev-debt-label" for="dev-debt-toggle" class="text-lg">Standard Debt</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="dev-debt-toggle" id="dev-debt-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="dev-debt-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="dev-market-label" for="dev-market-toggle" class="text-lg">Market</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="dev-market-toggle" id="dev-market-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="dev-market-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-6">
                <button id="dev-open-market-style-modal-btn" class="btn-style p-4 text-xl">Market Style</button>
                <button id="dev-starting-unlocks-btn" class="btn-style p-4 text-xl">Starting Unlocks</button>
            </div>
            <div class="flex justify-between items-center">
                <button id="dev-back-btn" class="btn-style p-4 text-xl">Back</button>
                <button id="dev-start-game-btn" class="btn-style bg-green-700 hover:bg-green-600 p-4 text-xl">Start Game</button>
            </div>
        </div>
    </div>

    <!-- Family Store Options Screen -->
    <div id="family-store-screen" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-3000">
        <div class="bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col">
            <h2 class="text-3xl font-handwritten text-center mb-6">Family Store Options</h2>
            <div class="space-y-4 mb-6">
                <!-- Toggles -->
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="family-coffee-label" for="family-coffee-toggle" class="text-lg">Free Coffee Shop</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="family-coffee-toggle" id="family-coffee-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="family-coffee-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="family-costs-label" for="family-costs-toggle" class="text-lg">Bad Costs</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="family-costs-toggle" id="family-costs-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="family-costs-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <!-- Dropdown -->
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label for="family-relative-select" class="text-lg">Choose Relative</label>
                    <select id="family-relative-select" class="p-2 rounded-md border-2 border-amber-800/50 bg-white/80">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
            </div>
            <div class="flex justify-between items-center">
                <button id="family-back-btn" class="btn-style p-4 text-xl">Back</button>
                <button id="family-start-game-btn" class="btn-style bg-green-700 hover:bg-green-600 p-4 text-xl">Start Game</button>
            </div>
        </div>
    </div>

    <!-- Specialty Store Options Screen -->
    <div id="specialty-store-screen" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-3000">
        <div class="bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col">
            <h2 class="text-3xl font-handwritten text-center mb-6">Specialty Store Options</h2>
            <div class="space-y-4 mb-6">
                <!-- Dropdowns -->
                <div class="grid grid-cols-2 gap-4">
                    <div class="flex flex-col space-y-2">
                        <label for="specialty-one-select" class="text-lg">Primary Specialty</label>
                        <select id="specialty-one-select" class="p-2 rounded-md border-2 border-amber-800/50 bg-white/80"></select>
                    </div>
                    <div class="flex flex-col space-y-2">
                        <label for="specialty-two-select" class="text-lg">Secondary Specialty</label>
                        <select id="specialty-two-select" class="p-2 rounded-md border-2 border-amber-800/50 bg-white/80"></select>
                    </div>
                </div>
                <!-- Toggles -->
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="specialty-costs-label" for="specialty-costs-toggle" class="text-lg">-10% Prices</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="specialty-costs-toggle" id="specialty-costs-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="specialty-costs-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="specialty-coffee-label" for="specialty-coffee-toggle" class="text-lg">No Coffee Shop</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="specialty-coffee-toggle" id="specialty-coffee-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="specialty-coffee-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label id="specialty-customers-label" for="specialty-customers-toggle" class="text-lg">Increase Customer Pool</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="specialty-customers-toggle" id="specialty-customers-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="specialty-customers-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
            </div>
            <div class="flex justify-between items-center">
                <button id="specialty-back-btn" class="btn-style p-4 text-xl">Back</button>
                <button id="specialty-start-game-btn" class="btn-style bg-green-700 hover:bg-green-600 p-4 text-xl">Start Game</button>
            </div>
        </div>
    </div>

    <!-- Casual Mode Options Screen -->
    <div id="casual-mode-screen" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-3000">
        <div class="bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col">
            <h2 class="text-3xl font-handwritten text-center mb-6">Casual Mode Options</h2>
            <div class="space-y-4 mb-6">
                <!-- Toggles -->
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label for="casual-breaks-toggle" class="text-lg">No Breaks</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="casual-breaks-toggle" id="casual-breaks-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="casual-breaks-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label for="casual-debt-toggle" class="text-lg">No Debt Penalty</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="casual-debt-toggle" id="casual-debt-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="casual-debt-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
            </div>
            <div class="flex justify-between items-center">
                <button id="casual-back-btn" class="btn-style p-4 text-xl">Back</button>
                <button id="casual-start-game-btn" class="btn-style bg-green-700 hover:bg-green-600 p-4 text-xl">Start Game</button>
            </div>
        </div>
    </div>

    <!-- Final Settings Screen -->
    <div id="final-settings-screen" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-3000">
        <div class="bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col">
            <h2 class="text-3xl font-handwritten text-center mb-6">Final Settings</h2>
            <div class="space-y-4 mb-6">
                <!-- Market Type Dropdown -->
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label for="final-market-type-select" class="text-lg">Market Type</label>
                    <select id="final-market-type-select" class="p-2 rounded-md border-2 border-amber-800/50 bg-white/80">
                        <option value="classic">Classic</option>
                        <option value="dailyMood">Daily Mood</option>
                        <option value="categoryFocus">Category Focus</option>
                        <option value="liveSimulation">Live Simulation</option>
                        <option value="disabled">Disabled</option>
                    </select>
                </div>
                <!-- Continuous Day Toggle -->
                <div class="flex items-center justify-between p-2 bg-white/50 rounded-md">
                    <label for="final-continuous-day-toggle" class="text-lg">Continuous Day</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="final-continuous-day-toggle" id="final-continuous-day-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="final-continuous-day-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
            </div>
            <div class="flex justify-between items-center">
                <button id="final-settings-back-btn" class="btn-style p-4 text-xl">Back</button>
                <button id="final-settings-start-game-btn" class="btn-style bg-green-700 hover:bg-green-600 p-4 text-xl">Start Game</button>
            </div>
        </div>
    </div>

    <!-- Market Style Selection Modal -->
    <div id="market-style-modal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-4000">
        <div class="bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col">
            <h2 class="text-3xl font-handwritten text-center mb-6">Select Market Style</h2>
            <div class="flex space-x-4 mb-4">
                <!-- Market Style Buttons -->
                <div id="market-style-buttons" class="flex flex-col space-y-2 w-1/3">
                    <button class="market-style-btn btn-style p-3 text-lg" data-style="disabled">Disabled</button>
                    <button class="market-style-btn btn-style p-3 text-lg" data-style="classic">Classic</button>
                    <button class="market-style-btn btn-style p-3 text-lg" data-style="dailyMood">Daily Mood</button>
                    <button class="market-style-btn btn-style p-3 text-lg" data-style="categoryFocus">Category Focus</button>
                    <button class="market-style-btn btn-style p-3 text-lg" data-style="liveSimulation">Live Simulation</button>
                </div>
                <!-- Description Panel -->
                <div id="market-style-description" class="w-2/3 p-4 bg-white/50 rounded-md border-2 border-amber-800/30">
                    <p>Select a style to see its description.</p>
                </div>
            </div>
            <div class="flex justify-end items-center space-x-4">
                <button id="market-style-cancel-btn" class="btn-style p-4 text-xl">Cancel</button>
                <button id="market-style-confirm-btn" class="btn-style bg-green-700 hover:bg-green-600 p-4 text-xl">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Newspaper Modal -->
    <div id="newspaper-modal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-5000 p-4">
        <div class="bg-[#fdf6e3] w-full max-w-3xl p-6 rounded-lg shadow-2xl border-4 border-amber-900 text-amber-900 flex flex-col relative newspaper-container">
            <button id="close-newspaper-btn" class="absolute -top-4 -right-4 bg-red-700 text-white rounded-full w-10 h-10 text-2xl font-bold border-4 border-white hover:bg-red-600 transition-transform hover:scale-110">&times;</button>
            <div class="text-center mb-4">
                <h1 class="font-playfair text-5xl font-bold text-purple-900 pb-2 border-b-4 border-double border-purple-900">The Bumble Bee</h1>
                <p class="text-lg text-gray-600 mt-2">Edition: Day <span id="newspaper-day">1</span></p>
            </div>
            <div class="flex-grow overflow-y-auto p-4 border-t border-gray-300">
                <h2 id="newspaper-headline" class="font-playfair text-3xl font-bold text-gray-800 mb-4"></h2>
                <p id="newspaper-description" class="font-merriweather text-lg leading-relaxed text-gray-700"></p>
                <div class="text-center mt-6">
                    <button id="newspaper-hint-btn" class="btn-style px-6 py-2">Show Hint</button>
                </div>
                <div id="newspaper-hint-display" class="hidden mt-4 p-3 bg-purple-100/50 border-2 border-purple-200 rounded-lg text-center">
                    <!-- Hint text will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- End of Day Report Panel -->
    <div id="end-of-day-panel" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-2000">
        <div class="bg-amber-100 w-full max-w-4xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col" style="height: 90vh;">
            <div class="flex justify-center items-center relative mb-4 flex-shrink-0">
                <h2 class="text-3xl font-handwritten text-center">End of Day Report</h2>
                <button id="eod-newspaper-btn" class="absolute right-0 btn-style p-2 hidden" title="Read Today's News">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 12h6m-6-4h6" />
                    </svg>
                </button>
            </div>

            <!-- Summary Section -->
            <div class="grid grid-cols-2 gap-6 mb-4 flex-shrink-0">
                <div>
                    <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Summary</h3>
                    <div class="space-y-2 text-lg">
                        <p>Day Ended: <span id="report-day" class="font-bold"></span></p>
                        <p>Gross Sales: <span id="report-sales" class="font-bold"></span></p>
                        <p>Today's Accrued Expenses: <span id="report-expenses" class="font-bold"></span></p>
                        <div id="weekly-bill-report" class="pl-4 text-base border-l-2 border-amber-800/30 ml-2 space-y-1 my-1"></div>
                        <p class="border-t border-amber-800/30 pt-2">Net Profit: <span id="report-profit" class="font-bold"></span></p>
                    </div>
                </div>
                <div id="report-summary-extra" class="mt-2 text-sm">
                    <!-- Extra summary stats will be populated here -->
                </div>
            </div>

            <!-- Report Toggles -->
            <div class="flex space-x-2 border-b-2 border-amber-800/30 mb-2 flex-shrink-0">
                <button id="report-toggle-customers" class="report-toggle-btn flex-1 p-2 bg-amber-800/20 rounded-t-md">Customer Details</button>
                <button id="report-toggle-sales" class="report-toggle-btn flex-1 p-2 bg-amber-800/20 rounded-t-md bg-opacity-50">Sales</button>
                <button id="report-toggle-coffee" class="report-toggle-btn flex-1 p-2 bg-amber-800/20 rounded-t-md bg-opacity-50">Coffee</button>
                <button id="report-toggle-bills" class="report-toggle-btn flex-1 p-2 bg-amber-800/20 rounded-t-md bg-opacity-50">Bills</button>
                <button id="report-toggle-market" class="report-toggle-btn flex-1 p-2 bg-amber-800/20 rounded-t-md bg-opacity-50">Market</button>
            </div>

            <!-- Report Views -->
            <div class="flex-grow overflow-y-auto p-2 bg-white/30 rounded-md border">
                <!-- Customer Details View -->
                <div id="report-view-customers" class="report-view space-y-3">
                    <!-- Original #sales-report-list content goes here -->
                </div>

                <!-- Sales View -->
                <div id="report-view-sales" class="report-view hidden">
                    <!-- Sales breakdown will be populated here -->
                </div>

                <!-- Coffee View -->
                <div id="report-view-coffee" class="report-view hidden">
                    <!-- Coffee sales breakdown will be populated here -->
                </div>

                <!-- Bills View -->
                <div id="report-view-bills" class="report-view hidden">
                    <!-- Bills breakdown will be populated here -->
                </div>

                <!-- Market View -->
                <div id="report-view-market" class="report-view hidden">
                    <!-- Market predictions will be populated here -->
                </div>
            </div>

            <div class="text-center mt-4 flex-shrink-0">
                <button id="next-day-report-btn" class="btn-style px-8 py-3 text-xl">Start Next Day</button>
            </div>
        </div>
    </div>

    <!-- Manager Report Modal -->
    <div id="manager-report-modal" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-4000">
        <div class="bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-handwritten">Manager's Report</h2>
                <button id="close-manager-report-btn" class="text-3xl font-bold text-amber-900 hover:text-red-700">&times;</button>
            </div>
            <div class="flex-grow bg-white/50 p-4 rounded-md border-2 border-amber-800/30">
                <h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Upcoming Trends</h3>
                <div id="manager-trends-content">
                    <p class="text-center p-4">The manager is still gathering data...</p>
                </div>
            </div>
            <div class="mt-4 text-center">
                <button id="manager-dev-report-btn" class="btn-style hidden">DEV Report</button>
            </div>
        </div>
    </div>

    <!-- DEV Report Modal -->
    <div id="dev-report-modal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-5000">
        <div class="bg-amber-100 w-full max-w-3xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col" style="height: 80vh;">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-3xl font-handwritten">Developer Forecast Report</h2>
                <button id="close-dev-report-btn" class="text-3xl font-bold text-amber-900 hover:text-red-700">&times;</button>
            </div>
            <div id="dev-report-content" class="flex-grow bg-white/50 p-4 rounded-md border-2 border-amber-800/30 overflow-y-auto">
                <!-- Content will be populated by JS -->
            </div>
        </div>
    </div>

    <!-- Simulated Market Report Modal -->
    <div id="simulated-market-report-modal" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-6000">
        <div class="bg-amber-50 w-full max-w-4xl p-6 rounded-lg shadow-2xl border-4 border-amber-900 text-amber-900 flex flex-col" style="height: 90vh;">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 id="simulated-report-title" class="text-3xl font-handwritten">Simulated Market Report</h2>
                <button id="close-simulated-report-btn" class="text-3xl font-bold text-amber-900 hover:text-red-700">&times;</button>
            </div>
            <div id="simulated-market-report-content" class="flex-grow bg-white/40 p-4 rounded-md border-2 border-amber-800/30 overflow-y-auto">
                <!-- Simulated content will be populated by JS -->
            </div>
        </div>
    </div>

    <!-- Market Panel Modal -->
    <div id="market-panel" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-4000">
        <div class="relative bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col" style="height: 80vh;">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-3xl font-handwritten">Market Report</h2>
                <button id="close-market-panel-btn" class="text-3xl font-bold text-amber-900 hover:text-red-700">&times;</button>
            </div>
            <div id="market-categories-container" class="space-y-2 flex-grow overflow-y-auto p-2 bg-white/30 rounded-md border">
                <!-- Category reports will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- Market Detail Panel Modal -->
    <div id="market-detail-panel" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-4000">
        <div class="relative bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col" style="height: 80vh;">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 id="market-detail-title" class="text-3xl font-handwritten">Category Details</h2>
                <div>
                     <button id="market-detail-back-btn" class="btn-style px-4 py-1 mr-2">Back</button>
                     <button id="close-market-detail-panel-btn" class="text-3xl font-bold text-amber-900 hover:text-red-700">&times;</button>
                </div>
            </div>
            <div id="market-items-container" class="space-y-2 flex-grow overflow-y-auto p-2 bg-white/30 rounded-md border">
                <!-- Individual item reports will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- Market Item Deep Dive Panel Modal -->
    <div id="market-item-deep-dive-panel" class="hidden fixed inset-0 bg-black/50 flex items-center justify-center z-4000">
        <div class="relative bg-amber-100 w-full max-w-2xl p-6 rounded-lg shadow-xl border-4 border-amber-900 text-amber-900 flex flex-col" style="height: 80vh;">
            <div class="flex justify-between items-center mb-2 flex-shrink-0">
                <h2 id="market-deep-dive-title" class="text-3xl font-handwritten">Item Details</h2>
                <div>
                    <button id="market-deep-dive-back-btn" class="btn-style px-4 py-1 mr-2">Back</button>
                    <button id="close-market-deep-dive-panel-btn" class="text-3xl font-bold text-amber-900 hover:text-red-700">&times;</button>
                </div>
            </div>
            <div class="space-y-4 flex-grow overflow-y-auto p-2">
                <!-- Detailed Graph -->
                <div class="w-full h-48 bg-white/50 rounded-md border-2 border-amber-800/20 p-1">
                    <canvas id="market-deep-dive-canvas"></canvas>
                </div>
                <!-- Stats and Ordering -->
                <div class="grid grid-cols-2 gap-4">
                    <div class="p-2 bg-white/50 rounded-md border border-amber-800/10">
                        <h3 class="font-handwritten text-lg border-b border-amber-800/20 mb-1">Stats</h3>
                        <div class="text-sm space-y-1">
                            <p>Base Cost: <span id="deep-dive-base-cost" class="font-bold">$--.--</span></p>
                            <p>7-Day High: <span id="deep-dive-high" class="font-bold text-red-500">$--.--</span></p>
                            <p>7-Day Low: <span id="deep-dive-low" class="font-bold text-green-500">$--.--</span></p>
                        </div>
                    </div>
                    <div class="p-2 bg-white/50 rounded-md border border-amber-800/10">
                        <h3 class="font-handwritten text-lg border-b border-amber-800/20 mb-1">Place Order</h3>
                        <div class="space-y-2">
                             <div class="flex items-center justify-between">
                                <span>Price:</span>
                                <span id="deep-dive-current-price" class="font-bold">$--.--</span>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="deep-dive-order-qty">Quantity:</label>
                                <input type="number" id="deep-dive-order-qty" min="1" value="1" class="w-20 p-1 text-center border-2 border-amber-800 rounded-md bg-white/80">
                            </div>
                            <button id="deep-dive-place-order-btn" data-item="" class="btn-style w-full py-1 mt-1">Order for $--.--</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script>
        function showMessage(text, callback) {
            // If we are the host with a connection, send the message to the companion.
            if (hostConnection && hostConnection.open) {
                hostConnection.send({ type: 'feedbackMessage', message: text });
            }

            const msgBox = document.getElementById('message-box');
            const msgText = document.getElementById('message-text');
            const msgBtn = document.getElementById('message-ok-btn');

            msgText.textContent = text;
            msgBox.classList.remove('hidden');

            const clickHandler = () => {
                msgBox.classList.add('hidden');
                if (callback) callback();
                msgBtn.removeEventListener('click', clickHandler);
            };
            msgBtn.addEventListener('click', clickHandler);
        }

        const customerTypes = {
            'artist': {
                name: 'Artist',
                storageLabel: 'Drawing',
                storageIndex: 0,
                spriteType: 'student'
            },
            'painter': {
                name: 'Painter',
                storageLabel: 'Painting',
                storageIndex: 1,
                spriteType: 'painter'
            },
            'hobbyist': {
                name: 'Hobbyist',
                storageLabel: 'Models',
                storageIndex: 2,
                spriteType: 'modelMaker'
            },
            'woodworker': {
                name: 'Woodworker',
                storageLabel: 'Woodworking',
                storageIndex: 3,
                spriteType: 'woodworker'
            },
            'sculptor': {
                name: 'Sculptor',
                storageLabel: 'Sculpture',
                storageIndex: 4,
                spriteType: 'sculptor'
            },
            'architect': {
                name: 'Architect',
                storageLabel: 'Architectural',
                storageIndex: 5,
                spriteType: 'architect'
            }
        };

        let originalCustomerProfiles = {};
        let customerProfiles = {
            'artist': {
                "Leo": { "request": "I need some basic supplies for my life drawing class.", "requestedItems": ["Pencil", "Sketchbook"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Kara": { "request": "I want to try some charcoal drawings. Got any?", "requestedItems": ["Charcoal"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Benny": { "request": "My markers have all dried out! I need a new set.", "requestedItems": ["Markers"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Vince": { "request": "I'm teaching a class, I need a bulk order of sketchbooks.", "requestedItems": ["Sketchbook", "Sketchbook", "Sketchbook"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Arturo": { "request": "Just a pencil for now, maybe a sketchbook if I feel inspired.", "requestedItems": ["Pencil"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Penelope": { "request": "I need a good set of colored markers for a commission piece.", "requestedItems": ["Markers"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Chuck": { "request": "Do you have any fine-tipped charcoal pencils?", "requestedItems": ["Charcoal", "Pencil"], "patience": 100, "visitedToday": false, "toolsOwned": [] }
            },
            'painter': {
                "Frida": { "request": "I'm starting a new self-portrait. I'll need acrylics and a canvas.", "requestedItems": ["Acrylics", "Canvas"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Claude": { "request": "Just need some water colors for some light studies.", "requestedItems": ["Water Color"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Georgia": { "request": "I'm working on a large piece. I need oil paints.", "requestedItems": ["Oils", "Canvas"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Bob": { "request": "Time to paint some happy little trees. Need some oils.", "requestedItems": ["Oils"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Rembrandt": { "request": "I require the finest acrylics for my next masterpiece.", "requestedItems": ["Acrylics"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Sonia": { "request": "A small canvas and some water colors, please.", "requestedItems": ["Canvas", "Water Color"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "JMW": { "request": "I'm feeling dramatic. Give me your most vibrant oils and a large canvas.", "requestedItems": ["Oils", "Canvas"], "patience": 100, "visitedToday": false, "toolsOwned": [] }
            },
            'hobbyist': {
                "Wally": { "request": "I'm building a new model ship. I need glue and some razors for the small parts.", "requestedItems": ["Glue", "Razors"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Gundam Guy": { "request": "I need to paint my latest creation. Got any mini paints?", "requestedItems": ["Mini Paints"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Tanya": { "request": "I'm ready to start a new project. A model kit, please!", "requestedItems": ["Model Kits"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Duncan": { "request": "Two thin coats of mini paints are all I need.", "requestedItems": ["Mini Paints"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Rick": { "request": "I need razors to... uh... 'customize' my models. Yeah, that's it.", "requestedItems": ["Razors"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Mini Martha": { "request": "A little glue can fix anything!", "requestedItems": ["Glue"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Captain Kit": { "request": "I'm on the hunt for a new model kit to assemble.", "requestedItems": ["Model Kits", "Glue"], "patience": 100, "visitedToday": false, "toolsOwned": [] }
            },
            'woodworker': {
                "Ron": { "request": "I need to finish a chair. Some sanding paper and stainer should do it.", "requestedItems": ["Sanding Paper", "Stainer"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Tammy": { "request": "I'm just starting out. Do you have any wood scraps I can practice on?", "requestedItems": ["Wood Scraps"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "April": { "request": "I'm building a large table and need some lumber.", "requestedItems": ["Lumber"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Nick": { "request": "I need some quality lumber for a custom piece.", "requestedItems": ["Lumber"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Pat": { "request": "Just some sanding paper to smooth things over.", "requestedItems": ["Sanding Paper"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Woody": { "request": "Got any interesting wood scraps? I like a challenge.", "requestedItems": ["Wood Scraps"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Cheryl": { "request": "I'm staining a deck. I'll need a lot of stainer.", "requestedItems": ["Stainer", "Stainer"], "patience": 100, "visitedToday": false, "toolsOwned": [] }
            },
            'sculptor': {
                "Michelangelo": { "request": "I have a vision! I require clay to bring it to life.", "requestedItems": ["Clay"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Auguste": { "request": "I need to paint a ceramic piece. Do you have pottery paints?", "requestedItems": ["Pottery Paints"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Donatello": { "request": "I am ready to work with a harder medium. A block of stone, please.", "requestedItems": ["Stone", "Clay"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Henry": { "request": "I'm thinking... bigger. A block of marble.", "requestedItems": ["Marble"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Camille": { "request": "I need clay, and perhaps some pottery paints for the details.", "requestedItems": ["Clay", "Pottery Paints"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Constantin": { "request": "Just a simple block of stone today.", "requestedItems": ["Stone"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Barbara": { "request": "I'm making a set of mugs. Clay and pottery paints, please.", "requestedItems": ["Clay", "Pottery Paints", "Clay"], "patience": 100, "visitedToday": false, "toolsOwned": [] }
            },
            'architect': {
                "Frank": { "request": "I'm drafting a new building. I need vellum and some fresh pencil lead.", "requestedItems": ["Vellum", "Pencil Lead"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Zaha": { "request": "I need to make a model for a presentation. Do you sell tiny trees?", "requestedItems": ["Tiny Trees"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Chris": { "request": "I'm working on some final designs and need some high-quality markers.", "requestedItems": ["Fancy Markers", "Vellum"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Renzo": { "request": "I've run out of pencil lead again.", "requestedItems": ["Pencil Lead"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Tadao": { "request": "I require vellum for some concrete plans.", "requestedItems": ["Vellum"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Maya": { "request": "I'm designing a park. I'll take all the tiny trees you have.", "requestedItems": ["Tiny Trees", "Tiny Trees"], "patience": 100, "visitedToday": false, "toolsOwned": [] },
                "Norman": { "request": "A set of your fanciest markers, if you please.", "requestedItems": ["Fancy Markers"], "patience": 100, "visitedToday": false, "toolsOwned": [] }
            }
        };

        async function generateCustomerRequest() {
            // Step 1: Determine the in-demand items for today (Day 2 onwards)
            let inDemandItems = new Set();
            if (day > 1 && marketForecast && marketForecast.length > 0) {
                // The forecast for the *current* day was set at the end of the *previous* day.
                // marketForecast[0] is for day 2, marketForecast[1] for day 3, etc.
                // So for the current day `D`, we need the forecast from index `D-2`.
                const forecastIndex = (day - 2 + 7) % 7; // Safer modulo for JS
                const todaysForecast = marketForecast[forecastIndex];
                if (todaysForecast && todaysForecast.recommendations) {
                    todaysForecast.recommendations.forEach(item => inDemandItems.add(item));
                }
            }

            const unlockedAndEnabledItems = new Set();
            Object.keys(enabledItems).forEach(item => {
                if (enabledItems[item]) {
                    // Check if the item is actually unlocked via storage
                    const isUnlocked = storageCells.some((cell, index) => unlocks.storage[index] && cell.allowedItems.includes(item));
                    if (isUnlocked) {
                        unlockedAndEnabledItems.add(item);
                    }
                }
            });

            const availableTypeKeys = Object.keys(customerTypes).filter(typeKey => {
                const typeItems = storageCells[customerTypes[typeKey].storageIndex].allowedItems;
                // An artist type is available if at least one of their items is enabled.
                return typeItems.some(item => unlockedAndEnabledItems.has(item));
            });


            if (availableTypeKeys.length === 0) {
                console.warn("No customer types available to spawn based on enabled items.");
                return null;
            }

            for (let i = 0; i < 50; i++) { // Increased retry loop for more complex filtering
                const chosenTypeKey = availableTypeKeys[Math.floor(Math.random() * availableTypeKeys.length)];
                const customersForType = customerProfiles[chosenTypeKey];

                const availableCustomers = Object.keys(customersForType).filter(name => {
                    if (customersForType[name].visitedToday) return false;
                    // A customer is only available if ALL their requested items are enabled.
                    return customersForType[name].requestedItems.every(item => unlockedAndEnabledItems.has(item));
                });


                if (availableCustomers.length === 0) {
                    continue; // Try another customer type
                }

                // Step 2: Implement weighted random selection
                const weightedCustomers = [];
                availableCustomers.forEach(customerName => {
                    const customer = customersForType[customerName];
                    // Base weight is 1. Add 1 for each in-demand item they want.
                    const weight = 1 + customer.requestedItems.filter(item => inDemandItems.has(item)).length;
                    for (let j = 0; j < weight; j++) {
                        weightedCustomers.push(customerName);
                    }
                });

                if (weightedCustomers.length === 0) {
                     continue; // Should not happen if availableCustomers has items, but as a safeguard.
                }

                const chosenCustomerName = weightedCustomers[Math.floor(Math.random() * weightedCustomers.length)];
                const customerData = { ...customersForType[chosenCustomerName] };

                // Mark the chosen customer as visited for the day
                customersForType[chosenCustomerName].visitedToday = true;

                return {
                    name: chosenCustomerName,
                    ...customerData,
                    customerType: chosenTypeKey
                };
            }

            return null; // Return null if no suitable customer is found
        }

        function generateCoffeeOrder() {
            if (!unlocks.facilities.coffeeShop || !coffeeShop.storage) {
                return null;
            }

            const availableIngredients = coffeeShop.storage.items;

            const availableRecipes = Object.keys(COFFEE_RECIPES).filter(recipeKey => {
                const recipe = COFFEE_RECIPES[recipeKey];
                return recipe.ingredients.every(ingredient => (availableIngredients[ingredient] || 0) > 0);
            });

            if (availableRecipes.length === 0) {
                return null; // No coffee can be made
            }

            const chosenRecipeKey = availableRecipes[Math.floor(Math.random() * availableRecipes.length)];
            const coffeeOrder = { ...COFFEE_RECIPES[chosenRecipeKey] }; // Create a copy
            coffeeOrder.key = chosenRecipeKey; // Store the key for reference
            coffeeOrder.hasSnack = false;

            // 33% chance of adding a snack if available
            if ((availableIngredients['Snacks'] || 0) > 0 && Math.random() < 0.33) {
                coffeeOrder.hasSnack = true;
                coffeeOrder.price += items['Snacks'].cost * 1.5; // Add snack price markup
            }

            return coffeeOrder;
        }

        let marketType = 'classic'; // Stores the player's choice. Can be 'classic', 'dailyMood', 'categoryFocus', or 'liveSimulation'.
        let originalItemCosts = {}; // Will store a clean copy of the base item costs.
        let dailyPlayerPurchases = {}; // For the 'Live Simulation' market.

        const marketStyleDescriptions = {
            disabled: "<strong>Market Disabled:</strong> All item costs will remain at their base value throughout the game. A simple, predictable experience.",
            classic: "<strong>Classic:</strong> The original market experience. Item costs will fluctuate slightly each day, creating small shifts in profitability.",
            dailyMood: "<strong>Daily Mood:</strong> Each day brings a new market-wide event. Watch for supplier surpluses, shipping crises, or price crashes that affect all items.",
            categoryFocus: "<strong>Category Focus:</strong> One or two art categories will be randomly selected each day to be either 'in-demand' (higher cost) or 'on sale' (lower cost).",
            liveSimulation: "<strong>Live Simulation:</strong> The most dynamic option. Prices react directly to your actions. Buying lots of one item will decrease its cost tomorrow, while high customer demand will increase it."
        };

        function generateMarketForecast() {
            const forecast = [];
            // Use a simulation for prices to generate accurate recommendations
            let simulatedPrices = JSON.parse(JSON.stringify(items)); // Deep copy of current prices for simulation

            for (let i = 0; i < 7; i++) {
                let dayEvent = { type: marketType, recommendations: [] };
                let nextDaySimulatedPrices = JSON.parse(JSON.stringify(simulatedPrices)); // Prices for the day being forecasted

                switch (marketType) {
                    case 'classic': {
                        const fluctuations = {};
                        Object.keys(items).forEach(itemName => {
                            const baseCost = originalItemCosts[itemName];
                            const fluctuation = (Math.random() - 0.5) * (baseCost * 0.2);
                            fluctuations[itemName] = fluctuation;

                            // Apply to simulated price for the next day
                            nextDaySimulatedPrices[itemName].cost += fluctuation;
                        });
                        dayEvent.fluctuations = fluctuations;
                        break;
                    }
                    case 'dailyMood': {
                        const mood = dailyMoodHeadlines[Math.floor(Math.random() * dailyMoodHeadlines.length)];
                        dayEvent.event = mood;

                        // First, apply a minor random fluctuation to all items from the previous simulated day's price.
                        Object.keys(nextDaySimulatedPrices).forEach(itemName => {
                            const baseCost = originalItemCosts[itemName];
                            if (baseCost) {
                                const fluctuation = (Math.random() - 0.5) * (baseCost * 0.1); // +/- 5%
                                nextDaySimulatedPrices[itemName].cost += fluctuation;
                            }
                        });

                        // Then, overwrite the price for event-specific items based on their original cost.
                        mood.effects.forEach(effect => {
                            const { category, modifier, items: affectedItems } = effect;
                            let targetItems = [];
                            if (category === "All") {
                                targetItems = Object.keys(items);
                            } else {
                                const storageCategory = storageCells.find(cell => cell.label === category);
                                if (storageCategory) targetItems = storageCategory.allowedItems;
                            }
                            targetItems.forEach(itemName => {
                                if (affectedItems === "all" || affectedItems.includes(itemName)) {
                                    const baseCost = originalItemCosts[itemName]; // Use original cost for event calculation
                                    if (baseCost) {
                                        nextDaySimulatedPrices[itemName].cost = parseFloat((baseCost * (1 + modifier)).toFixed(2));
                                    }
                                }
                            });
                        });
                        break;
                    }
                    case 'categoryFocus': {
                        const modifiers = {
                            "inDemand": { modifier: 0.25, message: "is in high demand! Prices are up." },
                            "onSale": { modifier: -0.20, message: "is on sale! Prices are down." }
                        };
                        const categories = [...storageCells];
                        let modifiedCategories = 0;
                        const maxChanges = 2;
                        const changes = [];
                        categories.sort(() => 0.5 - Math.random());

                        // First, apply a minor random fluctuation to all items from the previous simulated day's price.
                        Object.keys(nextDaySimulatedPrices).forEach(itemName => {
                            const baseCost = originalItemCosts[itemName];
                            if (baseCost) {
                                const fluctuation = (Math.random() - 0.5) * (baseCost * 0.1); // +/- 5%
                                nextDaySimulatedPrices[itemName].cost += fluctuation;
                            }
                        });

                        // Then, overwrite the price for event-specific categories based on their original cost.
                        for (const category of categories) {
                            if (modifiedCategories >= maxChanges) break;
                            if (Math.random() > 0.6) continue;

                            const modifierKeys = Object.keys(modifiers);
                            const chosenModifierKey = modifierKeys[Math.floor(Math.random() * modifierKeys.length)];
                            const chosenModifier = modifiers[chosenModifierKey];
                            changes.push({
                                categoryLabel: category.label,
                                modifier: chosenModifier.modifier,
                                message: chosenModifier.message
                            });
                            modifiedCategories++;

                            // Apply to simulated prices
                            category.allowedItems.forEach(itemName => {
                                if (items[itemName]) {
                                    const baseCost = originalItemCosts[itemName]; // Use original cost for event calculation
                                    if (baseCost) {
                                        nextDaySimulatedPrices[itemName].cost = parseFloat((baseCost * (1 + chosenModifier.modifier)).toFixed(2));
                                    }
                                }
                            });
                        }
                        dayEvent.changes = changes;
                        break;
                    }
                    case 'liveSimulation':
                    case 'disabled':
                        return [];
                }

                // Generate recommendations based on the simulated prices for the upcoming day
                Object.keys(nextDaySimulatedPrices).forEach(itemName => {
                    if (originalItemCosts[itemName] && nextDaySimulatedPrices[itemName].cost < originalItemCosts[itemName]) {
                        dayEvent.recommendations.push(itemName);
                    }
                });

                // Update the simulation for the next iteration
                simulatedPrices = nextDaySimulatedPrices;

                forecast.push(dayEvent);
            }
            return forecast;
        }

        const dailyMoodHeadlines = [
            // Positive Events
            {
                headline: "Titanium White Surplus Floods Market!",
                description: "A major paint manufacturer discovered a new, efficient refinement process, leading to a massive surplus of white pigment. Artists rejoice as a key component becomes cheaper than ever.",
                effects: [{ category: "Painting", modifier: -0.20, items: "all" }]
            },
            {
                headline: "Recycled Lumber Initiative Gains Traction",
                description: "Local initiatives to reclaim and process used lumber have proven successful, reducing the cost of raw materials for woodworkers. The program is being hailed as an environmental and economic victory.",
                effects: [{ category: "Woodworking", modifier: -0.15, items: "all" }]
            },
            {
                headline: "\"Sketch Daily\" App Goes Viral",
                description: "A new mobile app encouraging daily drawing habits has exploded in popularity, causing a boom in demand for basic supplies. Suppliers are offering discounts to capture the new wave of artists.",
                effects: [{ category: "Drawing", modifier: -0.10, items: "all" }]
            },
            {
                headline: "3D Printing Glues Deemed Overkill for Hobbyists",
                description: "A study reveals that most hobbyists are overpaying for industrial-strength glues when simpler, cheaper alternatives work just as well. This has led to a price correction in the model adhesive market.",
                effects: [{ category: "Models", modifier: -0.25, items: ["Glue"] }]
            },
            {
                headline: "Bountiful Harvest for Linseed Farmers",
                description: "Ideal weather conditions have resulted in a record-breaking harvest for linseed, a key ingredient in oil paints and wood stainers. The abundance of raw material is passing savings on to consumers.",
                effects: [
                    { category: "Painting", modifier: -0.10, items: "all" },
                    { category: "Woodworking", modifier: -0.10, items: "all" }
                ]
            },
            {
                headline: "Global Shipping Lanes Clear Up",
                description: "Recent international agreements have streamlined customs and reduced port congestion. The resulting drop in shipping costs has had a positive, deflationary effect on all imported goods.",
                effects: [{ category: "All", modifier: -0.05, items: "all" }]
            },
            // Negative Events
            {
                headline: "Rare Earth Pigment Mine Collapse Halts Production",
                description: "A critical mine supplying rare earth minerals for vibrant paint pigments has collapsed. The scarcity is expected to cause a sharp increase in the price of high-quality paints.",
                effects: [{ category: "Painting", modifier: 0.30, items: "all" }]
            },
            {
                headline: "Spotted Lanternfly Infestation Threatens Maple Trees",
                description: "A widespread infestation of the Spotted Lanternfly is devastating maple forests, a popular source of wood for sculptors and woodworkers. The cost of quality, unblemished lumber is soaring.",
                effects: [
                    { category: "Woodworking", modifier: 0.20, items: "all" },
                    { category: "Sculpture", modifier: 0.20, items: "all" }
                ]
            },
            {
                headline: "Architectural Firm Wins Prestigious Award With New Marker Style",
                description: "After a local firm won the Pritzker Prize, their lead architect credited a specific brand of \"Fancy Markers\" for their unique design style. This celebrity endorsement has caused a run on the markers, and prices have skyrocketed.",
                effects: [{ category: "Architectural", modifier: 0.25, items: ["Fancy Markers"] }]
            },
            {
                headline: "Factory Fire Destroys Model Kit Molds",
                description: "A fire at the largest model kit factory in the region has destroyed irreplaceable molds for classic and popular kits. Collectors and hobbyists are scrambling to buy up existing stock, driving up prices.",
                effects: [{ category: "Models", modifier: 0.40, items: "all" }]
            },
            {
                headline: "Graphite Dust Regulations Tighten",
                description: "New environmental regulations on graphite dust are forcing pencil and charcoal manufacturers to install expensive filtration systems. The cost is being passed on to the consumer.",
                effects: [{ category: "Drawing", modifier: 0.15, items: "all" }]
            },
            {
                headline: "Local Quarries Face Labor Dispute",
                description: "Ongoing labor disputes at several regional stone quarries have significantly slowed the supply of marble and carving stone. The shortage is causing major price hikes for sculptors.",
                effects: [{ category: "Sculpture", modifier: 0.35, items: "all" }]
            },
            {
                headline: "Inflation Concerns Spark Widespread Price Hikes",
                description: "Rising energy and labor costs are affecting all sectors of the economy. Art supply distributors have announced a general price increase across all product lines to compensate.",
                effects: [{ category: "All", modifier: 0.10, items: "all" }]
            },
            // Mixed Events
            {
                headline: "New Polymer Clay Praised for Wood-Like Finish",
                description: "A tech startup has released a new polymer clay that perfectly mimics the texture and finish of carved wood. Sculptors and model makers are flocking to the cheaper, easier-to-use material, causing a slump in the traditional lumber market.",
                effects: [
                    { category: "Sculpture", modifier: -0.15, items: "all" },
                    { category: "Woodworking", modifier: 0.05, items: "all" }
                ]
            },
            {
                headline: "\"The Great Outdoors\" Painting Competition Announced",
                description: "A national \"en plein air\" painting competition with a huge cash prize has been announced. The event has sparked a massive demand for portable canvases and watercolor sets, leading to supplier price hikes.",
                effects: [
                    { category: "Painting", modifier: 0.15, items: "all" },
                    { category: "Drawing", modifier: 0.05, items: "all" }
                ]
            },
            {
                headline: "Chemical Plant Fire Disrupts Supply Chain",
                description: "A fire at a key chemical manufacturing plant has created a critical shortage of solvents and acrylic polymers. This affects a wide range of products, from paints and glues to markers and finishing sprays.",
                effects: [
                    { category: "Painting", modifier: 0.10, items: "all" },
                    { category: "Models", modifier: 0.15, items: "all" },
                    { category: "Architectural", modifier: 0.05, items: "all" }
                ]
            },
            {
                headline: "Viral Trend Sees Artists \"Upcycling\" Old Tech",
                description: "A new art trend has artists creating sculptures from old computer parts and electronics. This has created a demand for strong glues and precision razors, while reducing the demand for traditional art paper and sketchbooks.",
                effects: [
                    { category: "Models", modifier: 0.10, items: "all" },
                    { category: "Drawing", modifier: -0.05, items: "all" }
                ]
            },
            {
                headline: "Film Studio Buys Bulk Vellum for Animated Feature",
                description: "A major animation studio has purchased nearly the entire global supply of high-grade vellum for a traditionally animated film. The move has created a shortage for architects, but has unexpectedly boosted sales of cheaper sketchbooks as an alternative.",
                effects: [
                    { category: "Architectural", modifier: 0.30, items: "all" },
                    { category: "Drawing", modifier: -0.05, items: "all" }
                ]
            },
            {
                headline: "Renowned Painter Denounces Digital Art",
                description: "Influential artist Jean-Pierre Monet publicly criticized the rise of digital art, calling for a return to \"pure, physical media.\" The speech has inspired a surge in oil and acrylic sales, but architectural firms, heavily reliant on digital drafting, are seeing supply costs drop as demand wanes.",
                effects: [
                    { category: "Painting", modifier: 0.15, items: "all" },
                    { category: "Architectural", modifier: -0.10, items: "all" }
                ]
            }
        ];

        let marketForecast = []; // Will hold the 7-day forecast array.
        let nextMarketForecast = []; // Will hold the next 7-day forecast, generated in advance.
        let currentDailyMood = null; // This will store the active headline object for the day.
        let tempMarketStyle = 'classic'; // To hold selection before confirming
        let newGameOptions = {};
        let previousNewGameScreen = '';
        let currentModalScreen = null;

        function openFinalSettingsScreen(options, previousScreen) {
            newGameOptions = options;
            previousNewGameScreen = previousScreen;
            hideScreen(previousScreen);
            showScreen('final-settings-screen');
        }

        function openMarketStyleModal() {
            tempMarketStyle = marketType; // Initialize with current setting
            const modal = document.getElementById('market-style-modal');
            if (modal) {
                modal.classList.remove('hidden');
                updateMarketModalUI();
            }
        }

        function updateMarketModalUI() {
            const descriptionPanel = document.getElementById('market-style-description');
            const buttons = document.querySelectorAll('.market-style-btn');

            buttons.forEach(btn => {
                const style = btn.dataset.style;
                if (style === tempMarketStyle) {
                    btn.classList.add('bg-green-700', 'hover:bg-green-600');
                    btn.classList.remove('bg-amber-700/60');
                } else {
                    btn.classList.remove('bg-green-700', 'hover:bg-green-600');
                    btn.classList.add('bg-amber-700/60');
                }
            });

            if (descriptionPanel) {
                descriptionPanel.innerHTML = marketStyleDescriptions[tempMarketStyle] || "<p>Select a style to see its description.</p>";
            }
        }

        function closeMarketStyleModal() {
            const modal = document.getElementById('market-style-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
        }

        let cash = 100;
        let day = 1;
        let shopPoints = 0;
        let itemPopularity = {};
        let priceHistory = {}; // Now stores { history: [], predictions: [] } for each item.
        let customers = [];
        let customerDemand = {};
        let canvas, ctx, pieClockCanvas, pieClockCtx;
        let lastTimestamp = 0;
        let running = true;
        let dayStarted = false;
        let developerMode = false;
        let continuousMode = false;
        let isMandatoryBreak = false;
        let dayShiftBreakTriggered = false;
        let nightShiftBreakTriggered = false;
        let casualNoBreaks = false;
        let casualNoDebtPenalty = false;
        let marketEnabled = false;
        let currentWeeklyAccruedBill = 0;
        let currentWeeklyLaborCost = 0;
        let currentWeeklyRentCost = 0;
        let currentWeeklyStorageCost = 0;
        let currentWeeklyCoffeeCost = 0;
        let coffeeShopExists = true;
        let isPaused = false;
        let timeMultiplier = 1;
        let isGameActive = false;

        // WebRTC Companion Variables
        let peer = null;
        let hostConnection = null;
        let companionConnection = null;
        let lastSentState = null;

        const OPENING_DURATION = 30000; // 30 seconds
        const DAY_SHIFT_DURATION = 60000; // 1 minute
        const NIGHT_SHIFT_DURATION = 60000; // 1 minute
        const CLOSING_DURATION = 30000; // 30 seconds
        let BREAK_DURATION = 20000; // 20 seconds
        const DAY_DURATION = OPENING_DURATION + DAY_SHIFT_DURATION + NIGHT_SHIFT_DURATION + CLOSING_DURATION;
        let dayTimer = DAY_DURATION;
        let dayPhase = 'pre-open'; // 'pre-open', 'opening', 'day-shift', 'night-shift', 'closing'
        let zone1PointTimer = 0;
        let coffeeShopBehindCounterTimer = 0;

        let CUSTOMER_SPAWN_INTERVAL = 8000;
        let timeSinceLastCustomer = 0;
        let floatingTexts = [];
        let clipboardUpdateTimer = 0;
        const CLIPBOARD_UPDATE_INTERVAL = 250; // ms
        let companionUpdateTimer = 0;
        const COMPANION_UPDATE_INTERVAL = 1000; // ms, for 1-second updates
        let dailySalesReport = [];
        let startingDayInventory = {};
        let dailySupplyOrders = [];
        let dailyLaborCosts = {};
        let dailyEmployeeWorkTimes = {};

        const COFFEE_RECIPES = {
            plain: { name: "Plain Coffee", price: 3, ingredients: ["Beans"] },
            tan: { name: "Tan Coffee", price: 7, ingredients: ["Beans", "Milks"] },
            sweet: { name: "Sweet Coffee", price: 7, ingredients: ["Beans", "Sugar"] },
            rich: { name: "Rich Coffee", price: 10, ingredients: ["Beans", "Milks", "Sugar"] }
        };

        // Camera and zoom variables
        let cameraX = 0;
        let cameraY = 0;
        let targetCameraX = 0;
        let cameraState = 'store'; // 'store' or 'office'
        let officeWidth;
        let worldWidth;


        const desk = { x: 0, y: 0, width: 0, height: 30 };
        const loadingDock = { x: 0, y: 0, width: 0, height: 50 };
        const cashierCounter = { x: 0, y: 0, w: 40, h: 120 };
        const coffeeShop = {
            rect: { x: 0, y: 0, w: 0, h: 0 },
            y: 0,
            behindCounterZone: { x: 0, y: 0, w: 0, h: 0 },
            storage: null // A single storage object for all coffee items
        };
        const managersOffice = { x: 0, y: 0, w: 100, h: 100 };
        const officeComputer = { x: 0, y: 0, w: 0, h: 0 };
        const officeZone1 = { x: 0, y: 0, w: 0, h: 0 };
        const officeZone2 = { x: 0, y: 0, w: 0, h: 0 };
        const officeZone3 = { x: 0, y: 0, w: 0, h: 0 };
        const cashRegister = { x: 0, y: 0, width: 60, height: 50 };
        const clipboard = { x: 0, y: 0, width: 50, height: 60 };
        const shoppingBasket = { x: 0, y: 0, width: 60, height: 50 };
        const lockIcon = { x: 0, y: 0, width: 50, height: 50 };
        const phoneIcon = { x: 0, y: 0, width: 50, height: 50 };
        let storageCells = [];
        let shelves = [];
        const MAX_BASKET_SIZE = 5;
        const MAX_SHELF_STACK = 10;
        const STOCKER_BASKET_SIZE = 6 * MAX_SHELF_STACK;
        const BARISTA_BASKET_SIZE = 10;
        const MAX_PACKAGE_SIZE = 20;
        const PACKAGE_WIDTH = 60;
        const PACKAGE_HEIGHT = 50;
        let loadingDockPackages = [];

        let unlocks = {
            employees: { cashier: false, stocker: false, barista: false, manager: false, salesperson: false },
            shelves: [true, false, false, false, false, false],
            facilities: { coffeeShop: false },
            storage: [true, false, false, false, false, false]
        };

        const unlockCosts = {
            employees: { cashier: 10, stocker: 15, barista: 20, manager: 50, salesperson: 30 },
            shelves: [null, 5, 10, 20, 40, 80], // index 0 is free
            facilities: { coffeeShop: 100 },
            storage: [10, 20, 30, 40, 50, 60]
        };

        let employeeWorkTimers = {
            cashier: 0,
            stocker: 0,
            barista: 0,
            manager: 0,
            salesperson: 0
        };

        const employeePayRates = { // per minute
            cashier: 2,
            stocker: 1,
            barista: 3,
            manager: 5,
            salesperson: 0
        };
        let originalEmployeePayRates = {};

        const dailyOperatingCosts = {
            rent: 5,
            storageUnitWeeklyRate: 10,
            coffeeShop: 2
        };

        const player = {
            x: 100, y: 300, width: 50, height: 50, speed: 250,
            targetX: null,
            targetY: null,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            basket: []
        };

        const stocker = {
            x: 300, y: 300, width: 50, height: 50, speed: 180,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            basket: [],
            task: null,
            stateTimer: 0,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false,
            breakTakenToday: false,
            shift: ['Day Shift'],
            breakPreference: 'first'
        };

        const cashier = {
            x: 100, y: 300, width: 50, height: 50, speed: 200,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            task: null,
            stateTimer: 0,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false,
            breakTakenToday: false,
            basket: [],
            shift: ['Day Shift'],
            breakPreference: 'first'
        };

        const barista = {
            x: 600, y: 600, width: 50, height: 50, speed: 160,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            basket: [],
            task: null,
            stateTimer: 0,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false,
            breakTakenToday: false,
            shift: ['Day Shift'],
            breakPreference: 'first'
        };
        const manager = {
            x: 200, y: 300, width: 50, height: 50, speed: 150,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            task: null,
            stateTimer: 5000,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false,
            canOrder: true,
            lastOrderQuarter: -1,
                hasPlacedMorningOrder: false,
            shift: ['Day Shift'],
            breakPreference: 'first'
        };

        const salesperson = {
            x: 400, y: 400, width: 50, height: 50, speed: 120,
            currentFrame: 0, frameWidth: 90, frameHeight: 90,
            animationSpeed: 150, lastFrameTime: 0,
            state: 'idle', facing: 'right',
            task: null,
            stateTimer: 0,
            idleX: 0, idleY: 0,
            onBreak: false,
            playerInitiatedBreak: false,
            breakTakenToday: false,
            basket: [],
            shift: ['Day Shift'],
            breakPreference: 'first'
        };

        const breakSpots = {
            cashier:     { x: 30, y: 15 }, // Top chair
            stocker:     { x: 60, y: 65 }, // Bottom chair
            barista:      { x: 10, y: 40 }, // Left of table
            manager:     { x: 85, y: 40 }, // Right of table
            salesperson: { x: 45, y: 40 }  // Center of table
        };

        function getBreakSpot(employeeKey) {
            const spot = breakSpots[employeeKey];
            // The break spot coordinates are relative to the break room (officeZone3)
            return {
                x: officeZone3.x + spot.x,
                y: officeZone3.y + spot.y
            };
        }

        const animations = {
            'idle': { startFrame: 0, frames: 3, cols: 3 },
            'walk': { startFrame: 3, frames: 3, cols: 3 }
        };

        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'KeyF') {
                 // Legacy keybind, now opens phone to orders
                openClipboardPanel();
                showAppScreen('restock-panel');
            } else if (e.code === 'KeyG') {
                toggleBasketExpansion();
            } else if (e.code === 'KeyT') {
                // Legacy keybind, now opens phone to unlocks
                openClipboardPanel();
                showAppScreen('unlocks-panel');
            } else if (e.code === 'KeyE') {
                handleInteraction();
            } else if (e.code === 'Escape') {
                if (isPhoneOpen) {
                    if (activePhoneScreen) {
                        showAppGrid(); // Go back to app grid
                    } else {
                        closeClipboard(); // Close phone from app grid
                    }
                } else if (activePanel) {
                    // Handle legacy panels if any are still in use
                    togglePanel(activePanel, false);
                }
            }
        });


        let items = {
            // Drawing (formerly General)
            'Pencil': { sellPrice: 1, baseCost: 0.25 }, 'Charcoal': { sellPrice: 2, baseCost: 0.50 }, 'Markers': { sellPrice: 5, baseCost: 1.25 }, 'Sketchbook': { sellPrice: 10, baseCost: 2.50 },
            // Painting (formerly Quality)
            'Water Color': { sellPrice: 5, baseCost: 1.25 }, 'Oils': { sellPrice: 5, baseCost: 1.25 }, 'Acrylics': { sellPrice: 10, baseCost: 2.50 }, 'Canvas': { sellPrice: 20, baseCost: 5.00 },
            // Models
            'Razors': { sellPrice: 5, baseCost: 1.25 }, 'Glue': { sellPrice: 7, baseCost: 1.75 }, 'Mini Paints': { sellPrice: 20, baseCost: 5.00 }, 'Model Kits': { sellPrice: 50, baseCost: 12.50 },
            // Woodworking (formerly Sculpture)
            'Sanding Paper': { sellPrice: 10, baseCost: 2.50 }, 'Stainer': { sellPrice: 20, baseCost: 5.00 }, 'Wood Scraps': { sellPrice: 50, baseCost: 12.50 }, 'Lumber': { sellPrice: 100, baseCost: 25.00 },
            // Sculpture (formerly Painting)
            'Clay': { sellPrice: 20, baseCost: 5.00 }, 'Pottery Paints': { sellPrice: 50, baseCost: 12.50 }, 'Stone': { sellPrice: 150, baseCost: 37.50 }, 'Marble': { sellPrice: 300, baseCost: 75.00 },
            // Architectural (formerly Drawing)
            'Pencil Lead': { sellPrice: 20, baseCost: 5.00 }, 'Vellum': { sellPrice: 75, baseCost: 18.75 }, 'Fancy Markers': { sellPrice: 100, baseCost: 25.00 }, 'Tiny Trees': { sellPrice: 200, baseCost: 50.00 },
            // Coffee Shop
            'Beans': { sellPrice: 1, baseCost: 0.25 }, 'Milks': { sellPrice: 2, baseCost: 0.50 }, 'Sugar': { sellPrice: 2, baseCost: 0.50 }, 'Snacks': { sellPrice: 3, baseCost: 0.75 }
        };

        let inventory = {};
        // Initialize inventory for a new game. This will be overwritten by loadGame if a save exists.
        Object.keys(items).forEach(item => inventory[item] = 5);
        let enabledItems = {};
        Object.keys(items).forEach(item => enabledItems[item] = true);


        class Customer {
            constructor(profile, name, request, requestedItems, customerType) {
                this.id = Math.random();
                this.profile = profile; // Reference to the persistent profile
                this.name = name;
                this.request = request;
                this.requestedItems = requestedItems;
                this.customerType = customerType;
                this.patience = this.profile.patience; // Use persistent patience
                this.initialPatience = this.profile.patience; // For sales report
                this.waitTimer = 0; // New timer for interaction logic
                this.discount = 0; // Discount for special interactions
                this.budget = Math.floor(Math.random() * 91) + 10;
                this.x = canvas.width + 50;
                this.y = desk.y + 75;
                this.targetX = canvas.width - 150;
                this.targetY = desk.y + 75;
                this.speed = 80;
                this.isServed = false;
                this.leaving = false;

                this.state = 'entering';
                this.isInteractedWith = false;
                this.needsAssistanceFulfilled = false;
                this.hasReachedWaitingPoint = false;
                this.helpedBySalesperson = false;

                const rand = Math.random();
                if (rand < 0.4) {
                    this.behaviorType = 'direct';
                } else if (rand < 0.8) {
                    this.behaviorType = 'needsInteraction';
                } else {
                    this.behaviorType = 'needsAssistance';
                }
                this.facing = 'left';
                this.currentFrame = 0;
                this.lastFrameTime = 0;
                this.animationSpeed = 150;
                this.frameWidth = 90;
                this.frameHeight = 90;
                this.speechBubbleTimer = 0;
                this.showSpeechBubble = false;
                this.order = [];
                this.stateTimer = 0;
                this.currentItemIndex = 0;
                this.isWaitingForRestock = false;
                this.boughtCoffee = false;
                this.coffeeOrder = null;

                this.spriteImage = new Image();
                this.spriteSheetLoaded = false;
            }

            draw() {
                if (this.spriteSheetLoaded) {
                    drawCharacter(this, this.spriteImage, '', '', false);
                }

                if (this.showSpeechBubble) {
                    const bubbleWidth = 200, bubbleHeight = 80;
                    const bubbleX = this.x - bubbleWidth / 2, bubbleY = this.y - 185;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = '#5d4037';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(bubbleX + 10, bubbleY); ctx.lineTo(bubbleX + bubbleWidth - 10, bubbleY);
                    ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + 10);
                    ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - 10);
                    ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - 10, bubbleY + bubbleHeight);
                    ctx.lineTo(this.x + 10, bubbleY + bubbleHeight); ctx.lineTo(this.x, this.y - 80); ctx.lineTo(this.x - 10, bubbleY + bubbleHeight);
                    ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight);
                    ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - 10);
                    ctx.lineTo(bubbleX, bubbleY + 10);
                    ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + 10, bubbleY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = '#5d4037';
                    ctx.font = '16px "Patrick Hand", cursive';
                    ctx.textAlign = 'center';
                    wrapText(ctx, this.request, this.x, bubbleY + 20, bubbleWidth - 20, 20);
                }

                // Assistance indicators
                const indicatorY = this.y - this.frameHeight - 25;
                if (this.behaviorType === 'needsInteraction' && !this.isInteractedWith) {
                    ctx.font = 'bold 36px "Indie Flower", cursive';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 150, 255, 0.9)';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.5)';
                    ctx.fillText('?', this.x, indicatorY);
                    ctx.shadowBlur = 0; // Reset shadow
                    ctx.fillStyle = '#fff';
                    ctx.fillText('?', this.x, indicatorY);
                } else if (this.behaviorType === 'needsAssistance' && !this.needsAssistanceFulfilled) {
                    ctx.font = 'bold 36px "Indie Flower", cursive';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 255, 100, 0.9)';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = 'rgba(0, 255, 100, 0.5)';
                    ctx.fillText('!', this.x, indicatorY);
                    ctx.shadowBlur = 0; // Reset shadow
                    ctx.fillStyle = '#fff';
                    ctx.fillText('!', this.x, indicatorY);
                }


                ctx.font = '20px "Indie Flower", cursive';
                ctx.textAlign = 'center';
                const displayName = this.name;
                ctx.fillText(displayName, this.x, this.y - this.frameHeight);
            }

            findNextItemTarget() {
                const itemToFind = this.requestedItems[this.currentItemIndex];
                if (!enabledItems[itemToFind]) {
                    return false; // Item is toggled off, cannot be found.
                }
                const targetShelf = shelves.find(s => s.items.some(i => i && i.assignedItem === itemToFind && i.quantity > 0));
                 if (targetShelf) {
                     this.targetX = targetShelf.rect.x + targetShelf.rect.w / 2;
                     this.targetY = targetShelf.rect.y + targetShelf.rect.h + 20;
                     return true;
                 }
                return false;
            }

            update(deltaTime) {
                if (this.state !== 'leaving' && dayPhase === 'closing') {
                    logCustomerToSalesReport(this);
                    this.state = 'leaving';
                    this.request = "Oh, it's closing time! I'll come back another day.";
                }

                const anim = animations[this.state === 'idle' || this.state === 'waitingAtCounter' || (this.state === 'waitingForInteraction' && this.hasReachedWaitingPoint) ? 'idle' : 'walk'];
                this.lastFrameTime += deltaTime;
                if (this.lastFrameTime >= this.animationSpeed) {
                    this.currentFrame = (this.currentFrame + 1) % anim.frames;
                    this.lastFrameTime = 0;
                }
                if (this.speechBubbleTimer > 0) {
                    this.speechBubbleTimer -= deltaTime;
                    if (this.speechBubbleTimer <= 0) {
                        this.showSpeechBubble = false;
                    }
                }
                switch(this.state) {
                    case 'entering':
                        this.targetY = desk.y + 75;
                        if (this.moveTowardsTarget(deltaTime)) {
                            switch (this.behaviorType) {
                                case 'direct':
                                    this.state = 'browsing';
                                    if (!this.findNextItemTarget()) {
                                        this.request = `Hmm, I don't see any ${this.requestedItems[0]}. I'll look around.`;
                                        this.state = 'wandering';
                                        this.isWaitingForRestock = true;
                                        this.stateTimer = 0;
                                    }
                                    break;
                                case 'needsInteraction':
                                    this.state = 'waitingForInteraction';
                                    this.request = "Hello? Could someone help me find something?";
                                    this.showSpeechBubble = true;
                                    this.speechBubbleTimer = 5000;
                                    // Set target to a point past the shelves
                                    const firstShelfX = shelves[0].rect.x;
                                    const lastShelf = shelves[shelves.length - 1];
                                    const lastShelfX = lastShelf.rect.x + lastShelf.rect.w;
                                    this.targetX = (firstShelfX + lastShelfX) / 2; // Middle of aisle
                                    this.targetY = shelves[0].rect.y + shelves[0].rect.h + 40; // Below shelves
                                    break;
                                case 'needsAssistance':
                                    this.state = 'waitingForAssistance';
                                    this.request = "Could someone get these items for me, please?";
                                    this.showSpeechBubble = true;
                                    this.speechBubbleTimer = 5000;
                                    // Start wandering
                                    this.stateTimer = 0;
                                    break;
                            }
                        }
                        break;
                    case 'browsing':
                        if (this.moveTowardsTarget(deltaTime)) {
                            this.state = 'takingItem';
                            this.stateTimer = 1000;
                        }
                        break;
                    case 'takingItem':
                        this.stateTimer -= deltaTime;
                        if (this.stateTimer <= 0) {
                            const currentItem = this.requestedItems[this.currentItemIndex];
                            const shelf = shelves.find(s => s.items.some(i => i && i.assignedItem === currentItem));
                            if(shelf) {
                                const slot = shelf.items.find(i => i && i.assignedItem === currentItem && i.quantity > 0);
                                if (slot) {
                                    slot.quantity--;
                                    this.order.push(currentItem);
                                    this.currentItemIndex++; // <-- FIX: This was missing!
                                     if(this.currentItemIndex >= this.requestedItems.length) {
                                        const coffeeOrder = generateCoffeeOrder();
                                        if (coffeeOrder) {
                                            this.coffeeOrder = coffeeOrder;
                                            this.request = `I'll take a ${this.coffeeOrder.name}${this.coffeeOrder.hasSnack ? ' and a snack' : ''}!`;
                                            this.showSpeechBubble = true;
                                            this.speechBubbleTimer = 3000;
                                            this.state = 'goingToCoffeeShop';
                                        } else {
                                            this.request = `Got everything! Time to check out.`;
                                            this.state = 'queuing';
                                        }
                                     } else {
                                         this.state = 'browsing';
                                         if(!this.findNextItemTarget()){
                                             this.request = `Can't find the other items... I'll just look around.`;
                                             this.state = 'wandering';
                                             this.isWaitingForRestock = true;
                                             this.stateTimer = 0;
                                         }
                                     }
                                } else {
                                    this.request = `They're out of ${currentItem}!`;
                                    logCustomerToSalesReport(this);
                                    this.state = 'leaving';
                                }
                            } else {
                                 this.request = `They're out of ${currentItem}!`;
                                 logCustomerToSalesReport(this);
                                 this.state = 'leaving';
                            }
                        }
                        break;
                    case 'wandering':
                        this.waitTimer += (deltaTime / 1000); // Start waiting (in seconds)
                        this.stateTimer -= deltaTime;
                        if (this.stateTimer <= 0 || this.moveTowardsTarget(deltaTime)) {
                            this.stateTimer = Math.random() * 4000 + 2000; // Wander for 2-6 seconds

                            if (this.isWaitingForRestock && this.findNextItemTarget()) {
                                this.state = 'browsing';
                                this.request = `Oh, they have the ${this.requestedItems[this.currentItemIndex]} now!`;
                                this.isWaitingForRestock = false;
                                this.waitTimer = 0; // Reset timer
                                return;
                            }

                            const firstShelfX = shelves[0].rect.x;
                            const lastShelf = shelves[shelves.length - 1];
                            const lastShelfX = lastShelf.rect.x + lastShelf.rect.w;
                            const shelfYArea = shelves[0].rect.y + shelves[0].rect.h + 60;

                            this.targetX = Math.random() * (lastShelfX - firstShelfX) + firstShelfX;
                            this.targetY = Math.random() * 100 + shelfYArea - 50;
                        }
                        break;
                    case 'waitingForInteraction':
                        if (!this.hasReachedWaitingPoint) {
                            if (this.moveTowardsTarget(deltaTime)) {
                                this.hasReachedWaitingPoint = true;
                                this.facing = 'down'; // Face forward
                            }
                        } else {
                            this.waitTimer += (deltaTime / 1000); // Start waiting once in position (in seconds)
                        }

                        if (this.isInteractedWith) {
                            this.waitTimer = 0; // Reset wait timer
                            this.state = 'browsing';
                            this.request = "Ah, thank you! Let me see...";
                            this.showSpeechBubble = true;
                            this.speechBubbleTimer = 3000;
                            if (!this.findNextItemTarget()) {
                                this.request = `Hmm, I still don't see what I need. I'll look around.`;
                                this.state = 'wandering';
                                this.isWaitingForRestock = true;
                                this.stateTimer = 0;
                            }
                        }
                        break;
                    case 'waitingForAssistance':
                        this.waitTimer += (deltaTime / 1000); // Start waiting (in seconds)
                        // Wander around until order is fulfilled
                        this.stateTimer -= deltaTime;
                        if (this.stateTimer <= 0 || this.moveTowardsTarget(deltaTime)) {
                            this.stateTimer = Math.random() * 5000 + 3000;
                            const firstShelfX = shelves[0].rect.x;
                            const lastShelf = shelves[shelves.length - 1];
                            const lastShelfX = lastShelf.rect.x + lastShelf.rect.w;
                            const shelfYArea = shelves[0].rect.y + shelves[0].rect.h + 60;
                            this.targetX = Math.random() * (lastShelfX - firstShelfX) + firstShelfX;
                            this.targetY = Math.random() * 100 + shelfYArea - 50;
                        }
                        // The check for fulfillment will be external (player/salesperson)
                        // and will change the customer's state directly to 'queuing'.
                        break;
                    case 'queuing':
                    case 'waitingAtCounter': {
                        const waitingCustomers = customers
                            .filter(c => ['queuing', 'waitingAtCounter'].includes(c.state))
                            .sort((a,b) => a.x - b.x);
                        const myQueueIndex = waitingCustomers.findIndex(c => c.id === this.id);
                        if (myQueueIndex !== -1) {
                             this.targetX = cashierCounter.x + cashierCounter.w + 60 + myQueueIndex * 90;
                             this.targetY = cashierCounter.y + cashierCounter.h / 2;
                        }
                        if (this.state === 'queuing' && this.moveTowardsTarget(deltaTime)) {
                            this.state = 'waitingAtCounter';
                        } else {
                            this.moveTowardsTarget(deltaTime);
                        }
                        break;
                    }
                    case 'goingToCoffeeShop':
                        this.targetX = coffeeShop.rect.x + coffeeShop.rect.w / 2;
                        this.targetY = coffeeShop.collisionLineY + 20;
                        if (this.moveTowardsTarget(deltaTime)) {
                            this.state = 'waitingForCoffee';
                            this.stateTimer = 5000; // 5 seconds to be served
                        }
                        break;
                    case 'waitingForCoffee':
                        this.stateTimer -= deltaTime;
                        const playerIsServing = isPlayerInZone(coffeeShop.behindCounterZone);
                        const baristaIsServing = unlocks.employees.barista && !barista.onBreak && Math.hypot(barista.x - barista.idleX, barista.y - barista.idleY) < 10;

                        if (this.coffeeOrder && (playerIsServing || baristaIsServing)) {
                            this.coffeeOrder.ingredients.forEach(ingredient => {
                                if (coffeeShop.storage.items[ingredient] > 0) {
                                    coffeeShop.storage.items[ingredient]--;
                                }
                            });
                            if (this.coffeeOrder.hasSnack) {
                                if (coffeeShop.storage.items['Snacks'] > 0) {
                                    coffeeShop.storage.items['Snacks']--;
                                }
                            }

                            cash += this.coffeeOrder.price;
                            updateUI(); // Refresh the cash display
                            this.boughtCoffee = true;

                            let floatingText = `${this.coffeeOrder.name}! +$${this.coffeeOrder.price.toFixed(2)}`;
                            if (this.coffeeOrder.hasSnack) {
                                floatingText += " (w/ Snack)";
                            }
                            const saleOrigin = playerIsServing ? player : barista;
                            spawnFloatingText(floatingText, saleOrigin.x, saleOrigin.y - 80, '#654321');

                            this.request = "Great, now to pay for everything else.";
                            this.showSpeechBubble = true;
                            this.speechBubbleTimer = 3000;
                            this.state = 'queuing';

                        } else if (this.stateTimer <= 0) {
                            this.request = "Guess no one's working at the coffee bar...";
                            this.showSpeechBubble = true;
                            this.speechBubbleTimer = 3000;
                            this.state = 'queuing';
                        }
                        break;
                    case 'leaving':
                        this.targetX = worldWidth + 100;
                        this.targetY = desk.y + 75;
                        this.moveTowardsTarget(deltaTime);
                        break;
                }
            }

            moveTowardsTarget(deltaTime) {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 5) return true;
                const moveX = (dx / dist) * this.speed * (deltaTime / 1000);
                const moveY = (dy / dist) * this.speed * (deltaTime / 1000);
                this.x += moveX;
                this.y += moveY;
                this.facing = moveX > 0 ? 'right' : 'left';
                return false;
            }
        }

        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const testWidth = context.measureText(testLine).width;
                if (testWidth > maxWidth && n > 0) {
                    context.fillText(line, x, y);
                    line = words[n] + ' ';
                    y += lineHeight;
                } else {
                    line = testLine;
                }
            }
            context.fillText(line, x, y);
        }

        function drawLoadingDock() {
            ctx.save(); // Save context state

            // Create a clipping path for the loading dock area
            ctx.beginPath();
            ctx.rect(loadingDock.x, loadingDock.y, loadingDock.width, loadingDock.height);
            ctx.clip();

            ctx.fillStyle = 'rgba(255, 235, 59, 0.3)'; // Light yellow background
            ctx.fillRect(loadingDock.x, loadingDock.y, loadingDock.width, loadingDock.height);

            ctx.strokeStyle = 'rgba(255, 193, 7, 0.6)'; // Darker yellow for hatching
            ctx.lineWidth = 4;
            const spacing = 40;
            ctx.beginPath();
            // Draw hatching lines that cover the entire visible canvas, but will be clipped
            for (let i = -canvas.height; i < worldWidth; i += spacing) {
                ctx.moveTo(i, canvas.height);
                ctx.lineTo(i + loadingDock.height, loadingDock.y);
            }
             for (let i = worldWidth + canvas.height; i > 0; i -= spacing) {
                ctx.moveTo(i, canvas.height);
                ctx.lineTo(i - loadingDock.height, loadingDock.y);
            }
            ctx.stroke();

            ctx.restore(); // Restore context state, removing the clip

            // Draw the dividing line if the coffee shop is unlocked
            if (unlocks.facilities.coffeeShop) {
                ctx.strokeStyle = 'rgba(93, 64, 55, 0.5)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(coffeeShop.rect.x, loadingDock.y);
                ctx.lineTo(coffeeShop.rect.x, loadingDock.y + loadingDock.height);
                ctx.stroke();
            }

            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;
            ctx.strokeRect(loadingDock.x, loadingDock.y, loadingDock.width, loadingDock.height-1);
        }

        function drawCoffeeSign(x, y, shopWidth, shopHeight) {
            const coffeeDarkBrown = '#4a2e1c';
            const coffeeSignColor = '#eaddc7';
            const coffeeTextColor = '#5d4037';

            const signY = y + shopHeight * 0.1;
            const signHeight = shopHeight * 0.17;
            const signX = x + shopWidth * 0.07;
            const signWidth = shopWidth * 0.86;
            ctx.fillStyle = coffeeSignColor;
            ctx.fillRect(signX, signY, signWidth, signHeight);
            ctx.strokeStyle = coffeeDarkBrown;
            ctx.strokeRect(signX, signY, signWidth, signHeight);

            // "Coffee" Text (Pixelated)
            ctx.fillStyle = coffeeTextColor;
            const letterC = [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]];
            const letterO = [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]];
            const letterF = [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0]];
            const letterE = [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,1,1,1]];
            const coffeeTextMap = [letterC, letterO, letterF, letterF, letterE, letterE];
            const pixelSize = Math.max(1, Math.floor(signHeight / 10));
            const letterWidth = 5 * pixelSize;
            const letterHeight = 5 * pixelSize;
            const textBlockWidth = (coffeeTextMap.length * letterWidth) + ((coffeeTextMap.length - 1) * pixelSize * 2);
            let textX = signX + (signWidth - textBlockWidth) / 2;
            const textY = signY + (signHeight - letterHeight) / 2;

            coffeeTextMap.forEach(letter => {
                for(let r=0; r<5; r++){
                    for(let c=0; c<5; c++){
                        if(letter[r][c]) {
                            ctx.fillRect(textX + c*pixelSize, textY + r*pixelSize, pixelSize, pixelSize);
                        }
                    }
                }
                textX += letterWidth + (pixelSize * 2);
            });
        }

        function drawCoffeeWindow(x, y, shopWidth, shopHeight) {
            const coffeeDarkBrown = '#4a2e1c';
            const coffeeWindowColor = '#d7ccc8';

            const windowY = y + shopHeight * 0.3;
            const windowHeight = shopHeight * 0.4;
            const windowX = x + shopWidth * 0.03;
            const windowWidth = shopWidth * 0.94;
            ctx.fillStyle = coffeeDarkBrown;
            ctx.fillRect(windowX, windowY, windowWidth, windowHeight);
            ctx.fillStyle = coffeeWindowColor;
            ctx.fillRect(windowX + shopWidth * 0.03, windowY + shopHeight * 0.03, windowWidth - shopWidth * 0.06, windowHeight - shopHeight * 0.06);
        }

        function drawEspressoMachine(x, y, shopWidth, shopHeight) {
            const machineW = shopWidth * 0.2;
            const machineH = shopHeight * 0.14;
            const machineX = x + shopWidth * 0.13;
            const machineY = y + (shopHeight * 0.7) - machineH;

            ctx.fillStyle = '#9e9e9e';
            ctx.fillRect(machineX, machineY, machineW, machineH);
            ctx.strokeStyle = '#424242';
            ctx.strokeRect(machineX, machineY, machineW, machineH);
            ctx.fillStyle = '#616161';
            ctx.fillRect(machineX + machineW * 0.1, machineY + machineH * 0.2, machineW * 0.3, machineH * 0.2);
            ctx.fillRect(machineX + machineW * 0.6, machineY + machineH * 0.2, machineW * 0.3, machineH * 0.2);
        }

        function drawCoffeeCounter(x, y, shopWidth, shopHeight) {
            const coffeeDarkBrown = '#4a2e1c';
            const coffeeMidBrown = '#6d4c41';

            const counterY = y + shopHeight * 0.73;
            const counterHeight = shopHeight * 0.04;
            ctx.fillStyle = coffeeMidBrown;
            ctx.fillRect(x, counterY, shopWidth, counterHeight);
            ctx.strokeStyle = coffeeDarkBrown;
            ctx.strokeRect(x, counterY, shopWidth, counterHeight);
        }

        function drawStools(x, y, shopWidth, shopHeight) {
            const coffeeMidBrown = '#6d4c41';
            const stoolY = y + shopHeight * 0.77;

            const stoolW = shopWidth * 0.1;
            const stoolH = shopHeight * 0.06;
            const legH = shopHeight * 0.04;
            const legW = shopWidth * 0.015;

            const stoolX1 = x + shopWidth * 0.5;
            ctx.fillStyle = coffeeMidBrown;
            ctx.fillRect(stoolX1, stoolY, stoolW, stoolH); // Seat
            ctx.fillRect(stoolX1 + stoolW * 0.15, stoolY + stoolH, legW, legH); // Leg 1
            ctx.fillRect(stoolX1 + stoolW * 0.7, stoolY + stoolH, legW, legH); // Leg 2

            const stoolX2 = x + shopWidth * 0.67;
            ctx.fillRect(stoolX2, stoolY, stoolW, stoolH); // Seat
            ctx.fillRect(stoolX2 + stoolW * 0.15, stoolY + stoolH, legW, legH); // Leg 1
            ctx.fillRect(stoolX2 + stoolW * 0.7, stoolY + stoolH, legW, legH); // Leg 2

            const stoolX3 = x + shopWidth * 0.84;
            ctx.fillRect(stoolX3, stoolY, stoolW, stoolH); // Seat
            ctx.fillRect(stoolX3 + stoolW * 0.15, stoolY + stoolH, legW, legH); // Leg 1
            ctx.fillRect(stoolX3 + stoolW * 0.7, stoolY + stoolH, legW, legH); // Leg 2
        }

        function drawForRentSign(x, y, shopWidth, shopHeight) {
            const windowY = y + shopHeight * 0.3;
            const windowHeight = shopHeight * 0.4;
            const windowX = x + shopWidth * 0.03;
            const windowWidth = shopWidth * 0.94;

            const centerX = windowX + windowWidth / 2;
            const centerY = windowY + windowHeight / 2;

            ctx.save();
            ctx.translate(centerX, centerY);
            // No rotation for a straight sign

            const signWidth = windowWidth * 0.8;
            const signHeight = windowHeight * 0.3;
            const signX = -signWidth / 2;
            const signY = -signHeight / 2;

            // Sign background
            ctx.fillStyle = '#ffffff'; // white
            ctx.fillRect(signX, signY, signWidth, signHeight);

            // Sign border
            ctx.strokeStyle = '#000000'; // black
            ctx.lineWidth = 3;
            ctx.strokeRect(signX, signY, signWidth, signHeight);

            // Text
            ctx.fillStyle = '#000000';
            ctx.font = `bold ${signHeight * 0.5}px "VT323", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('FOR RENT', 0, 0);

            ctx.restore();
        }

        function drawManagersOffice() {
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(managersOffice.x, managersOffice.y, managersOffice.w, managersOffice.h);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 4;
            ctx.strokeRect(managersOffice.x, managersOffice.y, managersOffice.w, managersOffice.h);
            ctx.fillStyle = '#5d4037';
            ctx.font = '14px "Indie Flower", cursive';
            ctx.textAlign = 'center';
            ctx.fillText("Manager's", managersOffice.x + managersOffice.w / 2, managersOffice.y + 20);
            ctx.fillText("Office", managersOffice.x + managersOffice.w / 2, managersOffice.y + 35);

            // Desk
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(managersOffice.x + 20, managersOffice.y + 50, 60, 30);
            ctx.strokeRect(managersOffice.x + 20, managersOffice.y + 50, 60, 30);
        }

        function drawOfficeZones() {
            // Player's Desk Area (Zone 1) - Rotated Desk
            const deskWidth = 15;
            const deskHeight = officeZone1.h * 0.8;
            const deskX = officeZone1.x + officeZone1.w - deskWidth - 5; // Move slightly left
            const deskY = officeZone1.y + (officeZone1.h - deskHeight) / 2;

            // Desk
            ctx.fillStyle = '#8d6e63'; // Brown color
            ctx.fillRect(deskX, deskY, deskWidth, deskHeight);
            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;
            ctx.strokeRect(deskX, deskY, deskWidth, deskHeight);

            // Computer
            const pcWidth = 25;
            const pcHeight = 30;
            const pcX = deskX - pcWidth + 5; // Positioned to the left of the desk
            const pcY = deskY + (deskHeight - pcHeight) / 2;
            officeComputer.x = pcX;
            officeComputer.y = pcY;
            officeComputer.w = pcWidth;
            officeComputer.h = pcHeight;
            ctx.fillStyle = '#333';
            ctx.fillRect(pcX, pcY, pcWidth, pcHeight);
            ctx.fillStyle = '#555'; // Screen
            ctx.fillRect(pcX + 3, pcY + 3, pcWidth - 8, pcHeight - 6);


            // Lounge Area (Zone 2) - Rotated Couch
            const couchWidth = officeZone2.h * 0.9; // Swapped w/h for rotation
            const couchHeight = officeZone2.w * 0.4;
            const couchX = officeZone2.x + (officeZone2.w - couchHeight) / 2;
            const couchY = officeZone2.y + (officeZone2.h - couchWidth) / 2;
            ctx.fillStyle = '#a1887f'; // Lighter brown for couch
            ctx.fillRect(couchX, couchY, couchHeight, couchWidth);
            ctx.fillStyle = '#795548'; // Darker brown for details
            ctx.fillRect(couchX, couchY, couchHeight, 8); // Top arm (was base)
            ctx.fillRect(couchX, couchY, 8, couchWidth); // Left arm (was left arm)
            ctx.fillRect(couchX + couchHeight - 8, couchY, 8, couchWidth); // Right arm


            // Break Room (Zone 3)
            const tableWidth = officeZone3.w * 0.6;
            const tableHeight = 10;
            const tableX = officeZone3.x + (officeZone3.w - tableWidth) / 2;
            const tableY = officeZone3.y + (officeZone3.h - tableHeight) / 2;
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(tableX, tableY, tableWidth, tableHeight);
            ctx.strokeRect(tableX, tableY, tableWidth, tableHeight);

            // Chairs
            const chairWidth = 15;
            const chairHeight = 18;
            // Chair 1 (Top)
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(tableX + 10, tableY - chairHeight + 5, chairWidth, chairHeight);
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(tableX + 10, tableY - chairHeight + 5, chairWidth, 4); // Backrest
            // Chair 2 (Bottom)
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(tableX + tableWidth - 25, tableY + tableHeight - 5, chairWidth, chairHeight);
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(tableX + tableWidth - 25, tableY + tableHeight + chairHeight - 9, chairWidth, 4); // Backrest

        }

        function getPackageLayout() {
            const coffeeItems = ['Beans', 'Milks', 'Sugar', 'Snacks'];
            const artPackages = [];
            const coffeePackages = [];

            loadingDockPackages.forEach((pkg, originalIndex) => {
                const packageData = { ...pkg, originalIndex };
                if (coffeeItems.includes(pkg.itemName)) {
                    coffeePackages.push(packageData);
                } else {
                    artPackages.push(packageData);
                }
            });

            const layout = [];
            const startY = loadingDock.y + (loadingDock.height - PACKAGE_HEIGHT) / 2;
            const packageSpacing = PACKAGE_WIDTH + 10;

            // Art packages on the left
            artPackages.forEach((pkg, index) => {
                layout.push({
                    ...pkg,
                    x: loadingDock.x + 10 + index * packageSpacing,
                    y: startY,
                    w: PACKAGE_WIDTH,
                    h: PACKAGE_HEIGHT
                });
            });

            // Coffee packages on the right, aligned with the coffee shop
            if (unlocks.facilities.coffeeShop) {
                const coffeeStartX = coffeeShop.rect.x;
                coffeePackages.forEach((pkg, index) => {
                    layout.push({
                        ...pkg,
                        x: coffeeStartX + index * packageSpacing,
                        y: startY,
                        w: PACKAGE_WIDTH,
                        h: PACKAGE_HEIGHT
                    });
                });
            }


            return layout;
        }

        function drawPackage(pkg, x, y) {
            ctx.fillStyle = '#b9936c';
            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;
            ctx.fillRect(x, y, PACKAGE_WIDTH, PACKAGE_HEIGHT);
            ctx.strokeRect(x, y, PACKAGE_WIDTH, PACKAGE_HEIGHT);

            // Tape
            ctx.fillStyle = 'rgba(160, 120, 80, 0.7)';
            ctx.fillRect(x + PACKAGE_WIDTH/2 - 5, y, 10, PACKAGE_HEIGHT);
            ctx.fillRect(x, y + PACKAGE_HEIGHT/2 - 5, PACKAGE_WIDTH, 10);

            // Label
            ctx.fillStyle = 'white';
            ctx.fillRect(x + 5, y + 5, PACKAGE_WIDTH - 10, 20);
            ctx.fillStyle = '#5d4037';
            ctx.font = '14px "Patrick Hand"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${pkg.itemName} (${pkg.quantity})`, x + PACKAGE_WIDTH/2, y + 15);
        }

        function drawPackages() {
            const packageLayout = getPackageLayout();
            packageLayout.forEach(layoutInfo => {
                drawPackage(layoutInfo, layoutInfo.x, layoutInfo.y);
            });
        }

        function drawStoreBackground() {
            ctx.fillStyle = '#bcaaa4';
            ctx.fillRect(0, 0, worldWidth, canvas.height);
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(0, 0, worldWidth, desk.y + desk.height);
            storageCells.forEach((cell, index) => {
                if (!unlocks.storage[index]) {
                    const r = cell.rect;
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(r.x, r.y, r.w, r.h);
                    drawLockIcon(r.x + r.w/2 - 25, r.y + r.h/2 - 25, 50, 50);
                    return;
                }

                const r = cell.rect;
                const perspective = 0.25;
                const insetX = r.w * perspective;
                const insetY = r.h * perspective;

                const backWall = {
                    x: r.x + insetX,
                    y: r.y + insetY,
                    w: r.w - insetX * 2,
                    h: r.h - insetY * 2
                };

                ctx.fillStyle = '#d7ccc8';
                ctx.fillRect(r.x, r.y, r.w, r.h);

                ctx.fillStyle = '#bcaaa4';
                ctx.fillRect(backWall.x, backWall.y, backWall.w, backWall.h);

                ctx.strokeStyle = '#5d4037';
                ctx.lineWidth = 3;

                ctx.beginPath();
                ctx.moveTo(r.x, r.y); ctx.lineTo(backWall.x, backWall.y);
                ctx.moveTo(r.x + r.w, r.y); ctx.lineTo(backWall.x + backWall.w, backWall.y);
                ctx.moveTo(r.x, r.y + r.h); ctx.lineTo(backWall.x, backWall.y + backWall.h);
                ctx.moveTo(r.x + r.w, r.y + r.h); ctx.lineTo(backWall.x + backWall.w, backWall.y + backWall.h);
                ctx.stroke();

                ctx.strokeRect(r.x, r.y, r.w, r.h);
                ctx.strokeRect(backWall.x, backWall.y, backWall.w, backWall.h);

                // Capacity Bar
                const currentFill = Object.values(cell.items).reduce((a, b) => a + b, 0);
                const fillPercent = Math.min(1, currentFill / cell.capacity);
                ctx.fillStyle = '#eeeeee';
                ctx.fillRect(backWall.x + 5, backWall.y + backWall.h - 15, backWall.w - 10, 10);
                ctx.fillStyle = '#76ff03';
                ctx.fillRect(backWall.x + 5, backWall.y + backWall.h - 15, (backWall.w - 10) * fillPercent, 10);
                ctx.strokeStyle = '#5d4037';
                ctx.strokeRect(backWall.x + 5, backWall.y + backWall.h - 15, backWall.w - 10, 10);

                ctx.fillStyle = '#5d4037';
                ctx.font = '18px "Indie Flower", cursive';
                ctx.textAlign = 'center';
                ctx.fillText(cell.label, cell.rect.x + cell.rect.w / 2, cell.rect.y + cell.rect.h + 20);
            });

            // Draw Cashier Counter
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(cashierCounter.x, cashierCounter.y, cashierCounter.w, cashierCounter.h);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 4;
            ctx.strokeRect(cashierCounter.x, cashierCounter.y, cashierCounter.w, cashierCounter.h);
            ctx.fillStyle = '#6d4c41'; // Darker top
            ctx.fillRect(cashierCounter.x, cashierCounter.y, 10, cashierCounter.h);


            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(desk.x, desk.y, desk.width, desk.height);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 4;
            ctx.strokeRect(desk.x, desk.y, desk.width, desk.height);

            drawLoadingDock();
            drawManagersOffice();
            drawCoffeeStorage();

            // The coffee shop is now drawn as a dynamic entity, so no background drawing here.
        }

        function drawCoffeeStorage() {
            if (!unlocks.facilities.coffeeShop || !coffeeShop.storage) return;

            const cell = coffeeShop.storage;
            const r = cell.rect;
            const perspective = 0.25;
            const insetX = r.w * perspective;
            const insetY = r.h * perspective;

            const backWall = {
                x: r.x + insetX,
                y: r.y + insetY,
                w: r.w - insetX * 2,
                h: r.h - insetY * 2
            };

            ctx.fillStyle = '#d7ccc8'; // Light gray-brown, same as main storage
            ctx.fillRect(r.x, r.y, r.w, r.h);

            ctx.fillStyle = '#bcaaa4'; // Darker back wall
            ctx.fillRect(backWall.x, backWall.y, backWall.w, backWall.h);

            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 3;

            // Perspective lines
            ctx.beginPath();
            ctx.moveTo(r.x, r.y); ctx.lineTo(backWall.x, backWall.y);
            ctx.moveTo(r.x + r.w, r.y); ctx.lineTo(backWall.x + backWall.w, backWall.y);
            ctx.moveTo(r.x, r.y + r.h); ctx.lineTo(backWall.x, backWall.y + backWall.h);
            ctx.moveTo(r.x + r.w, r.y + r.h); ctx.lineTo(backWall.x + backWall.w, backWall.y + backWall.h);
            ctx.stroke();

            // Outlines
            ctx.strokeRect(r.x, r.y, r.w, r.h);
            ctx.strokeRect(backWall.x, backWall.y, backWall.w, backWall.h);

            // Capacity Bar
            const currentFill = Object.values(cell.items).reduce((a, b) => a + b, 0);
            const fillPercent = Math.min(1, currentFill / cell.capacity);
            ctx.fillStyle = '#eeeeee';
            ctx.fillRect(backWall.x + 5, backWall.y + backWall.h - 15, backWall.w - 10, 10);
            ctx.fillStyle = '#76ff03';
            ctx.fillRect(backWall.x + 5, backWall.y + backWall.h - 15, (backWall.w - 10) * fillPercent, 10);
            ctx.strokeStyle = '#5d4037';
            ctx.strokeRect(backWall.x + 5, backWall.y + backWall.h - 15, backWall.w - 10, 10);

            // Label
            ctx.fillStyle = '#5d4037';
            ctx.font = '18px "Indie Flower", cursive';
            ctx.textAlign = 'center';
            ctx.fillText(cell.label, cell.rect.x + cell.rect.w / 2, cell.rect.y + cell.rect.h + 20);
        }

        function drawStaticUI() {
            const boxWidth = 70, boxHeight = 70;
            const boxX = canvas.width - boxWidth - 20, boxY = 20;

            ctx.fillStyle = "rgba(93, 64, 55, 0.7)";
            ctx.strokeStyle = "#4e342e";
            ctx.lineWidth = 2;
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

            const iconY = boxY + 10;
            phoneIcon.x = boxX + 10; phoneIcon.y = iconY;

            drawPhoneIcon(phoneIcon.x, phoneIcon.y, phoneIcon.width, phoneIcon.height);
        }

        function drawCashRegister(x, y, w, h) {
            ctx.fillStyle = '#c0c0c0'; ctx.fillRect(x, y, w, h);
            ctx.fillStyle = '#808080'; ctx.fillRect(x + 5, y + 5, w - 10, 15);
            ctx.fillStyle = '#333';
            ctx.fillRect(x + 8, y + 25, w * 0.4, h * 0.3);
            const btnW = w * 0.15; const btnH = h * 0.18;
            ctx.fillRect(x + w * 0.6, y + 25, btnW, btnH);
            ctx.fillRect(x + w * 0.8, y + 25, btnW, btnH);
            ctx.fillRect(x + w * 0.6, y + 25 + btnH + 5, btnW, btnH);
            ctx.fillRect(x + w * 0.8, y + 25 + btnH + 5, btnW, btnH);
        }

        function drawClipboard(x, y, w, h) {
             ctx.fillStyle = '#8d6e63'; ctx.fillRect(x, y, w, h);
             ctx.fillStyle = '#f5f5f5'; ctx.fillRect(x + 5, y + 15, w - 10, h - 20);
             ctx.fillStyle = '#757575'; ctx.fillRect(x + 10, y + 5, w - 20, 10);
             ctx.strokeStyle = '#bdbdbd'; ctx.lineWidth = 1;
             for (let i = 0; i < 4; i++) {
                 ctx.beginPath();
                 ctx.moveTo(x + 10, y + 25 + i * 8);
                 ctx.lineTo(x + w - 10, y + 25 + i * 8);
                 ctx.stroke();
             }
        }

        function drawShoppingBasket(x, y, w, h) {
            ctx.strokeStyle = '#f5f5f5';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + w * 0.1, y + h * 0.4);
            ctx.lineTo(x + w * 0.9, y + h * 0.4);
            ctx.lineTo(x + w * 0.8, y + h * 0.9);
            ctx.lineTo(x + w * 0.2, y + h * 0.9);
            ctx.closePath();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + w * 0.3, y + h * 0.4);
            ctx.quadraticCurveTo(x + w * 0.5, y, x + w * 0.7, y + h * 0.4);
            ctx.stroke();
        }

        function drawLockIcon(x, y, w, h) {
            ctx.strokeStyle = '#f5f5f5';
            ctx.lineWidth = 4;

            // Shackle (the U part)
            ctx.beginPath();
            ctx.moveTo(x + w * 0.25, y + h * 0.4);
            ctx.lineTo(x + w * 0.25, y + h * 0.2);
            ctx.arc(x + w * 0.5, y + h * 0.2, w * 0.25, Math.PI, 0);
            ctx.lineTo(x + w * 0.75, y + h * 0.4);
            ctx.stroke();

            // Body (the square part)
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(x, y + h * 0.4, w, h * 0.6);
        }

        function drawPhoneIcon(x, y, w, h) {
            ctx.fillStyle = '#f5f5f5';
            ctx.strokeStyle = '#f5f5f5';
            ctx.lineWidth = 3;

            // Phone body
            ctx.beginPath();
            ctx.roundRect(x + w * 0.15, y, w * 0.7, h, 8);
            ctx.fill();

            // Screen
            ctx.fillStyle = '#333';
            ctx.fillRect(x + w * 0.25, y + 8, w * 0.5, h - 24);

            // Home button
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + w * 0.5, y + h - 8, 4, 0, Math.PI * 2);
            ctx.stroke();
        }

        // --- START: Sprite Sheet Generation Code ---

        // This function generates the original flower-headed sprite for the player and NPCs
        function generateOriginalSpriteSheet(canvas, ctx) {
             const frameSize = 90;
             const sheetSize = 270;
             const colors = {
                 skin: '#f2d3b3', petal: '#ffc0cb', flowerCenter: '#ffee00',
                 top: '#f8f8f8', shorts: '#6E98D9', shoes: '#2d2d2d',
                 white: '#ffffff', outline: '#333333'
             };
             function drawFlowerHead(x, y, isSideView = false) {
                 const centerX = x + frameSize / 2;
                 const centerY = y + 25;
                 const petalRadius = 14;
                 const centerRadius = 5;
                 ctx.strokeStyle = colors.outline;
                 ctx.lineWidth = 1.5;
                 ctx.fillStyle = colors.petal;
                 if (isSideView) {
                     const sidePetals = [
                         { angle: Math.PI / 2, xOff: 0, yOff: -3, size: 1.1 },
                         { angle: Math.PI * 0.1, xOff: 5, yOff: 2, size: 1.0 },
                         { angle: Math.PI * 0.9, xOff: -5, yOff: 2, size: 1.0 },
                     ];
                     sidePetals.forEach(p => {
                         ctx.beginPath();
                         ctx.ellipse(centerX + p.xOff, centerY + p.yOff, 5 * p.size, 8 * p.size, p.angle, 0, Math.PI * 2);
                         ctx.fill();
                         ctx.stroke();
                     });
                 } else {
                     const numPetals = 6;
                     for (let i = 0; i < numPetals; i++) {
                         const angle = (i / numPetals) * Math.PI * 2;
                         const px = centerX + Math.cos(angle) * petalRadius;
                         const py = centerY + Math.sin(angle) * petalRadius;
                         ctx.beginPath();
                         ctx.ellipse(px, py, 6, 10, angle + Math.PI / 2, 0, Math.PI * 2);
                         ctx.fill();
                         ctx.stroke();
                     }
                 }
                 ctx.fillStyle = colors.flowerCenter;
                 ctx.beginPath();
                 ctx.arc(centerX, centerY, centerRadius, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.stroke();
             }
             function drawBody(x, y, bob = 0) {
                 ctx.fillStyle = colors.top;
                 ctx.strokeStyle = colors.outline;
                 ctx.lineWidth = 1.5;
                 ctx.beginPath();
                 ctx.moveTo(x + 38, y + 40 + bob);
                 ctx.lineTo(x + 52, y + 40 + bob);
                 ctx.lineTo(x + 55, y + 55 + bob);
                 ctx.lineTo(x + 35, y + 55 + bob);
                 ctx.closePath();
                 ctx.fill();
                 ctx.stroke();
                 ctx.fillStyle = colors.shorts;
                 ctx.beginPath();
                 ctx.rect(x + 35, y + 55 + bob, 20, 10);
                 ctx.fill();
                 ctx.stroke();
             }
             function drawLegs(x, y, frame = 1, bob = 0, isSideView = false) {
                 const legY = y + 65 + bob;
                 ctx.fillStyle = colors.skin;
                 ctx.strokeStyle = colors.outline;
                 ctx.lineWidth = 1.5;
                 let leftLegX = x + 38, rightLegX = x + 48, leftLegYOffset = 0, rightLegYOffset = 0;
                 if (isSideView) {
                     leftLegX = x + 42; rightLegX = x + 46;
                     if (frame === 1) { leftLegYOffset = 5; rightLegYOffset = 0; }
                     else if (frame === 2) { leftLegYOffset = 0; rightLegYOffset = 5; }
                 } else {
                     if (frame === 2) { rightLegYOffset = 2; }
                     else if (frame !== 1) { leftLegYOffset = 2; }
                 }
                 ctx.beginPath(); ctx.rect(rightLegX, legY + rightLegYOffset, 4, 15); ctx.fill(); ctx.stroke();
                 drawShoe(rightLegX, legY + 15 + rightLegYOffset, isSideView);
                 ctx.beginPath(); ctx.rect(leftLegX, legY + leftLegYOffset, 4, 15); ctx.fill(); ctx.stroke();
                 drawShoe(leftLegX, legY + 15 + leftLegYOffset, isSideView);
             }
             function drawShoe(x, y, isSideView) {
                 ctx.fillStyle = colors.shoes; ctx.strokeStyle = colors.outline; ctx.lineWidth = 1.5;
                 ctx.beginPath();
                 if(isSideView){ ctx.rect(x-3, y, 8, 5); } else { ctx.rect(x - 2, y, 8, 5); }
                 ctx.fill(); ctx.stroke();
                 ctx.fillStyle = colors.white;
                 ctx.beginPath();
                 if(isSideView){ ctx.rect(x+5, y, 2, 5); } else { ctx.rect(x - 2, y, 8, 2); }
                 ctx.fill();
             }
             function drawIdleFrame(col, row) {
                 const x = col * frameSize, y = row * frameSize;
                 const bob = (col === 1) ? 1 : 0;
                 drawBody(x, y, bob); drawLegs(x, y, 1, bob); drawFlowerHead(x, y);
             }
             function drawWalkDownFrame(col, row) {
                 const x = col * frameSize, y = row * frameSize;
                 const frame = (col % 2 === 0) ? (col === 0 ? 3 : 1) : 2;
                 drawBody(x, y); drawLegs(x, y, frame); drawFlowerHead(x, y);
             }
             function drawWalkRightFrame(col, row) {
                 const x = col * frameSize, y = row * frameSize;
                 const frame = (col % 2 === 0) ? (col === 0 ? 3 : 1) : 2;
                 drawBody(x, y); drawLegs(x, y, frame, 0, true); drawFlowerHead(x, y, true);
             }
             ctx.clearRect(0, 0, sheetSize, sheetSize);
             for (let row = 0; row < 3; row++) {
                 for (let col = 0; col < 3; col++) {
                     if (row === 0) { drawIdleFrame(col, row); }
                     else if (row === 1) { drawWalkDownFrame(col, row); }
                     else if (row === 2) { drawWalkRightFrame(col, row); }
                 }
             }
        }

        // This new function generates the bee sprites for customers
        function generateBeeSpriteSheet(canvas, ctx, artistType) {
            const frameSize = 90;
            const sheetSize = 270;
            const colors = {
                beeYellow: '#ffdd00', beeBlack: '#4a4a4a', wingBlue: 'rgba(169, 214, 229, 0.8)',
                outline: '#333333', beretRed: '#c0392b', paintBlue: '#3498db', paintRed: '#e74c3c',
                paintGreen: '#2ecc71', paletteBrown: '#8d6e63', glassesGray: '#7f8c8d', lightYellow: '#f1c40f',
                apronBlue: '#2c3e50', sawGray: '#bdc3c7', woodBrown: '#a0522d', clayGray: '#95a5a6',
                toolBrown: '#8B4513', smockGray: '#bdc3c7', bagBrown: '#8B5A2B', paperWhite: '#f5f5f5'
            };

            function drawBeeHead(ctx, x, y, isSideView = false, currentArtistType = '') {
                const centerX = x + frameSize / 2;
                const centerY = y + 30;
                ctx.strokeStyle = colors.outline;
                ctx.lineWidth = 1.5;
                ctx.fillStyle = colors.beeYellow;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 15, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = colors.beeBlack;
                if(currentArtistType === 'modelMaker'){
                    ctx.fillStyle = colors.glassesGray;
                    ctx.strokeStyle = colors.outline;
                    ctx.lineWidth = 1;
                    if(isSideView){
                        ctx.beginPath();
                        ctx.arc(centerX + 6, centerY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = colors.beeBlack;
                        ctx.beginPath();
                        ctx.arc(centerX + 6, centerY, 4, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(centerX - 7, centerY, 6, 0, Math.PI * 2);
                        ctx.arc(centerX + 7, centerY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = colors.beeBlack;
                        ctx.beginPath();
                        ctx.arc(centerX - 7, centerY, 4, 0, Math.PI * 2);
                        ctx.arc(centerX + 7, centerY, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = colors.glassesGray;
                    ctx.fillRect(centerX - 5, centerY - 22, 10, 4);
                    ctx.strokeRect(centerX - 5, centerY - 22, 10, 4);
                    ctx.fillStyle = colors.lightYellow;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY - 20, 2, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    if (isSideView) {
                        ctx.ellipse(centerX + 6, centerY, 3, 4, 0, 0, Math.PI * 2);
                    } else {
                        ctx.ellipse(centerX - 7, centerY, 3, 4, 0, 0, Math.PI * 2);
                        ctx.ellipse(centerX + 7, centerY, 3, 4, 0, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }
                ctx.strokeStyle = colors.beeBlack;
                ctx.beginPath();
                if(isSideView){
                    ctx.moveTo(centerX, centerY - 12);
                    ctx.quadraticCurveTo(centerX + 5, centerY - 22, centerX + 8, centerY - 20);
                } else {
                    ctx.moveTo(centerX - 5, centerY - 12);
                    ctx.quadraticCurveTo(centerX - 10, centerY - 22, centerX - 4, centerY - 20);
                    ctx.moveTo(centerX + 5, centerY - 12);
                    ctx.quadraticCurveTo(centerX + 10, centerY - 22, centerX + 4, centerY - 20);
                }
                ctx.stroke();
                if(currentArtistType === 'student'){
                    ctx.fillStyle = colors.beretRed;
                    ctx.beginPath();
                    ctx.ellipse(isSideView ? centerX + 4 : centerX, centerY - 15, 12, 6, isSideView ? 0.2 : 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            function drawAccessories(ctx, currentArtistType, x, y, bob, isSideView) {
                const centerX = x + frameSize / 2;
                const centerY = y + 55 + bob;
                ctx.strokeStyle = colors.outline;
                ctx.lineWidth = 1.5;
                switch(currentArtistType) {
                    case 'painter':
                        ctx.fillStyle = colors.paletteBrown;
                        ctx.beginPath();
                        ctx.ellipse(isSideView ? centerX + 20 : centerX - 20, centerY + 10, 8, 6, 0, 0, Math.PI*2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = colors.paintBlue; ctx.beginPath(); ctx.arc(isSideView ? centerX+18 : centerX-22, centerY+8, 1.5, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = colors.paintRed; ctx.beginPath(); ctx.arc(isSideView ? centerX+22 : centerX-18, centerY+8, 1.5, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = colors.paintGreen; ctx.beginPath(); ctx.arc(isSideView ? centerX+20 : centerX-20, centerY+12, 1.5, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = colors.beeBlack; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(isSideView ? centerX-20 : centerX+20, centerY+5); ctx.lineTo(isSideView ? centerX-28 : centerX+28, centerY); ctx.stroke();
                        break;
                    case 'woodworker':
                        ctx.lineWidth = 1;
                        ctx.fillStyle = colors.sawGray;
                        ctx.beginPath();
                        ctx.moveTo(isSideView ? centerX-20 : centerX+20, centerY);
                        ctx.lineTo(isSideView ? centerX-28 : centerX+28, centerY+10);
                        ctx.lineTo(isSideView ? centerX-18 : centerX+18, centerY+12);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = colors.woodBrown;
                        ctx.fillRect(isSideView ? centerX+15 : centerX-25, centerY+5, 10, 10);
                        ctx.strokeRect(isSideView ? centerX+15 : centerX-25, centerY+5, 10, 10);
                        break;
                    case 'sculptor':
                        ctx.lineWidth = 1;
                        ctx.fillStyle = colors.clayGray;
                        ctx.beginPath();
                        ctx.ellipse(isSideView ? centerX + 22 : centerX - 20, centerY + 8, 5, 6, 0, 0, Math.PI*2);
                        ctx.fill(); ctx.stroke();
                        ctx.fillStyle = colors.toolBrown;
                        ctx.fillRect(isSideView ? centerX - 25 : centerX + 15, centerY + 5, 12, 3);
                        ctx.strokeRect(isSideView ? centerX - 25 : centerX + 15, centerY + 5, 12, 3);
                        break;
                    case 'architect':
                        if (isSideView) {
                            ctx.fillStyle = colors.bagBrown; ctx.beginPath();
                            ctx.rect(centerX - 20, centerY - 5, 12, 14); ctx.fill(); ctx.stroke();
                            ctx.fillStyle = colors.paperWhite; ctx.strokeStyle = colors.beeBlack; ctx.lineWidth = 1;
                            ctx.beginPath(); ctx.rect(centerX - 18, centerY - 11, 4, 7); ctx.fill(); ctx.stroke();
                            ctx.beginPath(); ctx.rect(centerX - 13, centerY - 11, 4, 7); ctx.fill(); ctx.stroke();
                        } else {
                            ctx.strokeStyle = colors.bagBrown; ctx.lineWidth = 3;
                            ctx.beginPath(); ctx.moveTo(centerX - 12, centerY - 10); ctx.lineTo(centerX + 12, centerY + 8); ctx.stroke();
                            ctx.fillStyle = colors.bagBrown; ctx.lineWidth = 1.5; ctx.strokeStyle = colors.outline;
                            ctx.beginPath(); ctx.rect(centerX + 8, centerY, 14, 16); ctx.fill(); ctx.stroke();
                            ctx.fillStyle = colors.paperWhite; ctx.strokeStyle = colors.beeBlack; ctx.lineWidth = 1;
                            ctx.beginPath(); ctx.rect(centerX + 10, centerY - 6, 5, 8); ctx.fill(); ctx.stroke();
                            ctx.beginPath(); ctx.rect(centerX + 16, centerY - 6, 5, 8); ctx.fill(); ctx.stroke();
                        }
                        break;
                }
            }

            function drawBeeBody(ctx, currentArtistType, x, y, bob = 0, frame = 0, isSideView = false) {
                const centerX = x + frameSize / 2;
                const centerY = y + 55 + bob;
                ctx.strokeStyle = colors.outline;
                ctx.lineWidth = 1.5;
                const wingY = frame === 1 ? -5 : 0;
                ctx.fillStyle = colors.wingBlue;
                ctx.beginPath();
                if(isSideView){
                    ctx.ellipse(centerX - 12, centerY - 8 + wingY, 12, 7, -0.8, 0, Math.PI * 2);
                } else {
                    ctx.ellipse(centerX - 15, centerY - 8 + wingY, 12, 7, -0.8, 0, Math.PI * 2);
                    ctx.ellipse(centerX + 15, centerY - 8 + wingY, 12, 7, 0.8, 0, Math.PI * 2);
                }
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = colors.beeYellow;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 15, 18, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = colors.beeBlack;
                ctx.beginPath();
                ctx.rect(centerX - 15, centerY - 5, 30, 5);
                ctx.rect(centerX - 12, centerY + 5, 24, 4);
                ctx.fill();
                if(!isSideView) {
                    if(currentArtistType === 'woodworker') {
                        ctx.fillStyle = colors.apronBlue;
                        ctx.beginPath(); ctx.moveTo(centerX-8,centerY-10); ctx.lineTo(centerX+8,centerY-10); ctx.lineTo(centerX+10, centerY+14); ctx.lineTo(centerX-10, centerY+14); ctx.closePath(); ctx.fill(); ctx.stroke();
                    } else if (currentArtistType === 'sculptor') {
                        ctx.fillStyle = colors.smockGray;
                        ctx.beginPath(); ctx.moveTo(centerX - 10, centerY - 8); ctx.lineTo(centerX + 10, centerY - 8); ctx.lineTo(centerX + 12, centerY + 12); ctx.lineTo(centerX - 12, centerY + 12); ctx.closePath(); ctx.fill(); ctx.stroke();
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.fillRect(centerX - 5, centerY, 2, 2); ctx.fillRect(centerX + 3, centerY + 5, 2, 2);
                    }
                }
                drawAccessories(ctx, currentArtistType, x, y, bob, isSideView);
            }

            function drawBeeLegs(ctx, x, y, frame = 1, bob = 0, isSideView = false) {
                const legY = y + 72 + bob;
                ctx.strokeStyle = colors.beeBlack;
                ctx.lineWidth = 2;
                let leftLegX = x + 38; let rightLegX = x + 52;
                let leftLegYOffset = 0; let rightLegYOffset = 0;
                if (isSideView) {
                    leftLegX = x + 42; rightLegX = x + 48;
                    if (frame === 1) { leftLegYOffset = 3; }
                    else if (frame === 2) { rightLegYOffset = 3; }
                } else {
                    if (frame === 2) { rightLegYOffset = 2; }
                    else if (frame === 3) { leftLegYOffset = 2; }
                }
                ctx.beginPath(); ctx.moveTo(rightLegX, legY); ctx.lineTo(rightLegX, legY + 8 + rightLegYOffset); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(leftLegX, legY); ctx.lineTo(leftLegX, legY + 8 + leftLegYOffset); ctx.stroke();
            }

            ctx.clearRect(0, 0, sheetSize, sheetSize);
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = col * frameSize;
                    const y = row * frameSize;
                    let bob = 0, frame = 1, isSideView = false;
                    if (row === 0) { // Idle
                        bob = (col === 1) ? 1 : 0;
                    } else if (row === 1) { // Walk Down
                        frame = (col % 2 === 0) ? (col === 0 ? 3 : 1) : 2;
                    } else if (row === 2) { // Walk Right
                        isSideView = true;
                        frame = (col % 2 === 0) ? (col === 0 ? 3 : 1) : 2;
                    }
                    drawBeeBody(ctx, artistType, x, y, bob, col, isSideView);
                    drawBeeLegs(ctx, x, y, frame, bob, isSideView);
                    drawBeeHead(ctx, x, y, isSideView, artistType);
                }
            }
        }

        let playerSpriteImage = null;
        let spriteSheetLoaded = false;
        function loadSpriteSheet() {
            const spriteCanvas = document.getElementById('spriteSheetCanvas');
            const spriteCtx = spriteCanvas.getContext('2d');
            generateOriginalSpriteSheet(spriteCanvas, spriteCtx);
            const dataURL = spriteCanvas.toDataURL('image/png');
            playerSpriteImage = new Image();
            playerSpriteImage.onload = () => { spriteSheetLoaded = true; };
            playerSpriteImage.onerror = () => {
                showMessage("Critical Error: Failed to load character sprites from generated image data.", null);
            };
            playerSpriteImage.src = dataURL;
        }

        function generateAndLoadCustomerSprite(customer) {
            const spriteCanvas = document.getElementById('spriteSheetCanvas');
            const spriteCtx = spriteCanvas.getContext('2d');
            const spriteType = customerTypes[customer.customerType]?.spriteType;

            if (spriteType) {
                generateBeeSpriteSheet(spriteCanvas, spriteCtx, spriteType);
                const dataURL = spriteCanvas.toDataURL('image/png');
                customer.spriteImage.src = dataURL;
                customer.spriteImage.onload = () => {
                    customer.spriteSheetLoaded = true;
                };
            }
        }


        /**
         * REFACTOR: Centralized function to draw any character sprite.
         * This reduces code duplication across all character draw functions.
         * @param {object} character - The character object (player, npc, customer).
         * @param {HTMLImageElement} image - The sprite sheet image to draw from.
         * @param {string} name - The name to display above the character.
         * @param {string} [filter=''] - A CSS filter to apply to the sprite (e.g., for different colors).
         * @param {boolean} [drawName=true] - Whether to draw the name text.
         */
        function drawCharacter(character, image, name, filter = '', drawName = true) {
            if (!image || !image.complete) return;

            // Determine animation state (idle or walking)
            let animState = 'idle';
            if (character.state && !['idle', 'transaction', 'ordering', 'takingItem', 'waitingAtCounter', 'placing', 'interacting'].includes(character.state)) {
                animState = 'walk';
            }

            const anim = animations[animState];
            if (!anim) return;

            // Determine animation row based on direction
            let animRow = 0;
            if (animState === 'walk') {
                animRow = (character.facing === 'left' || character.facing === 'right') ? 2 : 1;
            }

            const frameIndex = (animRow * anim.cols) + character.currentFrame;
            const col = frameIndex % anim.cols;
            const row = Math.floor(frameIndex / anim.cols);
            const sourceX = col * character.frameWidth;
            const sourceY = row * character.frameHeight;

            ctx.save();
            if (filter) {
                ctx.filter = filter;
            }

            let drawX = character.x - character.frameWidth / 2;
            if (character.facing === 'left') {
                ctx.scale(-1, 1);
                drawX = -character.x - character.frameWidth / 2;
            }

            ctx.drawImage(image, sourceX, sourceY, character.frameWidth, character.frameHeight, drawX, character.y - character.frameHeight, character.frameWidth, character.frameHeight);
            ctx.restore();

            if (drawName && name) {
                ctx.fillStyle = '#f7e7d8';
                ctx.font = '20px "Indie Flower", cursive';
                ctx.textAlign = 'center';
                ctx.fillText(name, character.x, character.y - character.frameHeight - 10);
            }
        }

        function drawPlayer() {
            drawCharacter(player, playerSpriteImage, "Shopkeep");
        }

        function drawStocker() {
            if (!unlocks.employees.stocker) return;
            drawCharacter(stocker, playerSpriteImage, "Stocker", 'hue-rotate(180deg) brightness(1.2)');
        }

        function drawCashier() {
            if (!unlocks.employees.cashier) return;
            drawCharacter(cashier, playerSpriteImage, "Cashier", 'sepia(0.8) saturate(3)');
        }

        function drawBarista() {
            if (!unlocks.employees.barista) return;
            drawCharacter(barista, playerSpriteImage, "Barista", 'hue-rotate(90deg) saturate(1.5)');
        }

        function drawManager() {
            if (!unlocks.employees.manager) return;
            drawCharacter(manager, playerSpriteImage, "Manager", 'hue-rotate(270deg) saturate(2)');
        }

        function drawSalesperson() {
            if (!unlocks.employees.salesperson) return;
            drawCharacter(salesperson, playerSpriteImage, "Sales", 'hue-rotate(320deg) saturate(2.5)');
        }

        function moveCharacterTowards(character, targetX, targetY, deltaTime) {
            const dx = targetX - character.x;
            const dy = targetY - character.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 5) return true;
            const moveX = (dx / dist) * character.speed * (deltaTime / 1000);
            const moveY = (dy / dist) * character.speed * (deltaTime / 1000);
            character.x += moveX;
            character.y += moveY;
            if (Math.abs(dx) > Math.abs(dy)) {
                character.facing = moveX > 0 ? 'right' : 'left';
            }
            return false;
        }

        // --- START REFACTOR: Generic NPC Logic ---
        function handleEmployeeOffDuty(character, empKey, deltaTime) {
            const currentShiftPhase = dayPhase.replace('-', ' ');
            const isWorking = character.shift.map(s => s.toLowerCase()).includes(currentShiftPhase.toLowerCase());

            // An employee is off-duty if they are on break, the day hasn't started, or it's not their shift.
            if (character.onBreak || !dayStarted || !isWorking) {
                const breakSpot = getBreakSpot(empKey);
                if (moveCharacterTowards(character, breakSpot.x, breakSpot.y, deltaTime)) {
                    character.state = 'idle'; // Sit idle at the break spot
                } else {
                    character.state = 'walk'; // Walk towards the break spot
                }
                updateCharacterAnimation(character, deltaTime);
                return true; // Is off-duty, so the main update function should exit.
            }
            return false; // Is on-duty, so continue with normal logic.
        }

        function updateCharacterAnimation(character, deltaTime) {
            const animState = (character.state && !['idle', 'transaction', 'ordering', 'takingItem', 'waitingAtCounter', 'placing', 'interacting'].includes(character.state)) ? 'walk' : 'idle';
            const anim = animations[animState];
            if (!anim) return;

            character.lastFrameTime += deltaTime;
            if (character.lastFrameTime >= character.animationSpeed) {
                character.currentFrame = (character.currentFrame + 1) % anim.frames;
                character.lastFrameTime = 0;
            }
        }

        // --- END REFACTOR ---

        function updateStocker(deltaTime) {
            if (!unlocks.employees.stocker) return;

            if (handleEmployeeOffDuty(stocker, 'stocker', deltaTime)) return;

            updateCharacterAnimation(stocker, deltaTime);

            stocker.stateTimer -= deltaTime;
            switch(stocker.state) {
                case 'idle':
                    if (stocker.stateTimer <= 0) {
                        const task = findRestockingTask();
                        if (task) {
                            stocker.task = task;
                            stocker.state = task.action;
                        } else {
                            stocker.stateTimer = 3000;
                            if(Math.hypot(stocker.x - stocker.idleX, stocker.y - stocker.idleY) > 5) {
                                stocker.task = { target: {x: stocker.idleX, y: stocker.idleY} };
                                moveCharacterTowards(stocker, stocker.idleX, stocker.idleY, deltaTime);
                            } else {
                                stocker.task = null;
                            }
                        }
                    }

                    break;
                case 'fetching':
                    if (moveCharacterTowards(stocker, stocker.task.target.x, stocker.task.target.y, deltaTime)) {
                        const itemToTake = stocker.task.item;
                        const cell = storageCells.find((c, i) => unlocks.storage[i] && c.allowedItems.includes(itemToTake) && c.items[itemToTake] > 0);
                        if(cell) {
                            while(stocker.basket.length < STOCKER_BASKET_SIZE && cell.items[itemToTake] > 0) {
                                stocker.basket.push(itemToTake);
                                cell.items[itemToTake]--;
                            }
                        }
                        stocker.state = 'stocking';
                        stocker.task = null;
                    }
                    break;
                case 'fetching_dock':
                    if (moveCharacterTowards(stocker, stocker.task.target.x, stocker.task.target.y, deltaTime)) {
                        const pkg = loadingDockPackages[stocker.task.packageIndex];
                        if (pkg && pkg.itemName === stocker.task.item) {
                            while(stocker.basket.length < STOCKER_BASKET_SIZE && pkg.quantity > 0) {
                                stocker.basket.push(pkg.itemName);
                                pkg.quantity--;
                            }
                            if (pkg.quantity <= 0) {
                                loadingDockPackages.splice(stocker.task.packageIndex, 1);
                            }
                        }
                        stocker.state = 'stocking';
                        stocker.task = null;
                    }
                    break;
                case 'stocking':
                    if (!stocker.task) {
                        if (stocker.basket.length === 0) {
                            stocker.state = 'idle';
                            stocker.task = { target: {x: stocker.idleX, y: stocker.idleY} };
                            break;
                        }
                        const itemToStock = stocker.basket[0];
                        const targetShelf = findShelfForStocking(itemToStock);
                        if (targetShelf) {
                            stocker.task = { action: 'place', item: itemToStock, shelf: targetShelf, target: {x: targetShelf.rect.x + targetShelf.rect.w / 2, y: targetShelf.rect.y + targetShelf.rect.h + 10} };
                        } else {
                            stocker.basket.shift();
                        }
                    }
                    if (stocker.task && moveCharacterTowards(stocker, stocker.task.target.x, stocker.task.target.y, deltaTime)) {
                        const shelf = stocker.task.shelf;
                        const itemToStock = stocker.task.item;

                        let slot = shelf.items.find(s => s.assignedItem === itemToStock && s.quantity < MAX_SHELF_STACK);
                        if (!slot) {
                            slot = shelf.items.find(s => s.assignedItem === null);
                        }

                        if (slot) {
                            const itemIndexInBasket = stocker.basket.indexOf(itemToStock);
                            if(itemIndexInBasket > -1) {
                                if(slot.assignedItem === null) {
                                    slot.assignedItem = itemToStock;
                                }
                                stocker.basket.splice(itemIndexInBasket, 1);
                                slot.quantity++;
                            }
                        }
                        stocker.task = null;
                    }
                    break;
            }
        }

        function updateCashier(deltaTime) {
            if (!unlocks.employees.cashier) return;

            if (handleEmployeeOffDuty(cashier, 'cashier', deltaTime)) return;

            updateCharacterAnimation(cashier, deltaTime);

            cashier.stateTimer -= deltaTime;
            switch (cashier.state) {
                case 'idle':
                    const customerToServe = customers
                        .filter(c => c.state === 'waitingAtCounter' && !c.isServed)
                        .sort((a, b) => a.x - b.x)[0];
                    if (customerToServe) {
                        cashier.task = {
                            action: 'serve',
                            customerId: customerToServe.id,
                            target: { x: customerToServe.x - 30, y: customerToServe.y - 100 }
                        };
                        cashier.state = 'serving';
                    }
                    break;
                case 'serving':
                    if(cashier.task && moveCharacterTowards(cashier, cashier.task.target.x, cashier.task.target.y, deltaTime)) {
                        cashier.state = 'transaction';
                        cashier.stateTimer = 1500;
                    }
                    break;
                case 'transaction':
                    if(cashier.stateTimer <= 0) {
                        if(cashier.task) {
                            completeTransaction(cashier.task.customerId, false);
                        }
                        cashier.task = { target: {x: cashier.idleX, y: cashier.idleY } };
                        cashier.state = 'returning';
                    }
                    break;
                case 'returning':
                    if(cashier.task && moveCharacterTowards(cashier, cashier.task.target.x, cashier.task.target.y, deltaTime)) {
                        cashier.state = 'idle';
                        cashier.task = null;
                    }
                    break;
            }
        }

        function updateBarista(deltaTime) {
            if (!unlocks.employees.barista) return;

            if (handleEmployeeOffDuty(barista, 'barista', deltaTime)) return;

            updateCharacterAnimation(barista, deltaTime);
            barista.stateTimer -= deltaTime;

            switch(barista.state) {
                case 'idle':
                    if (barista.stateTimer <= 0) {
                        const task = findCoffeeRestockingTask();
                        if (task) {
                            barista.task = task;
                            barista.state = 'fetching_coffee';
                        } else {
                            barista.stateTimer = 3000;
                            if(Math.hypot(barista.x - barista.idleX, barista.y - barista.idleY) > 5) {
                                moveCharacterTowards(barista, barista.idleX, barista.idleY, deltaTime);
                            }
                        }
                    }
                    break;
                case 'fetching_coffee':
                    if (moveCharacterTowards(barista, barista.task.target.x, barista.task.target.y, deltaTime)) {
                        const pkg = loadingDockPackages[barista.task.packageIndex];
                        if (pkg && pkg.itemName === barista.task.item) {
                            while(barista.basket.length < BARISTA_BASKET_SIZE && pkg.quantity > 0) {
                                barista.basket.push(pkg.itemName);
                                pkg.quantity--;
                            }
                            if (pkg.quantity <= 0) {
                                loadingDockPackages.splice(barista.task.packageIndex, 1);
                            }
                        }
                        barista.state = 'stocking_coffee';
                        barista.task = null;
                    }
                    break;
                case 'stocking_coffee':
                    if (!barista.task) {
                        // If basket is empty or storage doesn't exist, go idle.
                        if (barista.basket.length === 0 || !coffeeShop.storage) {
                            barista.state = 'idle';
                            break;
                        }
                        // Set the task to go to the single coffee storage location.
                        const storageCell = coffeeShop.storage;
                        barista.task = {
                            target: {
                                x: storageCell.rect.x + storageCell.rect.w / 2,
                                y: storageCell.rect.y + storageCell.rect.h + 10
                            }
                        };
                    }

                    // Move towards the storage location.
                    if (barista.task && moveCharacterTowards(barista, barista.task.target.x, barista.task.target.y, deltaTime)) {
                        const storageCell = coffeeShop.storage;
                        const newBasket = [];
                        let itemsStocked = 0;

                        // Iterate through the basket and try to stock each item.
                        for (const itemToStock of barista.basket) {
                            const currentFill = Object.values(storageCell.items).reduce((a, b) => a + b, 0);
                            // Check if it's a valid coffee item AND there's space.
                            if (storageCell.allowedItems.includes(itemToStock) && currentFill < storageCell.capacity) {
                                storageCell.items[itemToStock] = (storageCell.items[itemToStock] || 0) + 1;
                                itemsStocked++;
                            } else {
                                // If it can't be stocked, put it back in the "new" basket.
                                newBasket.push(itemToStock);
                            }
                        }

                        if (itemsStocked > 0) {
                            spawnFloatingText(`Stashed ${itemsStocked} coffee items.`, barista.x, barista.y - 90, '#654321');
                        }

                        barista.basket = newBasket; // Update basket with any remaining items.
                        barista.task = null;
                        barista.state = 'idle'; // Go idle after finishing the stocking attempt.
                    }
                    break;
            }
        }


        function updateManager(deltaTime) {
             if (!unlocks.employees.manager) return;

            if (handleEmployeeOffDuty(manager, 'manager', deltaTime)) return;

            const currentQuarter = Math.floor(((DAY_DURATION - dayTimer) / DAY_DURATION) * 4);
            if (currentQuarter > manager.lastOrderQuarter) {
                manager.canOrder = true;
            }

            updateCharacterAnimation(manager, deltaTime);
            manager.stateTimer -= deltaTime;

            switch(manager.state) {
                case 'idle':
                    if (manager.stateTimer <= 0) {

                        // --- Morning Prep Logic (DISABLED) ---
                        /*
                        if (dayPhase === 'opening' && manager.canOrder && !manager.hasPlacedMorningOrder) {
                            const shelfDemand = {};
                            const shelfStock = {};
                            shelves.forEach(shelf => {
                                shelf.items.forEach(slot => {
                                    if (slot.assignedItem) {
                                        const itemName = slot.assignedItem;
                                        shelfDemand[itemName] = (shelfDemand[itemName] || 0) + MAX_SHELF_STACK;
                                        shelfStock[itemName] = (shelfStock[itemName] || 0) + slot.quantity;
                                    }
                                });
                            });

                            const shoppingList = [];
                            for (const itemName in shelfDemand) {
                                const neededToFillShelves = shelfDemand[itemName] - shelfStock[itemName];
                                const backroomStock = getBackroomStock(itemName);
                                const neededFromSupplier = neededToFillShelves - backroomStock;
                                if (neededFromSupplier > 0) {
                                    shoppingList.push({ itemName, quantity: neededFromSupplier });
                                }
                            }

                            if (shoppingList.length > 0) {
                                shoppingList.sort((a, b) => (itemPopularity[b.itemName] || 0) - (itemPopularity[a.itemName] || 0));
                                const finalOrderList = [];
                                let totalCost = 0;
                                const availableCash = cash - 30;

                                for (const orderItem of shoppingList) {
                                    const itemCost = items[orderItem.itemName].cost * orderItem.quantity;
                                    if (totalCost + itemCost <= availableCash) {
                                        totalCost += itemCost;
                                        finalOrderList.push(orderItem);
                                    }
                                }

                                let packagesFromOrder = 0;
                                finalOrderList.forEach(orderItem => {
                                    packagesFromOrder += Math.ceil(orderItem.quantity / MAX_PACKAGE_SIZE);
                                });

                                if (finalOrderList.length > 0) {
                                    manager.task = {
                                        action: 'order_bulk',
                                        items: finalOrderList,
                                        totalCost: totalCost,
                                        target: { x: managersOffice.x + managersOffice.w / 2, y: managersOffice.y + managersOffice.h + 10 }
                                    };
                                    manager.state = 'going_to_office';
                                    manager.hasPlacedMorningOrder = true;
                                    manager.canOrder = false;
                                    manager.lastOrderQuarter = 0;
                                    break; // Exit switch case to process new state
                                }
                            }
                        }
                        */

                        // --- Urgent Order Logic (DISABLED) ---
                        /*
                        let urgentOrderItem = null;
                        let requiredQuantity = 0;
                        const waitingCustomers = customers.filter(c => c.isWaitingForRestock);
                        if (waitingCustomers.length > 0) {
                            const customerDemands = {};
                            for (const customer of waitingCustomers) {
                                const waitingOnItem = customer.requestedItems[customer.currentItemIndex];
                                if (waitingOnItem && getTotalStock(waitingOnItem) === 0) {
                                    const isItemUnlocked = storageCells.some(cell => unlocks.storage[storageCells.indexOf(cell)] && cell.allowedItems.includes(waitingOnItem));
                                    if (isItemUnlocked) {
                                        customerDemands[waitingOnItem] = (customerDemands[waitingOnItem] || 0) + 1;
                                    }
                                }
                            }
                            let maxDemand = 0;
                            for (const item in customerDemands) {
                                if (customerDemands[item] > maxDemand) {
                                    maxDemand = customerDemands[item];
                                    urgentOrderItem = item;
                                    requiredQuantity = customerDemands[item];
                                }
                            }
                        }

                        if (urgentOrderItem) {
                            const quantityToOrder = requiredQuantity;
                            const packagesFromOrder = Math.ceil(quantityToOrder / MAX_PACKAGE_SIZE);
                            manager.task = {
                                action: 'order',
                                item: urgentOrderItem,
                                isUrgent: true,
                                requiredQuantity: requiredQuantity,
                                target: { x: managersOffice.x + managersOffice.w / 2, y: managersOffice.y + managersOffice.h + 10 }
                            };
                            manager.state = 'going_to_office';
                            manager.stateTimer = 1000;
                            break;
                        }
                        */

                        // --- Evening Low-Stock Check (DISABLED) ---
                        /*
                        if (manager.canOrder && dayPhase === 'closing') {
                            const lowStockItems = Object.keys(items).filter(item => {
                                const stock = getTotalStock(item);
                                return stock < 5;
                            });

                            if (lowStockItems.length > 0) {
                                lowStockItems.sort((a, b) => (itemPopularity[b] || 0) - (itemPopularity[a] || 0));
                                const mostPopularLowItem = lowStockItems[0];
                                const quantityToOrder = 1;
                                const packagesFromOrder = Math.ceil(quantityToOrder / MAX_PACKAGE_SIZE);

                                manager.task = {
                                    action: 'order',
                                    item: mostPopularLowItem,
                                    isUrgent: false,
                                    target: { x: managersOffice.x + managersOffice.w / 2, y: managersOffice.y + managersOffice.h + 10 }
                                };
                                manager.state = 'going_to_office';
                            } else {
                                 manager.stateTimer = 10000;
                                if(Math.hypot(manager.x - manager.idleX, manager.y - manager.idleY) > 5) {
                                     manager.task = { target: {x: manager.idleX, y: manager.idleY} };
                                 } else {
                                     manager.task = null;
                                 }
                            }
                        } else {
                             manager.stateTimer = 5000;
                        }
                        */
                        manager.stateTimer = 5000; // Manager will now just idle
                    }

                     if(manager.task && manager.task.target) {
                         moveCharacterTowards(manager, manager.task.target.x, manager.task.target.y, deltaTime);
                    }
                    break;
                case 'going_to_office':
                     if (moveCharacterTowards(manager, manager.task.target.x, manager.task.target.y, deltaTime)) {
                        manager.state = 'ordering';
                        manager.stateTimer = 3000; // Time to "place order"
                    }
                    break;
                case 'ordering':
                    if(manager.stateTimer <= 0) {
                        const orderTask = manager.task;

                        if (orderTask.action === 'order_bulk') {
                            cash -= orderTask.totalCost;
                            updateUI();
                            orderTask.items.forEach(orderItem => {
                                dailySupplyOrders.push({
                                    orderedBy: 'Manager',
                                    itemName: orderItem.itemName,
                                    quantity: orderItem.quantity,
                                    cost: items[orderItem.itemName].cost * orderItem.quantity
                                });
                                let remainingQuantity = orderItem.quantity;
                                while (remainingQuantity > 0) {
                                    const quantityForPackage = Math.min(remainingQuantity, MAX_PACKAGE_SIZE);
                                    loadingDockPackages.push({ itemName: orderItem.itemName, quantity: quantityForPackage });
                                    remainingQuantity -= quantityForPackage;
                                }
                            });
                            spawnFloatingText(`Bulk Order Placed! (-$${orderTask.totalCost.toFixed(2)})`, manager.x, manager.y - 90, '#3b82f6');
                        } else {
                            // Single item order logic
                            const itemToOrder = orderTask.item;
                            const quantityToOrder = orderTask.isUrgent ? orderTask.requiredQuantity : 1;
                            const restockPrice = items[itemToOrder].cost;
                            const totalCost = restockPrice * quantityToOrder;

                            if (cash - totalCost < 30) {
                                spawnFloatingText(`Can't afford ${itemToOrder}!`, manager.x, manager.y - 90, '#ef4444');
                                manager.state = 'idle';
                                manager.stateTimer = 15000; // Wait longer before trying again
                                manager.task = { target: {x: manager.idleX, y: manager.idleY} };
                                break;
                            }

                            cash -= totalCost;
                            updateUI();
                            dailySupplyOrders.push({
                                orderedBy: 'Manager',
                                itemName: itemToOrder,
                                quantity: quantityToOrder,
                                cost: totalCost
                            });

                            let remainingQuantity = quantityToOrder;
                            while (remainingQuantity > 0) {
                                const quantityForPackage = Math.min(remainingQuantity, MAX_PACKAGE_SIZE);
                                loadingDockPackages.push({itemName: itemToOrder, quantity: quantityForPackage});
                                remainingQuantity -= quantityForPackage;
                            }
                             spawnFloatingText(`${itemToOrder} Ordered! (-$${totalCost.toFixed(2)})`, manager.x, manager.y - 90, '#3b82f6');
                        }

                        manager.state = 'idle';
                        manager.stateTimer = 5000;
                        manager.task = { target: {x: manager.idleX, y: manager.idleY} };

                        if (orderTask.action !== 'order_bulk' && !orderTask.isUrgent) {
                            manager.canOrder = false;
                            manager.lastOrderQuarter = currentQuarter;
                        }
                    }
                    break;
            }
        }

        function updateSalesperson(deltaTime) {
            if (!unlocks.employees.salesperson) return;

            if (handleEmployeeOffDuty(salesperson, 'salesperson', deltaTime)) return;

            updateCharacterAnimation(salesperson, deltaTime);
            salesperson.stateTimer -= deltaTime;

            switch (salesperson.state) {
                case 'idle':
                    if (salesperson.stateTimer <= 0) {
                        const customerToAssist = customers.find(c => c.behaviorType === 'needsAssistance' && !c.needsAssistanceFulfilled && !c.leaving);
                        if (customerToAssist) {
                            salesperson.state = 'assistingCustomer';
                            salesperson.task = {
                                customer: customerToAssist,
                                currentItemIndex: 0,
                                missingItems: [] // REFACTOR: Initialize missing items list
                            };
                            return;
                        }

                        const customerToInteract = customers.find(c => c.behaviorType === 'needsInteraction' && !c.isInteractedWith && !c.leaving);
                        if (customerToInteract) {
                            salesperson.state = 'goingToInteract';
                            salesperson.task = { customer: customerToInteract, target: { x: customerToInteract.x + 50, y: customerToInteract.y } };
                            return;
                        }

                        salesperson.state = 'wandering';
                        salesperson.stateTimer = Math.random() * 3000 + 2000;
                        if (shelves && shelves.length > 0) {
                            const randomShelf = shelves[Math.floor(Math.random() * shelves.length)];
                            salesperson.task = { target: { x: randomShelf.rect.x + randomShelf.rect.w / 2, y: randomShelf.rect.y + randomShelf.rect.h + 20 } };
                        } else {
                            salesperson.state = 'idle';
                            salesperson.stateTimer = 2000;
                            salesperson.task = null;
                        }
                    }
                    break;

                case 'wandering':
                    if (!salesperson.task || moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        salesperson.state = 'idle';
                        salesperson.task = null;
                        salesperson.stateTimer = 1000;
                    }
                    break;

                case 'goingToInteract':
                    if (!salesperson.task.customer || salesperson.task.customer.leaving) {
                         salesperson.state = 'idle';
                         salesperson.task = null;
                         return;
                    }
                    if (moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        salesperson.state = 'interacting';
                        salesperson.stateTimer = 1000;
                    }
                    break;

                case 'interacting':
                    if (salesperson.stateTimer <= 0) {
                        const customer = salesperson.task.customer;
                        if (customer && !customer.leaving) {
                            if (customer.waitTimer > 60) { // Check for 60 seconds
                                // The salesperson can also convince waiting customers
                                if (customer.order.length > 0) {
                                    customer.discount = 0.25;
                                    customer.state = 'queuing';
                                    customer.request = "Okay, you've convinced me.";
                                    spawnFloatingText("Deal Made!", salesperson.x, salesperson.y - 90, '#3b82f6');
                                } else {
                                    // Same 50/50 logic as player
                                    if (Math.random() < 0.5) {
                                        const allStockedItems = [];
                                        shelves.forEach(shelf => shelf.items.forEach(slot => {
                                            if (slot.assignedItem && slot.quantity > 0) allStockedItems.push(slot.assignedItem);
                                        }));
                                        if (allStockedItems.length > 0) {
                                            const randomItem = allStockedItems[Math.floor(Math.random() * allStockedItems.length)];
                                            customer.order.push(randomItem);
                                            customer.profile.patience -= 10;
                                            customer.patience = customer.profile.patience; // Sync instance
                                            customer.state = 'queuing';
                                            customer.request = `Alright, you've convinced me. I'll take the ${randomItem}.`;
                                            spawnFloatingText("Convinced!", salesperson.x, salesperson.y - 90, '#f59e0b');
                                        } else {
                                            customer.profile.patience -= 30;
                                            customer.patience = customer.profile.patience; // Sync instance
                                            logCustomerToSalesReport(customer);
                                            customer.state = 'leaving';
                                            customer.request = "Your staff couldn't find anything either!";
                                            spawnFloatingText("Leaving Angry!", salesperson.x, salesperson.y - 90, '#ef4444');
                                        }
                                    } else {
                                        customer.profile.patience -= 30;
                                        customer.patience = customer.profile.patience; // Sync instance
                                        logCustomerToSalesReport(customer);
                                        customer.state = 'leaving';
                                        customer.request = "I'm tired of waiting, even with your help.";
                                        spawnFloatingText("Leaving Angry!", salesperson.x, salesperson.y - 90, '#ef4444');
                                    }
                                }
                            } else {
                                // Original interaction logic
                                customer.isInteractedWith = true;
                                customer.helpedBySalesperson = true;
                                spawnFloatingText("Let me help!", salesperson.x, salesperson.y - 90, '#3b82f6');
                            }
                        }
                        salesperson.state = 'idle';
                        salesperson.task = null;
                        salesperson.stateTimer = 2000;
                    }
                    break;

                case 'assistingCustomer': // This state now just initializes the collecting state
                    salesperson.state = 'collectingItem';
                    break;
                case 'collectingItem':
                    {
                        const task = salesperson.task;
                        if (!task.customer || task.customer.leaving) {
                            salesperson.state = 'idle';
                            salesperson.task = null;
                            return;
                        }

                        // REFACTOR START: Logic to check all items before reporting.
                        if (task.currentItemIndex >= task.customer.requestedItems.length) {
                            // Finished checking all items.
                            if (task.missingItems.length > 0) {
                                salesperson.state = 'reportingToPlayer';
                                const missingItemsString = task.missingItems.join(', ');
                                salesperson.task.message = `We're out of ${missingItemsString} for ${task.customer.name}!`;
                            } else {
                                // All items collected, go deliver them.
                                salesperson.state = 'deliveringItems';
                                salesperson.task.target = { x: task.customer.x - 50, y: task.customer.y };
                            }
                            return; // Exit switch to process new state in next frame
                        }
                        // REFACTOR END

                        const itemToCollect = task.customer.requestedItems[task.currentItemIndex];

                        const targetShelf = shelves.find(s => s.items.some(i => i && i.assignedItem === itemToCollect && i.quantity > 0));

                        if (targetShelf) {
                            const targetPos = { x: targetShelf.rect.x + targetShelf.rect.w / 2, y: targetShelf.rect.y + targetShelf.rect.h + 20 };
                            if (moveCharacterTowards(salesperson, targetPos.x, targetPos.y, deltaTime)) {
                                const slot = targetShelf.items.find(i => i && i.assignedItem === itemToCollect && i.quantity > 0);
                                if (slot) {
                                    slot.quantity--;
                                    salesperson.basket.push(itemToCollect);
                                    task.currentItemIndex++; // Move to next item
                                }
                            }
                            return;
                        }

                        const targetCell = storageCells.find(c => c.allowedItems.includes(itemToCollect) && c.items[itemToCollect] > 0);
                        if (targetCell) {
                            salesperson.state = 'fetchingFromStorage';
                            salesperson.task.target = {
                                x: targetCell.rect.x + targetCell.rect.w / 2,
                                y: targetCell.rect.y + targetCell.rect.h + 20,
                                cell: targetCell,
                                item: itemToCollect
                            };
                            return;
                        }

                        // REFACTOR: Item is not found anywhere. Add to missing list and check next item.
                        task.missingItems.push(itemToCollect);
                        task.currentItemIndex++;
                    }
                    break;

                case 'fetchingFromStorage':
                    if (moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        const cell = salesperson.task.target.cell;
                        const item = salesperson.task.target.item;
                        if (cell && item && cell.items[item] > 0) {
                            cell.items[item]--;
                            salesperson.basket.push(item);
                            salesperson.task.currentItemIndex++;
                        }
                        salesperson.state = 'collectingItem'; // Go back to check for the next item
                        salesperson.task.target = null;
                    }
                    break;
                case 'reportingToPlayer':
                    salesperson.task.target = { x: player.x, y: player.y + 50 };

                    if (moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        spawnFloatingText(salesperson.task.message, salesperson.x, salesperson.y - 90, '#8b5cf6');

                        // After reporting, go deliver whatever was found
                        salesperson.state = 'deliveringItems';
                        salesperson.task.target = { x: salesperson.task.customer.x - 50, y: salesperson.task.customer.y };
                        salesperson.task.message = null;
                    }
                    break;
                case 'deliveringItems':
                     if (!salesperson.task.customer || salesperson.task.customer.leaving) {
                         salesperson.state = 'idle';
                         salesperson.task = null;
                         return;
                    }
                    if (moveCharacterTowards(salesperson, salesperson.task.target.x, salesperson.task.target.y, deltaTime)) {
                        if(salesperson.basket.length > 0) {
                            salesperson.task.customer.order.push(...salesperson.basket);
                            salesperson.basket = [];
                            spawnFloatingText("Here's what I found!", salesperson.x, salesperson.y - 90, '#22c55e');
                        }
                        salesperson.task.customer.waitTimer = 0; // Reset wait timer
                        salesperson.task.customer.needsAssistanceFulfilled = true;
                        salesperson.task.customer.helpedBySalesperson = true;
                        salesperson.task.customer.state = 'queuing';
                        salesperson.task.customer.request = "Thank you so much for your help!";


                        salesperson.state = 'idle';
                        salesperson.task = null;
                        salesperson.stateTimer = 3000;
                    }
                    break;
            }
        }


        function findShelfForStocking(itemName) {
            let targetShelf = shelves.find((s, i) => unlocks.shelves[i] && s.items.some(i => i && i.assignedItem === itemName && i.quantity < MAX_SHELF_STACK));
             if (!targetShelf) {
                 targetShelf = shelves.find((s, i) => unlocks.shelves[i] && s.items.some(i => i.assignedItem === null));
            }
            return targetShelf;
        }

        function getStorageStock(itemName) {
            let total = 0;
            storageCells.forEach((cell, index) => {
                if (unlocks.storage[index] && cell.items && cell.items[itemName]) {
                    total += cell.items[itemName];
                }
            });
            return total;
        }

        function findRestockingTask() {
            const coffeeItems = ['Beans', 'Milks', 'Sugar', 'Snacks'];
            const availableStock = new Map();
            storageCells.forEach((cell, index) => {
                if (unlocks.storage[index] && cell.items) {
                    for (const itemName in cell.items) {
                        if (cell.items[itemName] > 0 && !coffeeItems.includes(itemName)) {
                            const currentStock = availableStock.get(itemName) || { fromStorage: 0, fromDock: 0 };
                            currentStock.fromStorage += cell.items[itemName];
                            availableStock.set(itemName, currentStock);
                        }
                    }
                }
            });
            loadingDockPackages.forEach(pkg => {
                if (!coffeeItems.includes(pkg.itemName)) {
                    const currentStock = availableStock.get(pkg.itemName) || { fromStorage: 0, fromDock: 0 };
                    currentStock.fromDock += pkg.quantity;
                    availableStock.set(pkg.itemName, currentStock);
                }
            });

            if (availableStock.size === 0) {
                return null;
            }

            const assignedNeeded = new Set();
            const unassignedAvailable = new Set();

            shelves.forEach((shelf, i) => {
                if (unlocks.shelves[i]) {
                    shelf.items.forEach(slot => {
                        if (slot.assignedItem && slot.quantity < MAX_SHELF_STACK && availableStock.has(slot.assignedItem)) {
                            assignedNeeded.add(slot.assignedItem);
                        }
                    });
                }
            });

            const hasEmptySlot = shelves.some((s, i) => unlocks.shelves[i] && s.items.some(i => i.assignedItem === null));
            if (hasEmptySlot) {
                for (const [itemName, stock] of availableStock.entries()) {
                    const isAssigned = shelves.some(s => s.items.some(i => i.assignedItem === itemName));
                    if (!isAssigned) {
                        unassignedAvailable.add(itemName);
                    }
                }
            }

            const neededItems = [...assignedNeeded, ...unassignedAvailable];

            if (neededItems.length > 0) {
                const itemToFetch = neededItems[0];
                const stockLocation = availableStock.get(itemToFetch);

                if (stockLocation.fromStorage > 0) {
                    const storageCellWithItem = storageCells.find((c, i) =>
                        unlocks.storage[i] &&
                        c.allowedItems.includes(itemToFetch) &&
                        c.items[itemToFetch] > 0
                    );
                    if (storageCellWithItem) {
                        return {
                            action: 'fetching',
                            item: itemToFetch,
                            target: { x: storageCellWithItem.rect.x + storageCellWithItem.rect.w / 2, y: storageCellWithItem.rect.y + storageCellWithItem.rect.h + 10 }
                        };
                    }
                }

                if (stockLocation.fromDock > 0) {
                    const packageLayout = getPackageLayout();
                    const packageToFetch = packageLayout.find(p => p.itemName === itemToFetch);
                    if (packageToFetch) {
                        return {
                            action: 'fetching_dock',
                            item: itemToFetch,
                            packageIndex: packageToFetch.originalIndex,
                            target: { x: packageToFetch.x + packageToFetch.w / 2, y: loadingDock.y - 40 }
                        };
                    }
                }
            }

            return null;
        }

        function findCoffeeRestockingTask() {
            if (!unlocks.facilities.coffeeShop || !coffeeShop.storage) return null;

            const coffeeItems = coffeeShop.storage.allowedItems;
            const currentStock = Object.values(coffeeShop.storage.items).reduce((a, b) => a + b, 0);

            if (currentStock >= coffeeShop.storage.capacity) {
                return null; // Storage is full.
            }

            const packageLayout = getPackageLayout();
            const coffeePackageToFetch = packageLayout.find(p => coffeeItems.includes(p.itemName));

            if (coffeePackageToFetch) {
                return {
                    action: 'fetching_coffee',
                    item: coffeePackageToFetch.itemName,
                    packageIndex: coffeePackageToFetch.originalIndex,
                    target: { x: coffeePackageToFetch.x + coffeePackageToFetch.w / 2, y: loadingDock.y - 40 }
                };
            }
            return null;
        }

        function updatePlayer(deltaTime) {
            let dx = 0, dy = 0;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) dx += 1;
            if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) dy += 1;

            const oldY = player.y;
            let newX = player.x;
            let newY = player.y;

            if (dx !== 0 || dy !== 0) {
                // Keyboard movement overrides click-to-move
                player.targetX = null;
                player.targetY = null;

                newX = player.x + dx * player.speed * (deltaTime / 1000);
                newY = player.y + dy * player.speed * (deltaTime / 1000);

                player.state = 'walk';
                if (dx < 0) player.facing = 'left';
                if (dx > 0) player.facing = 'right';

            } else if (player.targetX !== null && player.targetY !== null) {
                // Click-to-move logic
                const targetDx = player.targetX - player.x;
                const targetDy = player.targetY - player.y;
                const dist = Math.hypot(targetDx, targetDy);

                if (dist < 5) { // Threshold to stop
                    player.targetX = null;
                    player.targetY = null;
                    player.state = 'idle';
                } else {
                    const moveX = (targetDx / dist) * player.speed * (deltaTime / 1000);
                    const moveY = (targetDy / dist) * player.speed * (deltaTime / 1000);
                    newX = player.x + moveX;
                    newY = player.y + moveY;

                    if (Math.abs(targetDx) > Math.abs(targetDy)) {
                        player.facing = moveX > 0 ? 'right' : 'left';
                    }
                    player.state = 'walk';
                }
            } else {
                player.state = 'idle';
            }

            // Coffee shop collision
            if (coffeeShop.rect.w > 0) { // check if coffee shop exists
                if (oldY >= coffeeShop.collisionLineY && newY < coffeeShop.collisionLineY &&
                    newX > coffeeShop.rect.x && newX < coffeeShop.rect.x + coffeeShop.rect.w) {
                    newY = coffeeShop.collisionLineY;
                    if (player.targetY && player.targetY < coffeeShop.collisionLineY) {
                        player.targetY = null; // Stop click-to-move if hitting the barrier
                    }
                }
            }

            player.x = newX;
            player.y = newY;

            const worldWidth = canvas.width + managersOffice.w;
            player.x = Math.max(player.frameWidth / 2, Math.min(worldWidth - player.frameWidth / 2, player.x));
            player.y = Math.max(player.frameHeight, Math.min(canvas.height, player.y));


            // Camera control logic
            const officeThreshold = officeWidth + 50; // 50px into the store
            if (player.x < officeThreshold && cameraState !== 'office') {
                cameraState = 'office';
                targetCameraX = 0;
            } else if (player.x >= officeThreshold && cameraState !== 'store') {
                cameraState = 'store';
                targetCameraX = -officeWidth;
            }

            updateCharacterAnimation(player, deltaTime);
        }

        function spawnFloatingText(text, x, y, color = 'green', duration = 2500) { // Increased duration
            floatingTexts.push({ text, x, y, color, duration, life: duration });
        }

        function updateAndDrawFloatingTexts(deltaTime) {
            floatingTexts.forEach(text => {
                text.life -= deltaTime;
                text.y -= 20 * (deltaTime / 1000); // Float up
                const opacity = Math.max(0, text.life / text.duration);

                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.fillStyle = text.color;
                ctx.font = 'bold 24px "Patrick Hand", cursive';
                ctx.textAlign = 'center';

                // Add glow effect
                ctx.shadowColor = text.color;
                ctx.shadowBlur = 10;

                ctx.fillText(text.text, text.x, text.y);
                ctx.restore();
            });
            floatingTexts = floatingTexts.filter(t => t.life > 0);
        }

        function drawPieClock() {
            const centerX = pieClockCanvas.width / 2;
            const centerY = pieClockCanvas.height / 2;
            const radius = Math.min(centerX, centerY) - 2;
            pieClockCtx.clearRect(0, 0, pieClockCanvas.width, pieClockCanvas.height);

            // Visual indicator for double time
            if (timeMultiplier > 1) {
                pieClockCtx.fillStyle = 'rgba(255, 255, 150, 0.3)'; // Light yellow glow
                pieClockCtx.beginPath();
                pieClockCtx.arc(centerX, centerY, radius + 2, 0, 2 * Math.PI);
                pieClockCtx.fill();
            }

            const startAngle = -Math.PI / 2;
            const openingAngle = (OPENING_DURATION / DAY_DURATION) * 2 * Math.PI;
            const dayShiftAngle = (DAY_SHIFT_DURATION / DAY_DURATION) * 2 * Math.PI;
            const nightShiftAngle = (NIGHT_SHIFT_DURATION / DAY_DURATION) * 2 * Math.PI;

            const openingColor = '#facc15'; // Yellow
            const openColor = '#22c55e'; // Green
            const nightShiftColor = '#16a34a'; // Darker Green
            const closingColor = '#ef4444'; // Red
            const overlayColor = 'rgba(93, 64, 55, 0.6)'; // Darkening overlay

            // Opening segment
            pieClockCtx.fillStyle = openingColor;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.arc(centerX, centerY, radius, startAngle, startAngle + openingAngle);
            pieClockCtx.closePath();
            pieClockCtx.fill();

            // Day Shift segment
            pieClockCtx.fillStyle = openColor;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.arc(centerX, centerY, radius, startAngle + openingAngle, startAngle + openingAngle + dayShiftAngle);
            pieClockCtx.closePath();
            pieClockCtx.fill();

            // Night Shift segment
            pieClockCtx.fillStyle = nightShiftColor;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.arc(centerX, centerY, radius, startAngle + openingAngle + dayShiftAngle, startAngle + openingAngle + dayShiftAngle + nightShiftAngle);
            pieClockCtx.closePath();
            pieClockCtx.fill();

            // Closing segment
            pieClockCtx.fillStyle = closingColor;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.arc(centerX, centerY, radius, startAngle + openingAngle + dayShiftAngle + nightShiftAngle, startAngle + 2 * Math.PI);
            pieClockCtx.closePath();
            pieClockCtx.fill();

            if (dayStarted) {
                 const progressAngle = ((DAY_DURATION - dayTimer) / DAY_DURATION) * 2 * Math.PI;
                 pieClockCtx.fillStyle = overlayColor;
                 pieClockCtx.beginPath();
                 pieClockCtx.moveTo(centerX, centerY);
                 pieClockCtx.arc(centerX, centerY, radius + 1, startAngle + progressAngle, startAngle + 2 * Math.PI);
                 pieClockCtx.closePath();
                 pieClockCtx.fill();
            } else {
                // If day is over, cover whole pie
                pieClockCtx.fillStyle = overlayColor;
                pieClockCtx.beginPath();
                pieClockCtx.arc(centerX, centerY, radius + 1, 0, 2 * Math.PI);
                pieClockCtx.fill();
            }

            // Draw the clock hand
            if (dayStarted) {
                const handAngle = startAngle + ((DAY_DURATION - dayTimer) / DAY_DURATION) * 2 * Math.PI;
                const handLength = radius * 0.9;
                const endX = centerX + handLength * Math.cos(handAngle);
                const endY = centerY + handLength * Math.sin(handAngle);

                // Line
                pieClockCtx.save();
                pieClockCtx.strokeStyle = 'white';
                pieClockCtx.lineWidth = 1.5;
                pieClockCtx.beginPath();
                pieClockCtx.moveTo(centerX, centerY);
                pieClockCtx.lineTo(endX, endY);
                pieClockCtx.stroke();
                pieClockCtx.restore();

                // Flourished tip
                pieClockCtx.save();
                pieClockCtx.translate(endX, endY);
                pieClockCtx.rotate(handAngle + Math.PI / 2);
                pieClockCtx.fillStyle = 'white';
                pieClockCtx.beginPath();
                pieClockCtx.moveTo(0, -2);
                pieClockCtx.lineTo(-4, 5);
                pieClockCtx.lineTo(4, 5);
                pieClockCtx.closePath();
                pieClockCtx.fill();
                pieClockCtx.restore();
            }

            // Border
            pieClockCtx.strokeStyle = '#5d4037';
            pieClockCtx.lineWidth = 2;
            pieClockCtx.beginPath();
            pieClockCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            pieClockCtx.stroke();

            // Add dashed lines for break times
            pieClockCtx.save();
            pieClockCtx.strokeStyle = 'black';
            pieClockCtx.lineWidth = 1;
            pieClockCtx.setLineDash([2, 3]); // Dashed line style

            // Day shift break (middle of day shift)
            const dayBreakRatio = (OPENING_DURATION + (DAY_SHIFT_DURATION / 2)) / DAY_DURATION;
            const dayBreakAngle = startAngle + dayBreakRatio * 2 * Math.PI;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.lineTo(centerX + radius * Math.cos(dayBreakAngle), centerY + radius * Math.sin(dayBreakAngle));
            pieClockCtx.stroke();

            // Night shift break (middle of night shift)
            const nightBreakRatio = (OPENING_DURATION + DAY_SHIFT_DURATION + (NIGHT_SHIFT_DURATION / 2)) / DAY_DURATION;
            const nightBreakAngle = startAngle + nightBreakRatio * 2 * Math.PI;
            pieClockCtx.beginPath();
            pieClockCtx.moveTo(centerX, centerY);
            pieClockCtx.lineTo(centerX + radius * Math.cos(nightBreakAngle), centerY + radius * Math.sin(nightBreakAngle));
            pieClockCtx.stroke();

            pieClockCtx.restore(); // Restore to solid lines

            // Darken the clock if paused
            if (isPaused) {
                pieClockCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                pieClockCtx.beginPath();
                pieClockCtx.arc(centerX, centerY, radius + 1, 0, 2 * Math.PI);
                pieClockCtx.fill();
            }
        }

        function handleClockClick() {
            if (!dayStarted) {
                // If the day hasn't started and we are not in continuous mode, clicking the clock starts the day.
                if (!continuousMode) {
                    document.getElementById('start-day-btn').click();
                }
                return; // In either case, if day hasn't started, do nothing else.
            }

            // The rest of the function is for skipping parts of an already started day.
            if (dayPhase === 'opening') {
                dayTimer = DAY_SHIFT_DURATION + NIGHT_SHIFT_DURATION + CLOSING_DURATION;
                dayPhase = 'day-shift';
                spawnFloatingText('Opening Skipped!', canvas.width / 2, 120, '#facc15');
            } else if (dayPhase === 'day-shift') {
                dayTimer = NIGHT_SHIFT_DURATION + CLOSING_DURATION;
                dayPhase = 'night-shift';
                spawnFloatingText('Day Shift Skipped!', canvas.width / 2, 120, '#22c55e');
            } else if (dayPhase === 'night-shift') {
                dayTimer = CLOSING_DURATION;
                dayPhase = 'closing';
                spawnFloatingText('Night Shift Skipped!', canvas.width / 2, 120, '#ef4444');
            } else if (dayPhase === 'closing') {
                dayTimer = 1;
                spawnFloatingText('Closing Skipped!', canvas.width / 2, 120, '#ef4444');
            }
        }

        function gameLoop(timestamp) {
            if (!running || !lastTimestamp) {
                lastTimestamp = timestamp;
                requestAnimationFrame(gameLoop);
                return;
            }
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            if (isGameActive && !isPaused) {
                const effectiveDeltaTime = deltaTime * timeMultiplier;

                if (dayStarted) {
                    dayTimer -= effectiveDeltaTime;

                    // Track employee work time based on shift
                const employees = { cashier, stocker, barista, manager, salesperson };
                const currentShiftPhase = dayPhase.replace('-', ' '); // "day-shift" -> "day shift"
                for (const empKey in employees) {
                    const employee = employees[empKey];
                    if (unlocks.employees[empKey] && !employee.onBreak && employee.shift.map(s => s.toLowerCase()).includes(currentShiftPhase.toLowerCase())) {
                        employeeWorkTimers[empKey] = (employeeWorkTimers[empKey] || 0) + effectiveDeltaTime;
                    }
                }

                // --- Shift-Based Break Logic ---
                const elapsedTime = DAY_DURATION - dayTimer;
                const dayShiftBreakTime = OPENING_DURATION + (DAY_SHIFT_DURATION / 2);
                const nightShiftBreakTime = OPENING_DURATION + DAY_SHIFT_DURATION + (NIGHT_SHIFT_DURATION / 2);

                if (!dayShiftBreakTriggered && elapsedTime >= dayShiftBreakTime && !casualNoBreaks) {
                    dayShiftBreakTriggered = true;
                    isMandatoryBreak = true;
                    spawnFloatingText("FIRST BREAK!", canvas.width / 2, 120, '#3b82f6');

                    const employees = { cashier, stocker, barista, manager, salesperson };
                    const employeesOnFirstBreak = [];
                    for (const empKey in employees) {
                        const employee = employees[empKey];
                        const worksDay = employee.shift.includes('Day Shift');
                        const worksNight = employee.shift.includes('Night Shift');

                        if (unlocks.employees[empKey] && worksDay && !employee.breakTakenToday) {
                             if (!worksNight || employee.breakPreference === 'first') {
                                employee.onBreak = true;
                                employee.breakTakenToday = true;
                                employeesOnFirstBreak.push(employee);
                            }
                        }
                    }
                    if (isPhoneOpen && activePhoneScreen === 'employees-panel') openEmployeesPanel();

                    setTimeout(() => {
                        isMandatoryBreak = false;
                        employeesOnFirstBreak.forEach(employee => {
                             if (!employee.playerInitiatedBreak) {
                                employee.onBreak = false;
                            }
                        });
                        if (isPhoneOpen && activePhoneScreen === 'employees-panel') openEmployeesPanel();
                        spawnFloatingText("Break's over!", canvas.width / 2, 120, '#22c55e');
                    }, BREAK_DURATION);
                }

                if (!nightShiftBreakTriggered && elapsedTime >= nightShiftBreakTime && !casualNoBreaks) {
                    nightShiftBreakTriggered = true;
                    isMandatoryBreak = true;
                    spawnFloatingText("LAST BREAK!", canvas.width / 2, 120, '#3b82f6');

                    const employees = { cashier, stocker, barista, manager, salesperson };
                    const employeesOnLastBreak = [];
                    for (const empKey in employees) {
                        const employee = employees[empKey];
                        const worksNight = employee.shift.includes('Night Shift');

                        if (unlocks.employees[empKey] && worksNight && !employee.breakTakenToday) {
                            employee.onBreak = true;
                            employee.breakTakenToday = true;
                            employeesOnLastBreak.push(employee);
                        }
                    }
                    if (isPhoneOpen && activePhoneScreen === 'employees-panel') openEmployeesPanel();

                    setTimeout(() => {
                        isMandatoryBreak = false;
                        employeesOnLastBreak.forEach(employee => {
                            if (!employee.playerInitiatedBreak) {
                                employee.onBreak = false;
                            }
                        });
                        if (isPhoneOpen && activePhoneScreen === 'employees-panel') openEmployeesPanel();
                        spawnFloatingText("Break's over!", canvas.width / 2, 120, '#22c55e');
                    }, BREAK_DURATION);
                }


                if (dayTimer > DAY_SHIFT_DURATION + NIGHT_SHIFT_DURATION + CLOSING_DURATION) {
                    dayPhase = 'opening';
                } else if (dayTimer > NIGHT_SHIFT_DURATION + CLOSING_DURATION) {
                    dayPhase = 'day-shift';
                } else if (dayTimer > CLOSING_DURATION) {
                    dayPhase = 'night-shift';
                } else if (dayTimer > 0) {
                    dayPhase = 'closing';
                } else {
                    dayPhase = 'pre-open';
                    nextDay();
                }
            }

            updatePlayer(effectiveDeltaTime);

            // Zone 1 point system
            if (dayStarted && isPlayerInZone(officeZone1)) {
                const pointThreshold = 5000 / timeMultiplier;
                zone1PointTimer += effectiveDeltaTime;
                if (zone1PointTimer >= pointThreshold) {
                    shopPoints++;
                    zone1PointTimer -= pointThreshold;
                    updateUI();
                    spawnFloatingText("+1 Point", player.x, player.y - 90, "#f59e0b");
                }
            } else {
                zone1PointTimer = 0;
            }

            // Coffee shop money making timer
            if (unlocks.facilities.coffeeShop && dayStarted && isPlayerInZone(coffeeShop.behindCounterZone)) {
                const cashThreshold = 5000 / timeMultiplier;
                coffeeShopBehindCounterTimer += effectiveDeltaTime;
                if (coffeeShopBehindCounterTimer >= cashThreshold) {
                    cash++;
                    coffeeShopBehindCounterTimer -= cashThreshold;
                    updateUI();
                    spawnFloatingText("+$1", player.x, player.y - 90, "#22c55e");
                }
            } else {
                coffeeShopBehindCounterTimer = 0;
            }

            updateStocker(effectiveDeltaTime);
            updateCashier(effectiveDeltaTime);
            updateBarista(effectiveDeltaTime);
            updateManager(effectiveDeltaTime);
            updateSalesperson(effectiveDeltaTime);

            if (dayPhase === 'day-shift' || dayPhase === 'night-shift') {
                timeSinceLastCustomer += effectiveDeltaTime;
                if (timeSinceLastCustomer >= CUSTOMER_SPAWN_INTERVAL) {
                    timeSinceLastCustomer = 0;
                    spawnNewCustomer();
                }
            }

            customers.forEach(customer => customer.update(effectiveDeltaTime));
            customers = customers.filter(c => c.x < canvas.width + 100 && c.x > -100);
        }

        // Update things that should run even when paused (e.g. UI animations)
        const cashProgressBar = document.getElementById('cash-progress-bar');
        if (cashProgressBar) {
            const cashProgress = isPaused ? 0 : Math.min(100, (coffeeShopBehindCounterTimer / 5000) * 100);
            cashProgressBar.style.width = `${cashProgress}%`;
        }

        const pointsProgressBar = document.getElementById('points-progress-bar');
        if (pointsProgressBar) {
            const pointsProgress = isPaused ? 0 : Math.min(100, (zone1PointTimer / 5000) * 100);
            pointsProgressBar.style.width = `${pointsProgress}%`;
        }

        if (activeShelf) {
                const shelf = activeShelf;
                const dist = Math.hypot(player.x - (shelf.rect.x + shelf.rect.w/2), player.y - (shelf.rect.y + shelf.rect.h/2));
                if (dist > 200) {
                    togglePanel('shelf', false);
                }
            }
            if (activeStorageCell) {
                const cell = activeStorageCell;
                const dist = Math.hypot(player.x - (cell.rect.x + cell.rect.w/2), player.y - (cell.rect.y + cell.rect.h/2));
                if (dist > 200) {
                    togglePanel('storage', false);
                }
            }

            populateInStoreCustomers();

            // Real-time clipboard updates
            clipboardUpdateTimer += deltaTime;
            if (activePhoneScreen === 'customers-panel' && clipboardUpdateTimer >= CLIPBOARD_UPDATE_INTERVAL) {
                const inStoreList = document.getElementById('in-store-customer-list');
                const allList = document.getElementById('all-customer-list');
                if (inStoreList && inStoreList.offsetParent !== null) {
                    populateInStoreCustomers();
                }
                if (allList && allList.offsetParent !== null) {
                    populateAllCustomers();
                }
                clipboardUpdateTimer = 0;
            }

            // Send periodic updates to the companion
            if (hostConnection && hostConnection.open) {
                companionUpdateTimer += deltaTime;
                if (companionUpdateTimer >= COMPANION_UPDATE_INTERVAL) {
                    sendFullGameStateToCompanion();
                    companionUpdateTimer = 0;
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();

            // Smooth camera movement
            const cameraSpeed = 0.05;
            cameraX += (targetCameraX - cameraX) * cameraSpeed;

            // cameraX = canvas.width / 2 - player.x;
            cameraY = 0;
            clampCamera();
            ctx.translate(cameraX, cameraY);

            drawStoreBackground();
            const dynamicEntities = [...customers, { y: cashierCounter.y + cashierCounter.h, type: 'cashier-counter' }, ...shelves, player, stocker, cashier, barista, manager, salesperson];

            if (coffeeShopExists) {
                const { x, y, w: shopWidth, h: shopHeight } = coffeeShop.rect;

                const signYPos = y + shopHeight * 0.1;
                const signHeight = shopHeight * 0.17;
                const windowYPos = signYPos + signHeight + shopHeight * 0.03;
                const windowHeight = shopHeight * 0.4;
                const counterYPos = windowYPos + windowHeight + shopHeight * 0.03;
                const counterHeight = shopHeight * 0.04;
                const stoolYPos = counterYPos + counterHeight;
                const stoolHeight = shopHeight * 0.06;
                const legHeight = shopHeight * 0.04;

                // Background parts of the coffee shop
                dynamicEntities.push({
                    y: windowYPos + windowHeight, // Sort by the bottom of the window
                    draw: () => {
                        drawCoffeeSign(x, y, shopWidth, shopHeight);
                        drawCoffeeWindow(x, y, shopWidth, shopHeight);
                        if (unlocks.facilities.coffeeShop) {
                            drawEspressoMachine(x, y, shopWidth, shopHeight);
                        } else {
                            drawForRentSign(x, y, shopWidth, shopHeight);
                        }
                    }
                });

                // Foreground parts of the coffee shop
                if (unlocks.facilities.coffeeShop) {
                    dynamicEntities.push({
                        y: stoolYPos + stoolHeight + legHeight, // Sort by the bottom of the stools
                        draw: () => {
                            drawCoffeeCounter(x, y, shopWidth, shopHeight);
                            drawStools(x, y, shopWidth, shopHeight);
                        }
                    });
                }
            }

            dynamicEntities.sort((a, b) => (a.y || (a.rect ? a.rect.y + a.rect.h : 0)) - (b.y || (b.rect ? b.rect.y + b.rect.h : 0)));
            dynamicEntities.forEach(entity => {
                if (entity instanceof Customer) {
                    entity.draw();
                } else if (entity.draw) { // Handles shelves, coffee shop parts
                    entity.draw();
                } else if (entity === player) {
                    drawPlayer();
                } else if (entity === stocker) {
                    drawStocker();
                } else if (entity === cashier) {
                    drawCashier();
                } else if (entity === barista) {
                    drawBarista();
                } else if (entity === manager) {
                    drawManager();
                } else if (entity === salesperson) {
                    drawSalesperson();
                }
            });
            drawOfficeZones();
            drawPackages();
            updateAndDrawFloatingTexts(deltaTime);

            ctx.restore();

            drawStaticUI();
            drawPieClock();

            requestAnimationFrame(gameLoop);
        }

        async function spawnNewCustomer() {
            if (customers.length >= 7) return;
            const customerData = await generateCustomerRequest();
            if (customerData && customerData.requestedItems) {
                const newCustomer = new Customer(
                    customerProfiles[customerData.customerType][customerData.name], // Pass the profile object
                    customerData.name,
                    customerData.request,
                    customerData.requestedItems,
                    customerData.customerType
                );
                customers.push(newCustomer);
                generateAndLoadCustomerSprite(newCustomer);
                populateInStoreCustomers();
            }
        }

        function updateUI() {
            document.getElementById('cash-display').textContent = Math.round(cash);
            document.getElementById('day-display').textContent = day;
            document.getElementById('shop-points-display').textContent = shopPoints;
        }


        function logCustomerToSalesReport(customer, transactionDetails = {}) {
            dailySalesReport.push({
                name: customer.name,
                typeKey: customer.customerType,
                requestedItems: customer.requestedItems,
                purchasedItems: [...customer.order],
                waitTime: Math.round(customer.waitTimer),
                patienceChange: customer.profile.patience - customer.initialPatience,
                discount: customer.discount,
                boughtCoffee: customer.boughtCoffee,
                coffeeOrder: customer.coffeeOrder,
                helpedBySalesperson: customer.helpedBySalesperson,
                finalPrice: transactionDetails.finalPrice,
                commission: transactionDetails.commission
            });
        }

        function completeTransaction(customerId, isPlayerSale = false) {
            const customer = customers.find(c => c.id === customerId);
            if (!customer || customer.isServed) {
                console.warn("Attempted to complete transaction for non-existent/served customer:", customerId);
                return;
            }

            if (customer.order.length === 0) {
                logCustomerToSalesReport(customer);
                customer.leaving = true;
                customer.state = 'leaving';
                return;
            }

            let totalSellPrice = 0;
            customer.order.forEach(item => {
                totalSellPrice += items[item].sellPrice;
            });
            let salePrice = Math.ceil(totalSellPrice);

            // Apply discount if applicable
            if (customer.discount > 0) {
                salePrice = Math.ceil(salePrice * (1 - customer.discount));
            }

            // REFACTOR: Apply salesperson commission
            let commission = 0;
            if (customer.helpedBySalesperson) {
                commission = Math.ceil(salePrice * 0.10);
                salePrice -= commission;
            }

            customer.isServed = true;

            if (salePrice <= customer.budget) {
                cash += salePrice;
                if (isPlayerSale) {
                    shopPoints += customer.discount > 0 ? 1 : 3; // Player sale
                } else {
                    shopPoints += 1; // NPC sale
                }

                customer.leaving = true;
                customer.state = 'leaving';
                let saleText = customer.discount > 0 ? `+$${salePrice} (Discounted)` : `+$${salePrice}`;
                if (commission > 0) {
                    saleText += ` (-$${commission} comm.)`;
                }
                const saleOrigin = isPlayerSale ? player : cashier;
                spawnFloatingText(saleText, saleOrigin.x, saleOrigin.y - 80, '#22c55e');


                // Track popularity of sold items
                customer.order.forEach(item => {
                    itemPopularity[item] = (itemPopularity[item] || 0) + 1;
                });

            } else {
                customer.order.forEach(item => {
                    const shelfToReturn = shelves.find(s => s.items.some(i => i && i.assignedItem === item) || s.items.some(i => i.assignedItem === null));
                    if(shelfToReturn) {
                        let slot = shelfToReturn.items.find(i => i && i.assignedItem === item);
                        if(slot) slot.quantity++;
                        else {
                            const emptySlot = shelfToReturn.items.find(i => i.assignedItem === null);
                            if(emptySlot) {
                                emptySlot.assignedItem = item;
                                emptySlot.quantity = 1;
                            }
                        }
                    }
                });

                customer.leaving = true;
                customer.state = 'leaving';
                const saleOrigin = isPlayerSale ? player : cashier;
                spawnFloatingText('Too Expensive!', saleOrigin.x, saleOrigin.y - 80, '#ef4444');
            }
            logCustomerToSalesReport(customer, { finalPrice: salePrice, commission: commission });
            updateUI();
            populateInStoreCustomers();
            saveGame();
        }

        function endGame(reason) {
            running = false;
            const defaultMessage = `Game Over! You ran out of money. You survived for ${day} days and ended with $${Math.round(cash)}.`;
            showMessage(reason || defaultMessage, null);
        }

function openNewspaperModal() {
    if (!currentDailyMood) {
        console.warn("Tried to open newspaper, but no daily mood is set.");
        return;
    }

    const modal = document.getElementById('newspaper-modal');
    const hintBtn = document.getElementById('newspaper-hint-btn');
    const hintDisplay = document.getElementById('newspaper-hint-display');

    // The news is for the *upcoming* day
    document.getElementById('newspaper-day').textContent = day + 1;
    document.getElementById('newspaper-headline').textContent = currentDailyMood.headline;
    document.getElementById('newspaper-description').textContent = currentDailyMood.description;

    // Reset hint state every time the modal is opened
    hintDisplay.classList.add('hidden');
    hintBtn.classList.remove('hidden');

    modal.classList.remove('hidden');
}

function closeNewspaperModal() {
    const modal = document.getElementById('newspaper-modal');
    modal.classList.add('hidden');
}

function openManagerReportModal() {
    const modal = document.getElementById('manager-report-modal');
    const devButton = document.getElementById('manager-dev-report-btn');
    const trendsContent = document.getElementById('manager-trends-content');
    const trendsHeader = modal.querySelector('h3');

    trendsHeader.textContent = "Today's Buying Guide";

    if (developerMode) {
        devButton.classList.remove('hidden');
    } else {
        devButton.classList.add('hidden');
    }

    let recommendationsHtml = '';
    let dayEvent = null;

    // The forecast for the CURRENT day was set at the end of the PREVIOUS day.
    // marketForecast[0] is for day 2, marketForecast[1] for day 3, etc.
    // So for the current day `D`, we need the forecast from index `D-2`.
    if (day > 1 && marketForecast && marketForecast.length > 0) {
        const forecastIndex = (day - 2 + 7) % 7; // Safer modulo for JS
        dayEvent = marketForecast[forecastIndex];
    }

    if (dayEvent && dayEvent.recommendations && dayEvent.recommendations.length > 0) {
        recommendationsHtml = '<p class="mb-2">The manager suggests keeping an eye on these items, they are cheaper than usual today:</p>';
        recommendationsHtml += '<ul class="list-disc list-inside grid grid-cols-2 gap-x-4">';
        dayEvent.recommendations.forEach(item => {
            recommendationsHtml += `<li class="text-green-700 font-bold">${item}</li>`;
        });
        recommendationsHtml += '</ul>';
    } else {
        recommendationsHtml = '<p class="text-center p-4">The manager reports a stable market today. No special deals.</p>';
    }

    trendsContent.innerHTML = recommendationsHtml;

    modal.classList.remove('hidden');
}

function closeManagerReportModal() {
    const modal = document.getElementById('manager-report-modal');
    modal.classList.add('hidden');
}

function openDevReportModal() {
    const modal = document.getElementById('dev-report-modal');
    const contentDiv = document.getElementById('dev-report-content');
    contentDiv.innerHTML = ''; // Clear previous content

    if (!marketForecast || marketForecast.length === 0) {
        contentDiv.innerHTML = '<p class="text-center">No forecast data available. Is the market enabled?</p>';
        modal.classList.remove('hidden');
        return;
    }

    marketForecast.forEach((dayEvent, index) => {
        const dayContainer = document.createElement('div');
        dayContainer.className = 'mb-2 border border-amber-800/20 rounded-md';

        const dayButton = document.createElement('button');
        dayButton.className = 'w-full p-2 text-left font-bold bg-amber-200/50 hover:bg-amber-300/50 transition-colors flex justify-between items-center';
        dayButton.innerHTML = `<span>Day ${day + index + 1}</span><span class="font-sans text-xl">+</span>`;

        const detailsDiv = document.createElement('div');
        detailsDiv.className = 'p-3 border-t border-amber-800/20 hidden bg-white/30';

        let detailsHtml = '';
        if (dayEvent.type === 'dailyMood' && dayEvent.event) {
            detailsHtml += `<p><strong class="font-handwritten">Headline:</strong> ${dayEvent.event.headline}</p>`;
            detailsHtml += `<div class="mt-2"><strong class="font-handwritten">Effects:</strong>`;
            dayEvent.event.effects.forEach(effect => {
                const modifier = effect.modifier;
                const color = modifier > 0 ? 'text-red-600' : 'text-green-600';
                const sign = modifier > 0 ? '+' : '';
                const itemsAffected = Array.isArray(effect.items) ? `(${effect.items.join(', ')})` : `(All)`;
                detailsHtml += `<div class="pl-4 ${color}"><strong>${effect.category} ${itemsAffected}:</strong> ${sign}${(modifier * 100).toFixed(0)}%</div>`;
            });
            detailsHtml += `</div>`;
        } else if (dayEvent.type === 'categoryFocus' && dayEvent.changes) {
            detailsHtml += `<p><strong class="font-handwritten">Event Type:</strong> Category Focus</p>`;
            detailsHtml += `<div class="mt-2"><strong class="font-handwritten">Changes:</strong>`;
            dayEvent.changes.forEach(change => {
                 const modifier = change.modifier;
                 const color = modifier > 0 ? 'text-red-600' : 'text-green-600';
                 const sign = modifier > 0 ? '+' : '';
                detailsHtml += `<div class="pl-4 ${color}"><strong>${change.categoryLabel}:</strong> ${sign}${(modifier * 100).toFixed(0)}% - ${change.message}</div>`;
            });
            detailsHtml += `</div>`;
        } else if (dayEvent.type === 'classic' && dayEvent.fluctuations) {
            detailsHtml += `<p><strong class="font-handwritten">Event Type:</strong> Classic Fluctuation</p>`;
             detailsHtml += `<div class="mt-2"><strong class="font-handwritten">Fluctuations:</strong>`;
            Object.entries(dayEvent.fluctuations).forEach(([itemName, fluctuation]) => {
                const baseCost = originalItemCosts[itemName] || 1; // Avoid division by zero
                const percentChange = (fluctuation / baseCost) * 100;
                const color = percentChange > 0 ? 'text-red-600' : 'text-green-600';
                const sign = percentChange > 0 ? '+' : '';
                detailsHtml += `<div class="pl-4 ${color}"><strong>${itemName}:</strong> ${sign}${percentChange.toFixed(1)}%</div>`;
            });
            detailsHtml += `</div>`;
        } else {
             detailsHtml += `<p>No event data for this day.</p>`;
        }

        // Add the button to the HTML string
        detailsHtml += `<div class="mt-4 text-right"><button class="btn-style view-market-btn !px-2 !py-1 !text-sm" data-forecast-index="${index}">View Market on this Day</button></div>`;

        detailsDiv.innerHTML = detailsHtml;

        dayButton.addEventListener('click', () => {
            const isHidden = detailsDiv.classList.toggle('hidden');
            dayButton.querySelector('span:last-child').textContent = isHidden ? '+' : '-';
        });

        // Add listener for the new button
        const viewMarketBtn = detailsDiv.querySelector('.view-market-btn');
        if (viewMarketBtn) {
            viewMarketBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent the accordion from closing
                const forecastIndex = parseInt(e.target.dataset.forecastIndex, 10);
                // This function will be created in a later step
                openSimulatedMarketReport(forecastIndex);
            });
        }

        dayContainer.appendChild(dayButton);
        dayContainer.appendChild(detailsDiv);
        contentDiv.appendChild(dayContainer);
    });


    modal.classList.remove('hidden');
}

function closeDevReportModal() {
    const modal = document.getElementById('dev-report-modal');
    modal.classList.add('hidden');
}

function openSimulatedMarketReport(forecastIndex) {
    const modal = document.getElementById('simulated-market-report-modal');
    const contentDiv = document.getElementById('simulated-market-report-content');
    const title = document.getElementById('simulated-report-title');
    contentDiv.innerHTML = '';
    const targetDay = day + forecastIndex + 1;
    title.textContent = `Simulated Market Report for Day ${targetDay}`;

    // --- 1. Create deep copies to avoid modifying the live game state ---
    let simulatedPriceHistory = JSON.parse(JSON.stringify(priceHistory));
    let simulatedItems = JSON.parse(JSON.stringify(items));

    // --- 2. Loop through forecasts up to the target day to simulate price changes ---
    for (let i = 0; i <= forecastIndex; i++) {
        const dayEvent = marketForecast[i];
        if (!dayEvent) continue;

        let nextDayPrices = JSON.parse(JSON.stringify(simulatedItems));

        // --- Apply the same logic as the nextDay() function ---
        switch (dayEvent.type) {
            case 'classic':
                if (dayEvent.fluctuations) {
                    Object.keys(nextDayPrices).forEach(itemName => {
                        nextDayPrices[itemName].cost += dayEvent.fluctuations[itemName];
                    });
                }
                break;
            case 'dailyMood':
            case 'categoryFocus':
                // These types reset to base cost before applying modifiers
                Object.keys(nextDayPrices).forEach(key => {
                    if (originalItemCosts[key]) nextDayPrices[key].cost = originalItemCosts[key];
                });

                if (dayEvent.type === 'dailyMood' && dayEvent.event) {
                    dayEvent.event.effects.forEach(effect => {
                        let targetItems = [];
                        if (effect.category === "All") targetItems = Object.keys(items);
                        else {
                            const cat = storageCells.find(c => c.label === effect.category);
                            if (cat) targetItems = cat.allowedItems;
                        }
                        targetItems.forEach(itemName => {
                            if (effect.items === "all" || effect.items.includes(itemName)) {
                                nextDayPrices[itemName].cost *= (1 + effect.modifier);
                            }
                        });
                    });
                } else if (dayEvent.type === 'categoryFocus' && dayEvent.changes) {
                    dayEvent.changes.forEach(change => {
                        const cat = storageCells.find(c => c.label === change.categoryLabel);
                        if (cat) {
                            cat.allowedItems.forEach(itemName => {
                                nextDayPrices[itemName].cost *= (1 + change.modifier);
                            });
                        }
                    });
                }
                break;
        }

        // Clamp prices and round them
        Object.keys(nextDayPrices).forEach(itemName => {
            if (originalItemCosts[itemName]) {
                const baseCost = originalItemCosts[itemName];
                const minCost = baseCost * 0.25;
                const maxCost = baseCost * 1.75;
                nextDayPrices[itemName].cost = Math.max(minCost, Math.min(maxCost, nextDayPrices[itemName].cost));
            }
            nextDayPrices[itemName].cost = parseFloat(nextDayPrices[itemName].cost.toFixed(2));
        });

        // Update the main simulation object for the next iteration
        simulatedItems = nextDayPrices;

        // Update the history object for rendering
        Object.keys(simulatedPriceHistory).forEach(itemName => {
            simulatedPriceHistory[itemName].history.push(simulatedItems[itemName].cost);
            if (simulatedPriceHistory[itemName].history.length > 7) {
                simulatedPriceHistory[itemName].history.shift();
            }
        });
    }

    // --- 3. Render the report using the simulated data ---
    // This logic is copied from `openMarketPanel` but uses `simulatedPriceHistory`
    const allCategories = [...storageCells.map(cell => cell.label), "Coffee Supplies"];
    allCategories.forEach((categoryKey, index) => {
        if (categoryKey === "Coffee Supplies" && !unlocks.facilities.coffeeShop) return;

        const categoryButton = document.createElement('button');
        categoryButton.className = 'w-full p-2 bg-white/50 rounded-md border-2 border-amber-800/20 flex items-center space-x-4 text-left';

        const infoDiv = document.createElement('div');
        infoDiv.className = 'flex-grow';
        infoDiv.innerHTML = `<h3 class="font-handwritten text-xl">${categoryKey}</h3><div id="sim-percent-change-${index}" class="text-lg font-bold">--%</div>`;

        const canvasContainer = document.createElement('div');
        canvasContainer.className = 'w-32 h-16';
        const canvas = document.createElement('canvas');

        canvasContainer.appendChild(canvas);
        categoryButton.appendChild(infoDiv);
        categoryButton.appendChild(canvasContainer);
        contentDiv.appendChild(categoryButton);

        setTimeout(() => {
            const percentChange = drawMarketChart(canvas, categoryKey, simulatedPriceHistory);
            const percentDiv = document.getElementById(`sim-percent-change-${index}`);
            if (percentChange !== null && isFinite(percentChange)) {
                const sign = percentChange >= 0 ? '+' : '';
                const color = percentChange >= 0 ? 'text-green-600' : 'text-red-600';
                percentDiv.textContent = `${sign}${percentChange.toFixed(1)}%`;
                percentDiv.className = `text-lg font-bold ${color}`;
            } else {
                percentDiv.textContent = '...';
            }
        }, 0);
    });

    modal.classList.remove('hidden');
}

function closeSimulatedMarketReport() {
    const modal = document.getElementById('simulated-market-report-modal');
    modal.classList.add('hidden');
}

function toggleNewspaperModal() {
    const modal = document.getElementById('newspaper-modal');
    if (modal.classList.contains('hidden')) {
        openNewspaperModal();
    } else {
        closeNewspaperModal();
    }
}

function generateHintText() {
    if (!currentDailyMood || !currentDailyMood.effects) {
        return "No market effect information available.";
    }

    const hintParts = currentDailyMood.effects.map(effect => {
        const { category, modifier, items: affectedItems } = effect;
        const percentage = Math.abs(modifier * 100).toFixed(0);
        const priceText = modifier > 0 ? 'more expensive' : 'cheaper';
        const color = modifier > 0 ? 'text-red-600' : 'text-green-600';

        let itemLimiter = '';
        if (Array.isArray(affectedItems)) {
            itemLimiter = ` (${affectedItems.join(', ')} only)`;
        }

        return `<span class="font-bold ${color}">${category}${itemLimiter}: ${percentage}% ${priceText}</span>`;
    });

    return hintParts.join('<br>');
}

function showHint() {
    const hintDisplay = document.getElementById('newspaper-hint-display');
    const hintBtn = document.getElementById('newspaper-hint-btn');

    const hintText = generateHintText();
    hintDisplay.innerHTML = hintText;

    hintDisplay.classList.remove('hidden');
    hintBtn.classList.add('hidden');
}

        function applyClassicMarket() {
            Object.keys(items).forEach(itemName => {
                const baseCost = originalItemCosts[itemName];
                // Fluctuate price by up to +/- 10% of the base cost each day
                const fluctuation = (Math.random() - 0.5) * (baseCost * 0.2); // e.g. up to 20% swing
                let newCost = items[itemName].cost + fluctuation; // Apply to current price
                items[itemName].cost = parseFloat(newCost.toFixed(2));
            });
             spawnFloatingText("Market prices fluctuated overnight.", canvas.width / 2, 120, '#6b7280');
        }

        function applyDailyMoodMarket() {
            // Select a random headline from the new data structure
            currentDailyMood = dailyMoodHeadlines[Math.floor(Math.random() * dailyMoodHeadlines.length)];

            if (!currentDailyMood) return;

            // Apply each effect listed in the headline object
            currentDailyMood.effects.forEach(effect => {
                const { category, modifier, items: affectedItems } = effect;

                let targetItems = [];

                if (category === "All") {
                    targetItems = Object.keys(items);
                } else {
                    const storageCategory = storageCells.find(cell => cell.label === category);
                    if (storageCategory) {
                        targetItems = storageCategory.allowedItems;
                    }
                }

                targetItems.forEach(itemName => {
                    // Check if this specific item should be affected
                    if (affectedItems === "all" || affectedItems.includes(itemName)) {
                        const baseCost = items[itemName].cost;
                        items[itemName].cost = parseFloat((baseCost * (1 + modifier)).toFixed(2));
                    }
                });
            });


            // Display the headline to the player
            spawnFloatingText(currentDailyMood.headline, canvas.width / 2, 120, '#3b82f6');
        }

        function applyCategoryFocusMarket() {
            const modifiers = {
                "inDemand": { modifier: 0.25, message: "is in high demand! Prices are up." },
                "onSale": { modifier: -0.20, message: "is on sale! Prices are down." }
            };

            const categories = [...storageCells]; // Use your existing storageCells as categories
            let modifiedCategories = 0;
            const maxChanges = 2; // Change up to 2 categories per day

            // Shuffle categories to pick randomly
            categories.sort(() => 0.5 - Math.random());

            for (const category of categories) {
                if (modifiedCategories >= maxChanges) break;

                // Give a chance for nothing to happen to this category
                if (Math.random() > 0.6) continue;

                const modifierKeys = Object.keys(modifiers);
                const chosenModifierKey = modifierKeys[Math.floor(Math.random() * modifierKeys.length)];
                const chosenModifier = modifiers[chosenModifierKey];

                category.allowedItems.forEach(itemName => {
                    if (items[itemName]) {
                        const baseCost = items[itemName].cost;
                        items[itemName].cost = parseFloat((baseCost * (1 + chosenModifier.modifier)).toFixed(2));
                    }
                });

                // Announce the change for this category
                spawnFloatingText(`${category.label} ${chosenModifier.message}`, canvas.width / 2, 120 + (modifiedCategories * 30), '#f59e0b');
                modifiedCategories++;
            }

            if (modifiedCategories === 0) {
                spawnFloatingText("Market is stable today.", canvas.width / 2, 120, '#6b7280');
            }
        }

        function applyLiveSimulationMarket() {
            let priceChanges = 0;

            Object.keys(originalItemCosts).forEach(itemName => {
                const baseCost = originalItemCosts[itemName];

                // 1. Calculate Demand Factor (based on customer sales)
                const popularity = itemPopularity[itemName] || 0;
                // Formula: Each sale increases the next day's cost by 4%
                const demandFactor = 1 + (popularity * 0.04);

                // 2. Calculate Supply Factor (based on player purchases)
                const playerBuys = dailyPlayerPurchases[itemName] || 0;
                // Formula: Each item the player buys decreases the next day's cost by 1.5%
                const supplyFactor = 1 - (playerBuys * 0.015);

                // 3. Calculate New Cost
                // The new cost is based on the *previous day's* price, not the original base cost.
                let newCost = items[itemName].cost * demandFactor * supplyFactor;

                // 4. Clamp the price to prevent extreme swings
                const minCost = baseCost * 0.25; // Cannot go below 25% of base price
                const maxCost = baseCost * 1.75; // Cannot go above 175% of base price
                newCost = Math.max(minCost, Math.min(maxCost, newCost));

                // 5. Apply the new cost if it has changed
                if (items[itemName].cost !== newCost) {
                    priceChanges++;
                    items[itemName].cost = parseFloat(newCost.toFixed(2));
                }
            });

            if (priceChanges > 0) {
                spawnFloatingText("Market prices have adjusted based on yesterday's activity.", canvas.width / 2, 120, '#10b981');
            } else {
                spawnFloatingText("Market is stable today.", canvas.width / 2, 120, '#6b7280');
            }
        }

        function generatePredictions(priceArray) {
            if (priceArray.length < 2) {
                // Not enough data, return flat predictions
                const lastPrice = priceArray.length > 0 ? priceArray[priceArray.length - 1] : 10;
                return [lastPrice, lastPrice, lastPrice];
            }

            // Simple linear trend extrapolation
            const trend = priceArray[priceArray.length - 1] - priceArray[priceArray.length - 2];
            const predictions = [];
            let lastKnownPrice = priceArray[priceArray.length - 1];

            for (let i = 0; i < 3; i++) {
                let nextPrice = lastKnownPrice + trend * (i + 1);
                // Add some randomness to make it less predictable
                const randomness = (Math.random() - 0.5) * (lastKnownPrice * 0.1); // +/- 5% of last price
                nextPrice += randomness;
                // Ensure price doesn't go below a reasonable minimum
                nextPrice = Math.max(1, parseFloat(nextPrice.toFixed(2)));
                predictions.push(nextPrice);
            }
            return predictions;
        }


        function generateInitialMarketData() {
            priceHistory = {}; // Reset history
            Object.keys(items).forEach(itemName => {
                const baseCost = originalItemCosts[itemName];
                const history = [];
                let currentPrice = baseCost;

                // Generate 4 days of historical data
                for (let i = 0; i < 4; i++) {
                    // Fluctuate price by up to +/- 20% of the base cost
                    const fluctuation = (Math.random() - 0.5) * (baseCost * 0.4);
                    let newPrice = baseCost + fluctuation;

                    // Clamp the generated price to the 25%-175% range
                    const minCost = baseCost * 0.25;
                    const maxCost = baseCost * 1.75;
                    currentPrice = Math.max(minCost, Math.min(maxCost, newPrice));
                    currentPrice = parseFloat(currentPrice.toFixed(2));

                    history.push(currentPrice);
                }

                const predictions = generatePredictions(history);

                priceHistory[itemName] = {
                    history: history,
                    predictions: predictions
                };

                // The last historical price is "today's" price on day 1
                items[itemName].cost = history[history.length - 1];
            });
        }

        function toggleDoubleTime() {
            if (timeMultiplier > 1) {
                timeMultiplier = 1;
                document.getElementById('double-time-btn').classList.remove('bg-yellow-300');
            } else {
                timeMultiplier = 2;
                document.getElementById('double-time-btn').classList.add('bg-yellow-300');
            }
        }

        function nextDay() {
            if (!dayStarted) return;

            // Reset double time at the end of the day
            timeMultiplier = 1;
            document.getElementById('double-time-btn').classList.remove('bg-yellow-300');


            // Apply the market logic based on player's choice
            if (marketEnabled) {
                if (marketType === 'liveSimulation') {
                    applyLiveSimulationMarket();
                } else if (marketForecast && marketForecast.length > 0) {
                    const forecastIndex = (day - 1) % 7;
                    const dayEvent = marketForecast[forecastIndex];

                    if (dayEvent) {
                        switch (dayEvent.type) {
                            case 'classic':
                                if (dayEvent.fluctuations) {
                                    Object.keys(items).forEach(itemName => {
                                        // Classic fluctuates based on the previous day's price
                                        let newCost = items[itemName].cost + dayEvent.fluctuations[itemName];
                                        items[itemName].cost = parseFloat(newCost.toFixed(2));
                                    });
                                    spawnFloatingText("Market prices fluctuated overnight.", canvas.width / 2, 120, '#6b7280');
                                }
                                break;
                            case 'dailyMood':
                                // First, apply a minor random fluctuation to all items based on yesterday's price.
                                Object.keys(items).forEach(itemName => {
                                    const baseCost = originalItemCosts[itemName];
                                    if (baseCost) {
                                        const fluctuation = (Math.random() - 0.5) * (baseCost * 0.1); // +/- 5%
                                        items[itemName].cost += fluctuation;
                                    }
                                });
                                // Then, overwrite the price for event-specific items based on their original cost.
                                if (dayEvent.event) {
                                    currentDailyMood = dayEvent.event;
                                    currentDailyMood.effects.forEach(effect => {
                                        const { category, modifier, items: affectedItems } = effect;
                                        let targetItems = [];
                                        if (category === "All") {
                                            targetItems = Object.keys(items);
                                        } else {
                                            const storageCategory = storageCells.find(cell => cell.label === category);
                                            if (storageCategory) {
                                                targetItems = storageCategory.allowedItems;
                                            }
                                        }
                                        targetItems.forEach(itemName => {
                                            if (affectedItems === "all" || affectedItems.includes(itemName)) {
                                                const baseCost = originalItemCosts[itemName]; // Use original cost for event calculation
                                                if (baseCost) {
                                                    items[itemName].cost = parseFloat((baseCost * (1 + modifier)).toFixed(2));
                                                }
                                            }
                                        });
                                    });
                                    spawnFloatingText(currentDailyMood.headline, canvas.width / 2, 120, '#3b82f6');
                                }
                                break;
                            case 'categoryFocus':
                                // First, apply a minor random fluctuation to all items based on yesterday's price.
                                Object.keys(items).forEach(itemName => {
                                    const baseCost = originalItemCosts[itemName];
                                    if (baseCost) {
                                        const fluctuation = (Math.random() - 0.5) * (baseCost * 0.1); // +/- 5%
                                        items[itemName].cost += fluctuation;
                                    }
                                });
                                // Then, overwrite the price for event-specific categories based on their original cost.
                                if (dayEvent.changes && dayEvent.changes.length > 0) {
                                    dayEvent.changes.forEach((change, index) => {
                                        const category = storageCells.find(cell => cell.label === change.categoryLabel);
                                        if (category) {
                                            category.allowedItems.forEach(itemName => {
                                                if (items[itemName]) {
                                                    const baseCost = originalItemCosts[itemName]; // Use original cost for event calculation
                                                    if (baseCost) {
                                                        items[itemName].cost = parseFloat((baseCost * (1 + change.modifier)).toFixed(2));
                                                    }
                                                }
                                            });
                                            spawnFloatingText(`${change.categoryLabel} ${change.message}`, canvas.width / 2, 120 + (index * 30), '#f59e0b');
                                        }
                                    });
                                } else {
                                    spawnFloatingText("Market is stable today.", canvas.width / 2, 120, '#6b7280');
                                }
                                break;
                        }
                    }
                }
            } else {
                // If market is disabled, prices should reset to base.
                Object.keys(items).forEach(key => {
                    if (originalItemCosts[key]) {
                        items[key].cost = originalItemCosts[key];
                    }
                });
            }

            // --- Weekly Market Forecast Logic ---
            if (marketEnabled) {
                // On day 6, 13, 20, etc., generate the next week's forecast in advance.
                if (day > 0 && day % 7 === 6) {
                    nextMarketForecast = generateMarketForecast();
                     spawnFloatingText("Next week's market forecast generated.", canvas.width / 2, 150, '#9333ea');
                }
                // On day 7, 14, 21, etc., cycle the forecast for the week that's about to start.
                if (day > 0 && day % 7 === 0) {
                    marketForecast = [...nextMarketForecast];
                    nextMarketForecast = []; // It will be regenerated on the next Day 6.
                }
            }

            // Clamp all prices after any market logic has been applied
            Object.keys(items).forEach(itemName => {
                if (originalItemCosts[itemName]) {
                    const baseCost = originalItemCosts[itemName];
                    const minCost = baseCost * 0.25;
                    const maxCost = baseCost * 1.75;
                    items[itemName].cost = Math.max(minCost, Math.min(maxCost, items[itemName].cost));
                }
            });


            // 3. Update and record price history for the new day
            Object.keys(items).forEach(itemName => {
                if (!priceHistory[itemName] || !priceHistory[itemName].history) {
                     // This case handles loading a legacy save file.
                     // We'll create a new history for it.
                    priceHistory[itemName] = { history: [], predictions: [] };
                }

                // Add today's actual price to the history
                priceHistory[itemName].history.push(items[itemName].cost);

                // Keep the history to the last 7 days for the chart display
                if (priceHistory[itemName].history.length > 7) {
                    priceHistory[itemName].history.shift();
                }

                // Generate new predictions based on the updated history
                priceHistory[itemName].predictions = generatePredictions(priceHistory[itemName].history);
            });


            // 4. Reset daily trackers for the new day
            dailyPlayerPurchases = {};

            dayStarted = false;
            dayPhase = 'pre-open';
            dayShiftBreakTriggered = false;
            nightShiftBreakTriggered = false;
            manager.hasPlacedMorningOrder = false; // Reset for the next day

            // --- Daily & Weekly Expense Calculation ---
            let weeklyBillPaid = 0;

            // 1. Calculate and pay daily labor costs
            let dailyLaborCost = 0;
            dailyLaborCosts = {}; // Reset for the report
            dailyEmployeeWorkTimes = {}; // Reset for the report
            for (const employee in unlocks.employees) {
                if (unlocks.employees[employee]) {
                    const workTimeInMillis = employeeWorkTimers[employee] || 0;
                    dailyEmployeeWorkTimes[employee] = workTimeInMillis; // Store for report
                    const workTimeInSeconds = workTimeInMillis / 1000;
                    const payRatePerSecond = employeePayRates[employee] / 60;
                    const cost = Math.ceil(workTimeInSeconds * payRatePerSecond);
                    dailyLaborCosts[employee] = cost;
                    dailyLaborCost += cost;
                    employeeWorkTimers[employee] = 0; // Reset for next day
                }
            }
            cash -= dailyLaborCost; // Pay labor immediately
            currentWeeklyLaborCost += dailyLaborCost;

            // 2. Calculate and accrue daily rentable costs
            const dailyRent = dailyOperatingCosts.rent;
            const dailyCoffee = unlocks.facilities.coffeeShop ? dailyOperatingCosts.coffeeShop : 0;

            currentWeeklyRentCost += dailyRent;
            currentWeeklyCoffeeCost += dailyCoffee;

            let dailyAccruedAmount = dailyRent + dailyCoffee;
            currentWeeklyAccruedBill += dailyAccruedAmount;

            // 3. Handle End-of-Week Billing
            if (day > 0 && day % 7 === 0) {
                const unlockedStorageUnits = unlocks.storage.filter(unlocked => unlocked).length;
                const weeklyStorageCost = unlockedStorageUnits * dailyOperatingCosts.storageUnitWeeklyRate;
                currentWeeklyAccruedBill += weeklyStorageCost;
                currentWeeklyStorageCost = weeklyStorageCost; // For the report

                cash -= currentWeeklyAccruedBill;
                weeklyBillPaid = currentWeeklyAccruedBill;

                if (cash < 0 && !casualNoDebtPenalty) {
                    updateUI();
                    endGame(`Game Over! You couldn't pay your weekly bill of $${weeklyBillPaid.toFixed(2)} and ended with a debt of $${Math.abs(cash).toFixed(2)}.`);
                    return; // Exit here if game over
                }

                // Reset for the next week
                currentWeeklyAccruedBill = 0;
                currentWeeklyLaborCost = 0;
                currentWeeklyRentCost = 0;
                currentWeeklyStorageCost = 0;
                currentWeeklyCoffeeCost = 0;
            }

            const dailyTotalExpenses = dailyLaborCost + dailyAccruedAmount;

            customers.forEach(c => c.state = 'leaving');
            timeSinceLastCustomer = 0;

            updateUI();
            const reportPanel = document.getElementById('end-of-day-panel');
            const reportList = document.getElementById('report-view-customers');
            reportList.innerHTML = '';
            let grossSales = 0;
            const salesTally = {};
            const missedTally = {};
            dailySalesReport.forEach(report => {
                const reportDiv = document.createElement('div');
                reportDiv.className = 'text-sm p-2 border-b border-amber-800/20';
                const patienceColor = report.patienceChange < 0 ? 'text-red-600' : 'text-green-600';
                const patienceSign = report.patienceChange >= 0 ? '+' : '';
                let purchaseSummary = '<span class="text-red-600 font-bold">Left without buying</span>';
                if (report.purchasedItems.length > 0 && report.finalPrice !== undefined) {
                    const finalPrice = report.finalPrice || 0;
                    const commission = report.commission || 0;
                    const originalSalePrice = finalPrice + commission;

                    grossSales += originalSalePrice;

                    purchaseSummary = `${report.purchasedItems.join(', ')} ($${finalPrice.toFixed(2)} paid)`;
                     if (report.discount > 0) {
                        purchaseSummary += ` <span class="text-red-600 font-bold">(${report.discount * 100}% off)</span>`;
                    }
                    if (commission > 0) {
                        purchaseSummary += ` <span class="text-blue-600 font-bold">, $${commission.toFixed(2)} comm.</span>`;
                    }
                    report.purchasedItems.forEach(item => salesTally[item] = (salesTally[item] || 0) + 1);
                }
                const missedItems = report.requestedItems.filter(item => !report.purchasedItems.includes(item));
                missedItems.forEach(item => missedTally[item] = (missedTally[item] || 0) + 1);
                const coffeeIcon = report.boughtCoffee ? ' ☕' : '';
                reportDiv.innerHTML = `
            <div class="font-bold flex justify-between items-center">${report.name}${coffeeIcon}</div>
            <div>Purchased: <span class="font-handwritten">${purchaseSummary}</span></div>
            <div>Intended: <span class="font-handwritten">${report.requestedItems.join(', ')}</span></div>
            <div>Wait Time: <span class="font-handwritten">${report.waitTime}s</span> | Patience: <span class="font-handwritten ${patienceColor}">${patienceSign}${report.patienceChange}</span></div>
        `;
                reportList.appendChild(reportDiv);
            });
            const topSeller = Object.keys(salesTally).length ? Object.entries(salesTally).sort((a, b) => b[1] - a[1])[0][0] : 'None';
            const topMiss = Object.keys(missedTally).length ? Object.entries(missedTally).sort((a, b) => b[1] - a[1])[0][0] : 'None';
            const extraSummaryDiv = document.getElementById('report-summary-extra');
            extraSummaryDiv.innerHTML = `
        <p class="border-t border-amber-800/30 pt-2 mt-2">Top Seller: <span class="font-bold">${topSeller}</span></p>
        <p>Most Missed: <span class="font-bold">${topMiss}</span></p>
    `;
            document.getElementById('report-day').textContent = day;
            document.getElementById('report-sales').textContent = `$${grossSales.toFixed(2)}`;
            document.getElementById('report-expenses').textContent = `-$${dailyTotalExpenses.toFixed(2)}`;

            const weeklyReportDiv = document.getElementById('weekly-bill-report');
            weeklyReportDiv.innerHTML = ''; // Clear previous weekly report
            if (weeklyBillPaid > 0) {
                weeklyReportDiv.innerHTML = `
                    <p class="font-bold text-red-600">Weekly Bill Paid: -$${weeklyBillPaid.toFixed(2)}</p>
                `;
            }

            document.getElementById('report-profit').textContent = `$${(grossSales - dailyTotalExpenses).toFixed(2)}`;

            // --- START: POPULATE NEW REPORT VIEWS ---

            // 1. Populate Bills View
            const billsView = document.getElementById('report-view-bills');
            billsView.innerHTML = ''; // Clear previous content

            let billsHtml = `<div class="space-y-6">`;

            // Costs Paid Today section
            billsHtml += `<div><h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Costs Paid Today</h3>`;
            billsHtml += `<div class="space-y-1 text-lg">`;
            if (Object.keys(dailyLaborCosts).length > 0) {
                 for (const employee in dailyLaborCosts) {
                    const cost = dailyLaborCosts[employee];
                    const workTime = dailyEmployeeWorkTimes[employee] || 0;
                    const totalSeconds = Math.floor(workTime / 1000);
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    billsHtml += `<p class="flex justify-between text-base"><span>- ${employee.charAt(0).toUpperCase() + employee.slice(1)}'s Salary (${formattedTime}):</span> <span>-$${cost.toFixed(2)}</span></p>`;
                }
            } else {
                billsHtml += `<p class="text-base text-gray-500">No labor costs today.</p>`;
            }
            billsHtml += `</div></div>`;


            // Weekly Summary section
            billsHtml += `<div><h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Week-to-Date Summary</h3>`;
            billsHtml += `<div class="space-y-1 text-lg">`;
            billsHtml += `<p class="flex justify-between"><span>Total Labor Paid This Week:</span> <span>-$${currentWeeklyLaborCost.toFixed(2)}</span></p>`;
            billsHtml += `<p class="flex justify-between"><span>Total Accrued Bill (Due Day ${Math.ceil(day / 7) * 7}):</span> <span class="font-bold text-red-600">-$${currentWeeklyAccruedBill.toFixed(2)}</span></p>`;
            // Weekly Accrual Breakdown
            billsHtml += `<div class="pl-4 text-base border-l-2 border-amber-800/30 ml-2 space-y-1 my-1">`;
            billsHtml += `<p class="flex justify-between"><span>Rent:</span> <span>-$${currentWeeklyRentCost.toFixed(2)}</span></p>`;
            if (currentWeeklyStorageCost > 0) {
                billsHtml += `<p class="flex justify-between"><span>Storage Units:</span> <span>-$${currentWeeklyStorageCost.toFixed(2)}</span></p>`;
            }
            if (currentWeeklyCoffeeCost > 0) {
                billsHtml += `<p class="flex justify-between"><span>Coffee Shop:</span> <span>-$${currentWeeklyCoffeeCost.toFixed(2)}</span></p>`;
            }
            billsHtml += `</div>`;
            billsHtml += `</div></div>`;

            billsHtml += `</div>`;
            billsView.innerHTML = billsHtml;

            // 2. Populate Sales View
            const salesView = document.getElementById('report-view-sales');
            salesView.innerHTML = ''; // Clear previous content

            const requestedTally = {};
            dailySalesReport.forEach(report => {
                report.requestedItems.forEach(item => {
                    requestedTally[item] = (requestedTally[item] || 0) + 1;
                });
            });

            const orderedTally = {};
            dailySupplyOrders.forEach(order => {
                orderedTally[order.itemName] = (orderedTally[order.itemName] || 0) + order.quantity;
            });

            let salesHtml = `<div class="text-sm">`;
            salesHtml += `
                <div class="grid grid-cols-6 gap-2 font-bold border-b-2 border-amber-800/30 pb-1 mb-2 text-center">
                    <span class="text-left">Item</span>
                    <span>Start</span>
                    <span>Requested</span>
                    <span>Ordered</span>
                    <span>Sold</span>
                    <span>End</span>
                </div>
            `;

            const allTrackedItems = new Set();
            Object.keys(startingDayInventory).forEach(item => allTrackedItems.add(item));
            Object.keys(requestedTally).forEach(item => allTrackedItems.add(item));
            Object.keys(orderedTally).forEach(item => allTrackedItems.add(item));
            Object.keys(salesTally).forEach(item => allTrackedItems.add(item));

            const sortedItems = Array.from(allTrackedItems).sort();

            for (const itemName of sortedItems) {
                const startStock = startingDayInventory[itemName] || 0;
                const requested = requestedTally[itemName] || 0;
                const ordered = orderedTally[itemName] || 0;
                const sold = salesTally[itemName] || 0;
                const endStock = getTotalStock(itemName);

                if (startStock > 0 || requested > 0 || ordered > 0 || sold > 0) {
                    salesHtml += `
                        <div class="grid grid-cols-6 gap-2 py-1 border-b border-amber-800/10 text-center font-handwritten text-base">
                            <span class="text-left">${itemName}</span>
                            <span>${startStock}</span>
                            <span>${requested}</span>
                            <span>${ordered}</span>
                            <span>${sold}</span>
                            <span>${endStock}</span>
                        </div>
                    `;
                }
            }
            salesHtml += `</div>`;
            salesView.innerHTML = salesHtml;

            // 3. Populate Coffee View
            const coffeeView = document.getElementById('report-view-coffee');
            coffeeView.innerHTML = ''; // Clear previous content
            const coffeeSales = dailySalesReport.filter(r => r.coffeeOrder);
            let totalCoffeeRevenue = 0;
            const coffeeTally = {};
            let snackCount = 0;

            if (coffeeSales.length > 0) {
                let coffeeHtml = `<div class="space-y-4">`;
                coffeeSales.forEach(report => {
                    const order = report.coffeeOrder;
                    totalCoffeeRevenue += order.price;
                    coffeeTally[order.name] = (coffeeTally[order.name] || 0) + 1;
                    if (order.hasSnack) {
                        snackCount++;
                    }
                });

                coffeeHtml += `<div><h4 class="font-handwritten text-lg border-b border-amber-800/20 mb-2">Drinks Sold</h4>`;
                for (const coffeeName in coffeeTally) {
                    coffeeHtml += `<p class="flex justify-between"><span>${coffeeName}:</span> <span>x${coffeeTally[coffeeName]}</span></p>`;
                }
                coffeeHtml += `</div>`;

                if (snackCount > 0) {
                    coffeeHtml += `<div><h4 class="font-handwritten text-lg border-b border-amber-800/20 mb-2">Snacks Sold</h4>`;
                    coffeeHtml += `<p class="flex justify-between"><span>Snacks:</span> <span>x${snackCount}</span></p></div>`;
                }

                coffeeHtml += `
                    <div class="p-2 border-t-2 border-amber-800/30 flex justify-between items-center font-bold text-lg mt-4">
                        <span>Total Coffee Revenue:</span>
                        <span>$${totalCoffeeRevenue.toFixed(2)}</span>
                    </div>
                `;
                coffeeHtml += `</div>`;
                coffeeView.innerHTML = coffeeHtml;
            } else {
                coffeeView.innerHTML = `<p class="text-center p-4">No coffee was sold today.</p>`;
            }


            // --- END: POPULATE NEW REPORT VIEWS ---

            reportPanel.classList.remove('hidden');

            // --- Newspaper & Market Report Logic ---
            const eodNewspaperBtn = document.getElementById('eod-newspaper-btn');
            if (marketType === 'dailyMood' && currentDailyMood) {
                eodNewspaperBtn.classList.remove('hidden');
                openNewspaperModal();
            } else {
                eodNewspaperBtn.classList.add('hidden');
            }

            // Default to customer view
            document.getElementById('report-view-customers').classList.remove('hidden');
            document.getElementById('report-view-sales').classList.add('hidden');
            document.getElementById('report-view-coffee').classList.add('hidden');
            document.getElementById('report-view-bills').classList.add('hidden');
            document.getElementById('report-toggle-customers').classList.remove('bg-opacity-50');
            document.getElementById('report-toggle-sales').classList.add('bg-opacity-50');
            document.getElementById('report-toggle-coffee').classList.add('bg-opacity-50');
            document.getElementById('report-toggle-bills').classList.add('bg-opacity-50');

            // Handle Market toggle for the report button
            const marketReportButton = document.getElementById('report-toggle-market');
            marketReportButton.disabled = !marketEnabled;
            if (marketEnabled) {
                marketReportButton.textContent = 'Market';
            } else {
                marketReportButton.textContent = 'Market (Soon)';
            }

            // --- START: POPULATE MARKET REPORT VIEW ---
            const marketView = document.getElementById('report-view-market');
            if (marketEnabled && priceHistory) {
                let marketHtml = `<div class="space-y-4">`;

                // Add Market Style
                const styleName = marketType.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                marketHtml += `<div><h3 class="text-xl font-handwritten border-b-2 border-amber-800/30 mb-2">Market Style: ${styleName}</h3></div>`;

                // Function to get trend arrow and color
                const getTrend = (current, next) => {
                    if (next > current) return `<span class="text-red-500 font-bold">▲</span>`;
                    if (next < current) return `<span class="text-green-500 font-bold">▼</span>`;
                    return `<span class="text-gray-500 font-bold">▬</span>`;
                };

                const allCategories = [...storageCells, { label: "Coffee Supplies", allowedItems: ['Beans', 'Milks', 'Sugar', 'Snacks'] }];

                allCategories.forEach(category => {
                    // Skip empty or locked categories
                    if (!unlocks.storage[storageCells.indexOf(category)] && category.label !== "Coffee Supplies") return;
                    if (category.label === "Coffee Supplies" && !unlocks.facilities.coffeeShop) return;

                    marketHtml += `<div><h4 class="font-handwritten text-lg border-b border-amber-800/20 mb-2">${category.label}</h4>`;
                    marketHtml += `<div class="grid grid-cols-5 gap-x-2 text-sm text-center font-bold border-b border-amber-800/20 pb-1"><span class="text-left">Item</span><span>Today</span><span>+1 Day</span><span>+2 Days</span><span>+3 Days</span></div>`;
                    marketHtml += `<div class="space-y-1 mt-1">`;

                    category.allowedItems.forEach(itemName => {
                        const itemData = priceHistory[itemName];
                        if (itemData && itemData.predictions && itemData.predictions.length === 3) {
                            const todayPrice = itemData.history[itemData.history.length - 1];
                            const [pred1, pred2, pred3] = itemData.predictions;

                            marketHtml += `
                                <div class="grid grid-cols-5 gap-x-2 text-center items-center font-handwritten text-base">
                                    <span class="text-left">${itemName}</span>
                                    <span>$${todayPrice.toFixed(2)}</span>
                                    <span>${getTrend(todayPrice, pred1)} $${pred1.toFixed(2)}</span>
                                    <span>${getTrend(pred1, pred2)} $${pred2.toFixed(2)}</span>
                                    <span>${getTrend(pred2, pred3)} $${pred3.toFixed(2)}</span>
                                </div>
                            `;
                        }
                    });
                    marketHtml += `</div></div>`;
                });

                marketHtml += `</div>`;
                marketView.innerHTML = marketHtml;
            } else {
                marketView.innerHTML = `<p class="text-center p-4">The market is currently disabled.</p>`;
            }
            // --- END: POPULATE MARKET REPORT VIEW ---


            document.getElementById('next-day-report-btn').onclick = () => {
                day++;
                updateUI();
                for (const type in customerProfiles) {
                    for (const name in customerProfiles[type]) {
                        customerProfiles[type][name].visitedToday = false;
                    }
                }
                Object.keys(inventory).forEach(item => {
                    if (inventory[item] < 5) inventory[item] += 1;
                });
                saveGame();
                reportPanel.classList.add('hidden');
                dailySalesReport = [];
                if (continuousMode) {
                    document.getElementById('start-day-btn').click();
                } else {
                    document.getElementById('start-day-btn').classList.remove('hidden');
                }
            };
        }

        // --- LAYOUT INITIALIZATION ---
        // The following values determine the layout of the store.
        // This layout has been finalized and should not be changed.
        function initializeLayout() {
            officeWidth = canvas.width / 4;
            const storeShiftX = officeWidth;

            const cellWidth = canvas.width / 5;
            const cellHeight = ((desk.y - 250) / 2) * 0.8;
            const topPadding = 90;
            const cellPadding = 20;

            storageCells = [
                // Bottom Row
                { label: "Drawing", rect: { x: storeShiftX + cellPadding * 2, y: topPadding + cellHeight + 60, w: cellWidth, h: cellHeight }, allowedItems: ['Pencil', 'Charcoal', 'Markers', 'Sketchbook'], items: {}, capacity: 50 },
                { label: "Painting", rect: { x: storeShiftX + cellWidth + cellPadding * 3, y: topPadding + cellHeight + 60, w: cellWidth, h: cellHeight }, allowedItems: ['Water Color', 'Oils', 'Acrylics', 'Canvas'], items: {}, capacity: 50 },
                { label: "Models", rect: { x: storeShiftX + 2 * cellWidth + cellPadding * 4, y: topPadding + cellHeight + 60, w: cellWidth, h: cellHeight }, allowedItems: ['Razors', 'Glue', 'Mini Paints', 'Model Kits'], items: {}, capacity: 50 },
                // Top Row
                { label: "Woodworking", rect: { x: storeShiftX + cellPadding * 2, y: topPadding + 20, w: cellWidth, h: cellHeight }, allowedItems: ['Sanding Paper', 'Stainer', 'Wood Scraps', 'Lumber'], items: {}, capacity: 50 },
                { label: "Sculpture", rect: { x: storeShiftX + cellWidth + cellPadding * 3, y: topPadding + 20, w: cellWidth, h: cellHeight }, allowedItems: ['Clay', 'Pottery Paints', 'Stone', 'Marble'], items: {}, capacity: 50 },
                { label: "Architectural", rect: { x: storeShiftX + 2 * cellWidth + cellPadding * 4, y: topPadding + 20, w: cellWidth, h: cellHeight }, allowedItems: ['Pencil Lead', 'Vellum', 'Fancy Markers', 'Tiny Trees'], items: {}, capacity: 50 }
            ];

            // NEW COFFEE SHOP LOGIC
            if (coffeeShopExists) {
                const rightmostCell = storageCells[5];
                const coffeeShopHeight = (desk.y + desk.height) * 0.58; // Proportional height
                const coffeeShopWidth = coffeeShopHeight * (300 / 350);  // Maintain aspect ratio

                coffeeShop.rect.h = coffeeShopHeight;
                coffeeShop.rect.w = coffeeShopWidth;
                coffeeShop.rect.x = rightmostCell.rect.x + rightmostCell.rect.w + 40;
                coffeeShop.rect.y = (desk.y + desk.height) - coffeeShop.rect.h + 71;
                coffeeShop.y = coffeeShop.rect.y + coffeeShop.rect.h; // Set the sorting y-position

                // Define the zone behind the counter
                coffeeShop.behindCounterZone = {
                    x: coffeeShop.rect.x,
                    y: coffeeShop.rect.y,
                    w: coffeeShop.rect.w,
                    h: coffeeShop.rect.h * 0.75 // Area behind the counter
                };

                // Define the collision line for the counter
                const signY = coffeeShop.rect.y + coffeeShop.rect.h * 0.1;
                const signHeight = coffeeShop.rect.h * 0.17;
                const windowY = signY + signHeight + coffeeShop.rect.h * 0.03;
                const windowHeight = coffeeShop.rect.h * 0.4;
                coffeeShop.collisionLineY = windowY + windowHeight + coffeeShop.rect.h * 0.03;

                // Initialize the single coffee shop storage cell
                if (!coffeeShop.storage) { // Only initialize if it doesn't exist
                    const coffeeItems = ['Beans', 'Milks', 'Sugar', 'Snacks'];
                    const storageWidth = coffeeShop.rect.w * 0.8; // Make it thinner than the shop
                    const storageHeight = 60; // A fixed, thinner height
                    coffeeShop.storage = {
                        label: "Coffee Storage",
                        rect: {
                            x: coffeeShop.rect.x + (coffeeShop.rect.w - storageWidth) / 2, // Center it
                            y: coffeeShop.rect.y - storageHeight - 20, // Position above the shop
                            w: storageWidth,
                            h: storageHeight
                        },
                        allowedItems: coffeeItems,
                        items: coffeeItems.reduce((acc, item) => ({...acc, [item]: 0 }), {}),
                        capacity: 200 // 50 for each of the 4 items
                    };
                } else { // Just update position on resize
                    const storageWidth = coffeeShop.rect.w * 0.8;
                    const storageHeight = 60;
                    coffeeShop.storage.rect.w = storageWidth;
                    coffeeShop.storage.rect.h = storageHeight;
                    coffeeShop.storage.rect.x = coffeeShop.rect.x + (coffeeShop.rect.w - storageWidth) / 2;
                    coffeeShop.storage.rect.y = coffeeShop.rect.y - storageHeight - 20;
                }
            }


            cashierCounter.x = storeShiftX + 150;
            cashierCounter.y = (desk.y - cashierCounter.h) + 140;

            managersOffice.w = officeWidth;
            managersOffice.h = canvas.height / 2;
            managersOffice.x = 0;
            managersOffice.y = (canvas.height - managersOffice.h) / 2;

            // --- Office Zone Calculations ---
            const zoneSize = 80;
            const zonePadding = 20;

            // Zone 3 (Break Room) - Inside the office
            officeZone3.w = managersOffice.w * 0.7;
            officeZone3.h = managersOffice.h * 0.5;
            officeZone3.x = managersOffice.x + (managersOffice.w - officeZone3.w) / 2;
            officeZone3.y = managersOffice.y + (managersOffice.h - officeZone3.h) / 2 + 30; // Shift down a bit

            // Zone 1 & 2 (Desk & Waiting) - Below the office
            officeZone1.w = zoneSize;
            officeZone1.h = zoneSize;
            officeZone1.x = managersOffice.x + zonePadding;
            officeZone1.y = managersOffice.y + managersOffice.h + zonePadding;

            officeZone2.w = zoneSize;
            officeZone2.h = zoneSize;
            officeZone2.x = officeZone1.x + officeZone1.w + zonePadding;
            officeZone2.y = officeZone1.y;

            const shelfWidth = 60, shelfHeight = 120;
            const shelfY = desk.y - shelfHeight + 40;

            const numShelves = 6;
            const shelfPadding = 20;
            const totalShelvesWidth = (numShelves * shelfWidth) + ((numShelves - 1) * shelfPadding);
            const startX = storeShiftX + 250;
            if (shelves.length === 0) {
                for (let i = 0; i < numShelves; i++) {
                    const shelf = {
                        rect: { x: startX + i * (shelfWidth + shelfPadding), y: shelfY, w: shelfWidth, h: shelfHeight },
                        items: [
                            { assignedItem: null, quantity: 0 },
                            { assignedItem: null, quantity: 0 },
                            { assignedItem: null, quantity: 0 },
                            { assignedItem: null, quantity: 0 }
                        ],
                        y: shelfY + shelfHeight,
                        draw: drawShelf
                    };
                    shelves.push(shelf);
                }
            } else {
                 for (let i = 0; i < shelves.length; i++) {
                     shelves[i].rect.x = startX + i * (shelfWidth + shelfPadding);
                     shelves[i].rect.y = shelfY;
                     shelves[i].y = shelfY + shelfHeight;
                 }
            }
            const startY = cashierCounter.y + cashierCounter.h / 2;

            // --- Employee Idle Positions ---
            cashier.idleX = cashierCounter.x - 30;
            cashier.idleY = startY;
            if (cashier.state === 'idle' && !cashier.task) {
                cashier.x = cashier.idleX;
                cashier.y = cashier.idleY;
            }

            stocker.idleX = cashier.idleX - 40;
            stocker.idleY = startY;
            if (stocker.state === 'idle' && !stocker.task) {
                stocker.x = stocker.idleX;
                stocker.y = stocker.idleY;
            }

            manager.idleX = officeZone2.x + officeZone2.w / 2 - 20;
            manager.idleY = officeZone2.y + officeZone2.h / 2;
            if (manager.state === 'idle' && !manager.task) {
                manager.x = manager.idleX;
                manager.y = manager.idleY;
            }

            barista.idleX = coffeeShop.rect.x + (coffeeShop.rect.w / 4) + 42; // Move to the right
            barista.idleY = coffeeShop.rect.y + coffeeShop.rect.h + 5 - 42; // Move up
            if (barista.state === 'idle' && !barista.task) {
                barista.x = barista.idleX;
                barista.y = barista.idleY;
            }

            salesperson.idleX = storeShiftX + canvas.width - 100;
            salesperson.idleY = 400;
            if (salesperson.state === 'idle' && !salesperson.task) {
                salesperson.x = salesperson.idleX;
                salesperson.y = salesperson.idleY;
            }

            if (day === 1 && !dayStarted) {
                player.x = storeShiftX + 280;
                player.y = startY;
            }
        }

        // --- REFACTOR: Standalone Shelf Drawing Function ---
        function drawShelf() {
            const shelfIndex = shelves.indexOf(this);
             if (!unlocks.shelves[shelfIndex]) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
                drawLockIcon(this.rect.x + this.rect.w / 2 - 25, this.rect.y + this.rect.h / 2 - 25, 50, 50);
                return;
            }
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = 4;
            ctx.strokeRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, 10);
            ctx.strokeStyle = '#6d4c41';
            ctx.lineWidth = 2;
            const slotHeight = (this.rect.h - 10) / 4;
            ctx.beginPath();
            ctx.moveTo(this.rect.x, this.rect.y + 10 + slotHeight);
            ctx.lineTo(this.rect.x + this.rect.w, this.rect.y + 10 + slotHeight);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.rect.x, this.rect.y + 10 + slotHeight * 2);
            ctx.lineTo(this.rect.x + this.rect.w, this.rect.y + 10 + slotHeight * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.rect.x, this.rect.y + 10 + slotHeight * 3);
            ctx.lineTo(this.rect.x + this.rect.w, this.rect.y + 10 + slotHeight * 3);
            ctx.stroke();
            const itemWidth = this.rect.w - 20;
            const itemHeight = (this.rect.h - 40) / 4;
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i] && this.items[i].assignedItem) {
                    const item = this.items[i];
                    const stackX = this.rect.x + 10;
                    const stackY = this.rect.y + 15 + i * (itemHeight + 5);
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(stackX, stackY, itemWidth * (item.quantity / MAX_SHELF_STACK), itemHeight);
                    ctx.strokeStyle = '#5d4037';
                    ctx.strokeRect(stackX, stackY, itemWidth, itemHeight);
                    ctx.fillStyle = '#5d4037';
                    ctx.font = '12px "Patrick Hand", cursive';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(item.assignedItem.substring(0, 8), stackX + itemWidth / 2, stackY + itemHeight / 2);
                }
            }
        }


        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            desk.y = canvas.height - 220;

            initializeLayout();

            worldWidth = canvas.width + officeWidth;
            desk.width = worldWidth;
            loadingDock.y = canvas.height - loadingDock.height;
            loadingDock.x = officeWidth;
            loadingDock.width = canvas.width;
            cameraY = 0;

            if (cameraState === 'store') {
                 targetCameraX = -officeWidth;
                 cameraX = -officeWidth;
            } else {
                 targetCameraX = 0;
                 cameraX = 0;
            }
        }

        function clampCamera() {
            const worldWidth = canvas.width + officeWidth;
            const worldHeight = canvas.height;

            cameraX = Math.max(canvas.width - worldWidth, Math.min(0, cameraX));
            cameraY = Math.max(canvas.height - worldHeight, Math.min(0, cameraY));
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            const boxWidth = 70, boxHeight = 70;
            const boxX = canvas.width - boxWidth - 20, boxY = 20;


            // Check for static UI clicks FIRST, before transforming coordinates
            if (x >= boxX && x <= boxX + boxWidth && y >= boxY && y <= boxY + boxHeight) {
                 if (x >= phoneIcon.x && x <= phoneIcon.x + phoneIcon.width && y >= phoneIcon.y && y <= phoneIcon.y + phoneIcon.height) { openClipboardPanel(); }
                return;
            }

            // Convert to world coordinates for game object clicks
            const worldX = (x - cameraX);
            const worldY = (y - cameraY);

            // Check for clicks on packages in the loading dock
            if (worldY >= loadingDock.y) {
                if (Math.hypot(player.x - worldX, player.y - worldY) < 150) {
                    const packageLayout = getPackageLayout();
                    for (const layoutInfo of packageLayout) {
                        if (worldX > layoutInfo.x && worldX < layoutInfo.x + layoutInfo.w &&
                            worldY > layoutInfo.y && worldY < layoutInfo.y + layoutInfo.h) {
                            takeItemFromPackage(layoutInfo.originalIndex);
                            return; // Exit after handling one click
                        }
                    }
                }
            }

            // Check for click on the single coffee storage cell
            if (unlocks.facilities.coffeeShop && coffeeShop.storage) {
                const cell = coffeeShop.storage;
                const r = cell.rect;
                if (worldX >= r.x && worldX <= r.x + r.w && worldY >= r.y && worldY <= r.y + r.h) {
                    if (Math.hypot(player.x - (r.x + r.w / 2), player.y - (r.y + r.h)) < 150) {
                        openClipboardPanel();
                        openStorageCell(cell); // Use the generic storage panel
                        return;
                    }
                }
            }

            const clickedCell = storageCells.find(c => worldX >= c.rect.x && worldX <= c.rect.x + c.rect.w && worldY >= c.rect.y && worldY <= c.rect.y + c.rect.h);
            if (clickedCell) {
                const cellIndex = storageCells.indexOf(clickedCell);
                // Ensure the clicked cell is unlocked before proceeding
                if (unlocks.storage[cellIndex]) {
                    if (Math.hypot(player.x - (clickedCell.rect.x + clickedCell.rect.w/2), player.y - (clickedCell.rect.y + clickedCell.rect.h)) < 150) {
                        openClipboardPanel();
                        openStorageCell(clickedCell);
                        return;
                    }
                }
            }
            const clickedShelf = shelves.find(s => worldX >= s.rect.x && worldX <= s.rect.x + s.rect.w && worldY >= s.rect.y && worldY <= s.rect.y + s.rect.h);
            if (clickedShelf) {
                if (Math.hypot(player.x - (clickedShelf.rect.x + clickedShelf.rect.w/2), player.y - (clickedShelf.rect.y + clickedShelf.rect.h/2)) < 150) {
                    openClipboardPanel();
                    openShelfPanel(clickedShelf);
                    return;
                }
            }

            if (worldX >= officeComputer.x && worldX <= officeComputer.x + officeComputer.w &&
                worldY >= officeComputer.y && worldY <= officeComputer.y + officeComputer.h) {
                if (Math.hypot(player.x - (officeComputer.x + officeComputer.w / 2), player.y - (officeComputer.y + officeComputer.h / 2)) < 150) {
                    openClipboardPanel();
                    openMarketPanel();
                    return;
                }
            }

            // If no specific object was clicked, set the player's target destination.
            player.targetX = worldX;
            player.targetY = worldY;

        }

        function isPlayerInZone(zone) {
            return player.x > zone.x && player.x < zone.x + zone.w &&
                   player.y > zone.y && player.y < zone.y + zone.h;
        }

        function handleInteraction() {
            // Priority 0: Manager Interaction
            if (unlocks.employees.manager) {
                const distToManager = Math.hypot(player.x - manager.x, player.y - manager.y);
                if (distToManager < 150) {
                    openManagerReportModal();
                    return; // Interaction handled
                }
            }

            // Priority 1: Check out a customer if they are waiting and player is at the counter.
            const customerToCheckout = customers
                .filter(c => c.state === 'waitingAtCounter' && !c.isServed)
                .sort((a, b) => a.x - b.x)[0]; // Get the first person in line

            const playerAtCounter = Math.hypot(player.x - (cashierCounter.x - 30), player.y - (cashierCounter.y + cashierCounter.h / 2)) < 100;

            if (customerToCheckout && playerAtCounter) {
                completeTransaction(customerToCheckout.id, true);
                return; // Interaction handled, do nothing else.
            }

            // Find the closest customer the player can interact with
            const nearbyCustomer = customers.find(c =>
                !c.leaving &&
                c.state !== 'waitingAtCounter' &&
                c.state !== 'queuing' &&
                Math.hypot(player.x - c.x, player.y - c.y) < 150
            );

            if (!nearbyCustomer) {
                const nearbyShelf = shelves.find((shelf, index) =>
                    unlocks.shelves[index] &&
                    Math.hypot(player.x - (shelf.rect.x + shelf.rect.w / 2), player.y - (shelf.rect.y + shelf.rect.h / 2)) < 150
                );

                if (nearbyShelf) {
                    openClipboardPanel();
                    openShelfPanel(nearbyShelf);
                }
                return;
            }

            // --- New Interaction Logic for Waiting Customers (PRIORITY CHECK) ---
            if (nearbyCustomer.waitTimer > 60) { // Check for 60 seconds
                // Scenario A: Customer has items and has been waiting.
                if (nearbyCustomer.order.length > 0) {
                    nearbyCustomer.discount = 0.25; // Apply 25% discount
                    nearbyCustomer.state = 'queuing';
                    nearbyCustomer.request = "Alright, I'll take what you have for a discount.";
                    spawnFloatingText("Deal Made!", nearbyCustomer.x, nearbyCustomer.y - 90, '#3b82f6');
                    return;
                }
                // Scenario B: Customer has no items and has been waiting.
                else {
                    if (Math.random() < 0.5) {
                        // 50% chance: Buy a random in-stock item.
                        const allStockedItems = [];
                        shelves.forEach(shelf => {
                            shelf.items.forEach(slot => {
                                if (slot.assignedItem && slot.quantity > 0) {
                                    allStockedItems.push(slot.assignedItem);
                                }
                            });
                        });

                        if (allStockedItems.length > 0) {
                            const randomItem = allStockedItems[Math.floor(Math.random() * allStockedItems.length)];
                            nearbyCustomer.order.push(randomItem);
                            nearbyCustomer.profile.patience -= 10; // Small patience hit
                            nearbyCustomer.patience = nearbyCustomer.profile.patience; // Sync instance
                            nearbyCustomer.state = 'queuing';
                            nearbyCustomer.request = `Alright, I'll take a ${randomItem} then.`;
                            spawnFloatingText("Convinced!", nearbyCustomer.x, nearbyCustomer.y - 90, '#f59e0b');
                        } else {
                            // No items in stock, so they just leave.
                            nearbyCustomer.profile.patience -= 30; // Large patience hit
                            nearbyCustomer.patience = nearbyCustomer.profile.patience; // Sync instance
                            logCustomerToSalesReport(nearbyCustomer);
                            nearbyCustomer.state = 'leaving';
                            nearbyCustomer.request = "There's nothing here! I'm leaving.";
                            spawnFloatingText("Leaving Angry!", nearbyCustomer.x, nearbyCustomer.y - 90, '#ef4444');
                        }
                    } else {
                        // 50% chance: Leave the store.
                        nearbyCustomer.profile.patience -= 30; // Large patience hit
                        nearbyCustomer.patience = nearbyCustomer.profile.patience; // Sync instance
                        logCustomerToSalesReport(nearbyCustomer);
                        nearbyCustomer.state = 'leaving';
                        nearbyCustomer.request = "I've waited long enough. Goodbye.";
                        spawnFloatingText("Leaving Angry!", nearbyCustomer.x, nearbyCustomer.y - 90, '#ef4444');
                    }
                    return;
                }
            }

            // --- Original Interaction Logic ---
            if (nearbyCustomer.behaviorType === 'needsInteraction' && !nearbyCustomer.isInteractedWith) {
                nearbyCustomer.isInteractedWith = true;
                spawnFloatingText("Right this way!", player.x, player.y - 90, '#3b82f6');
                nearbyCustomer.showSpeechBubble = true;
                nearbyCustomer.speechBubbleTimer = 3000;
                return;
            }

            if (nearbyCustomer.behaviorType === 'needsAssistance' && !nearbyCustomer.needsAssistanceFulfilled) {
                const neededItems = nearbyCustomer.requestedItems.filter(item => !nearbyCustomer.order.includes(item));
                const playerBasketCounts = player.basket.reduce((acc, item) => { acc[item] = (acc[item] || 0) + 1; return acc; }, {});
                const neededItemsCounts = neededItems.reduce((acc, item) => { acc[item] = (acc[item] || 0) + 1; return acc; }, {});
                const canFulfill = Object.keys(neededItemsCounts).every(item => (playerBasketCounts[item] || 0) >= neededItemsCounts[item]);

                if (canFulfill && neededItems.length > 0) {
                    neededItems.forEach(item => {
                        const index = player.basket.indexOf(item);
                        player.basket.splice(index, 1);
                        nearbyCustomer.order.push(item);
                    });
                    updateBasketUI();

                    nearbyCustomer.waitTimer = 0; // Reset wait timer
                    nearbyCustomer.state = 'queuing';
                    nearbyCustomer.needsAssistanceFulfilled = true;
                    nearbyCustomer.request = `Oh, you have everything! Thanks! I'll go pay now.`;
                    nearbyCustomer.showSpeechBubble = true;
                    nearbyCustomer.speechBubbleTimer = 3000;
                    spawnFloatingText('Order Fulfilled!', player.x, player.y - 90, '#3b82f6');
                    return;
                }
            }

            // Default interaction: show speech bubble and maybe upsell
            if (nearbyCustomer.state === 'wandering' || nearbyCustomer.state === 'waitingForInteraction' || nearbyCustomer.state === 'waitingForAssistance') {
                if (nearbyCustomer.behaviorType === 'needsAssistance') {
                    const fullList = nearbyCustomer.requestedItems.join(', ');
                    nearbyCustomer.request = `I need: ${fullList}.`;
                } else {
                    const missingItem = nearbyCustomer.requestedItems[nearbyCustomer.currentItemIndex];
                    if (missingItem) {
                        nearbyCustomer.request = `I was really hoping to find some ${missingItem} today.`;
                    } else if (nearbyCustomer.behaviorType === 'needsInteraction') {
                        nearbyCustomer.request = "Hello? Could someone help me find something?";
                    }
                }
            }
            nearbyCustomer.showSpeechBubble = true;
            nearbyCustomer.speechBubbleTimer = 3000;

            if (Math.random() < 0.10 && nearbyCustomer.requestedItems.length < 4 && nearbyCustomer.behaviorType !== 'needsAssistance') {
                const allItems = Object.keys(items);
                const potentialItems = allItems.filter(i => !nearbyCustomer.requestedItems.includes(i));
                if (potentialItems.length > 0) {
                    const newItem = potentialItems[Math.floor(Math.random() * potentialItems.length)];
                    nearbyCustomer.requestedItems.push(newItem);
                    nearbyCustomer.request += ` and maybe a ${newItem}?`;
                    spawnFloatingText('Upsell!', player.x, player.y - 90, '#8b5cf6');
                }
            }
        }

        function populateAllCustomers() {
            const customerList = document.getElementById('all-customer-list');
            customerList.innerHTML = '';

            const unlockedTypeKeys = [];
            unlocks.storage.forEach((isUnlocked, index) => {
                if (isUnlocked) {
                    const typeKey = Object.keys(customerTypes).find(key => customerTypes[key].storageIndex === index);
                    if (typeKey && !unlockedTypeKeys.includes(typeKey)) {
                        unlockedTypeKeys.push(typeKey);
                    }
                }
            });

            unlockedTypeKeys.forEach(typeKey => {
                const typeInfo = customerTypes[typeKey];
                const profilesForType = customerProfiles[typeKey];

                const typeContainer = document.createElement('div');
                const typeHeader = document.createElement('h3');
                typeHeader.className = 'font-handwritten text-xl mt-4 px-1 border-b-2 border-amber-800/30 flex justify-between items-center cursor-pointer';
                typeHeader.innerHTML = `<span>${typeInfo.name}</span><span class="text-sm mr-2">[+]</span>`;

                const customerSubList = document.createElement('div');
                customerSubList.className = 'pl-2 hidden'; // Initially hidden

                typeContainer.appendChild(typeHeader);
                typeContainer.appendChild(customerSubList);
                customerList.appendChild(typeContainer);

                typeHeader.addEventListener('click', () => {
                    const isHidden = customerSubList.classList.toggle('hidden');
                    typeHeader.querySelector('span:last-child').textContent = isHidden ? '[+]' : '[-]';
                });

                if (!profilesForType) return;

                for (const name in profilesForType) {
                    const profile = profilesForType[name];
                    const customerDiv = document.createElement('div');
                    customerDiv.className = 'p-3 border-2 border-amber-800/50 rounded-lg bg-white/50 grid grid-cols-2 gap-x-4';

                    let visitedStatus = profile.visitedToday
                        ? '<span class="font-bold text-green-600">Visited</span>'
                        : '<span class="font-bold text-red-600">Not Visited</span>';

                    customerDiv.innerHTML = `
                        <div class="font-bold text-lg col-span-2">${name}</div>
                        <div>Patience: <span class="font-handwritten">${Math.round(profile.patience)}</span></div>
                        <div>Status: ${visitedStatus}</div>
                        <div class="col-span-2 mt-1">Tools: <span class="font-handwritten text-sm">${profile.toolsOwned.length > 0 ? profile.toolsOwned.join(', ') : 'None'}</span></div>
                    `;
                    customerSubList.appendChild(customerDiv);
                }
            });
        }

        function populateInStoreCustomers() {
            const customerList = document.getElementById('in-store-customer-list');
            customerList.innerHTML = '';

            const activeCustomers = customers.filter(c => !c.leaving);

            if (activeCustomers.length === 0) {
                customerList.innerHTML = `<p class="text-center p-4">No customers in the shop.</p>`;
                return;
            }

            activeCustomers.forEach(customer => {
                const customerButton = document.createElement('button');
                customerButton.id = `customer-in-store-${customer.id}`;
                customerButton.className = 'p-3 border-2 border-amber-800/50 rounded-lg bg-white/50 text-left hover:bg-amber-200/50 transition-colors w-full';
                customerButton.dataset.customerId = customer.id;

                let status = '';
                if (customer.waitTimer > 60) {
                    status = `<span class="font-bold text-yellow-600 animate-pulse">Needs Attention!</span>`;
                } else if (customer.state === 'waitingAtCounter') {
                    status = `<span class="font-bold text-green-600">Ready to Checkout</span>`;
                } else {
                    status = `<span class="text-gray-500">${customer.state}</span>`;
                }

                customerButton.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="font-bold text-lg">${customer.name}</div>
                        <div>${status}</div>
                    </div>
                    <div class="text-sm">Wait Time: ${Math.round(customer.waitTimer)}s</div>
                    <div class="text-xs mt-1">Looking for: <span class="font-handwritten">${customer.requestedItems.join(', ')}</span></div>
                `;

                customerButton.addEventListener('click', () => {
                    const targetCustomer = customers.find(c => c.id === customer.id);
                    if (targetCustomer) {
                        // When a customer is clicked, pan the camera to them
                        targetCameraX = -targetCustomer.x + canvas.width / 2;
                        closeClipboard();
                    }
                });
                customerList.appendChild(customerButton);
            });
        }

        function drawMarketChart(canvas, selectedKey, priceHistoryData = priceHistory) {
            if (!canvas.parentElement) return null;
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Data Aggregation ---
            let aggregatedHistory = [];
            const isArtCategory = storageCells.some(cell => cell.label === selectedKey);
            let itemsToAverage = [];

            if (isArtCategory) {
                const category = storageCells.find(cell => cell.label === selectedKey);
                itemsToAverage = category.allowedItems;
            } else if (selectedKey === "Coffee Supplies") {
                itemsToAverage = ['Beans', 'Milks', 'Sugar', 'Snacks'];
            }

            if (itemsToAverage.length > 0) { // Aggregate category data
                const firstItemHistory = priceHistoryData[itemsToAverage[0]]?.history;
                if (!firstItemHistory) return null;

                const historyLength = firstItemHistory.length;
                for (let i = 0; i < historyLength; i++) {
                    let sum = 0, count = 0;
                    itemsToAverage.forEach(item => {
                        if (priceHistoryData[item] && priceHistoryData[item].history[i] !== undefined) {
                            sum += priceHistoryData[item].history[i];
                            count++;
                        }
                    });
                    aggregatedHistory.push(count > 0 ? sum / count : 0);
                }
            } else { // Individual item data
                const itemData = priceHistoryData[selectedKey];
                if (itemData) {
                    aggregatedHistory = itemData.history || [];
                }
            }

            const historyData = aggregatedHistory;
            if (historyData.length < 2) return null; // Need at least 2 points to draw a line

            // --- Y-Axis Scaling ---
            let idealPrice = 0;
            if (itemsToAverage.length > 0) { // It's a category
                let sum = 0, count = 0;
                itemsToAverage.forEach(item => {
                    if (originalItemCosts[item] !== undefined) {
                        sum += originalItemCosts[item];
                        count++;
                    }
                });
                idealPrice = count > 0 ? sum / count : 0;
            } else { // It's an individual item
                idealPrice = originalItemCosts[selectedKey] || 0;
            }
            const maxVal = Math.max(...historyData, idealPrice);
            const minVal = Math.min(...historyData, idealPrice);
            const range = (maxVal - minVal === 0) ? 1 : (maxVal - minVal);

            // --- Percentage Change (Today vs. Ideal) ---
            const todayPrice = historyData[historyData.length - 1];
            const percentChange = idealPrice === 0 ? 0 : ((todayPrice - idealPrice) / idealPrice) * 100;


            // --- Drawing Setup ---
            const padding = { top: 5, right: 5, bottom: 20, left: 5 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;

            // --- X-Axis Labels ---
            const labels = [];
            for (let i = 0; i < historyData.length; i++) {
                const dayDiff = i - (historyData.length - 1);
                if (dayDiff === 0) {
                    labels.push("Today");
                } else {
                    labels.push(`${dayDiff}d`);
                }
            }
            ctx.font = '10px "VT323"';
            ctx.fillStyle = '#5d4037';
            ctx.textAlign = 'center';
            labels.forEach((label, index) => {
                if (historyData.length > 1) {
                    const x = padding.left + (index / (historyData.length - 1)) * chartWidth;
                    ctx.fillText(label, x, canvas.height - 5);
                }
            });

            // --- Historical Data (Solid Line) ---
            ctx.strokeStyle = percentChange > 0 ? '#ef4444' : '#22c55e'; // Red if > ideal, Green if <= ideal
            ctx.lineWidth = 2;
            ctx.beginPath();
            historyData.forEach((point, index) => {
                 if (historyData.length > 1) {
                    const x = padding.left + (index / (historyData.length - 1)) * chartWidth;
                    const y = padding.top + chartHeight - ((point - minVal) / range) * chartHeight;
                    if (index === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
            });
            ctx.stroke();

            // --- "Today's" Point ---
             if (historyData.length > 1) {
                const todayX = padding.left + chartWidth;
                const todayY = padding.top + chartHeight - ((todayPrice - minVal) / range) * chartHeight;
                ctx.fillStyle = '#5d4037';
                ctx.beginPath();
                ctx.arc(todayX, todayY, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // --- Baseline (Ideal Price) ---
            if (idealPrice > 0 && range > 0) {
                const baselineY = padding.top + chartHeight - ((idealPrice - minVal) / range) * chartHeight;
                ctx.strokeStyle = 'rgba(93, 64, 55, 0.4)'; // semi-transparent brown
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 3]);
                ctx.beginPath();
                ctx.moveTo(padding.left, baselineY);
                ctx.lineTo(padding.left + chartWidth, baselineY);
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
            }

            return percentChange;
        }

        function populateMarketItemDeepDivePanel(itemName) {
            const itemData = priceHistory[itemName];
            if (!itemData) { return; }

            const history = itemData.history;
            const baseCost = originalItemCosts[itemName];
            const currentPrice = items[itemName].cost;

            document.getElementById('market-deep-dive-title').textContent = itemName;
            document.getElementById('deep-dive-base-cost').textContent = `$${baseCost.toFixed(2)}`;
            document.getElementById('deep-dive-high').textContent = `$${Math.max(...history).toFixed(2)}`;
            document.getElementById('deep-dive-low').textContent = `$${Math.min(...history).toFixed(2)}`;
            document.getElementById('deep-dive-current-price').textContent = `$${currentPrice.toFixed(2)}`;

            const qtyInput = document.getElementById('deep-dive-order-qty');
            const orderBtn = document.getElementById('deep-dive-place-order-btn');
            qtyInput.value = 1;
            orderBtn.dataset.item = itemName;

            function updateOrderButtonText() {
                const quantity = parseInt(qtyInput.value, 10) || 0;
                const totalCost = (currentPrice * quantity);
                orderBtn.textContent = `Order for $${totalCost.toFixed(2)}`;
            }

            qtyInput.oninput = updateOrderButtonText;
            updateOrderButtonText();

            orderBtn.onclick = () => {
                const itemName = orderBtn.dataset.item;
                const quantity = parseInt(qtyInput.value, 10);
                const currentPrice = items[itemName].cost;
                const totalCost = currentPrice * quantity;
                if (isNaN(quantity) || quantity <= 0) { return; }

                if (cash >= totalCost) {
                    cash -= totalCost;
                    dailyPlayerPurchases[itemName] = (dailyPlayerPurchases[itemName] || 0) + quantity;
                    dailySupplyOrders.push({ orderedBy: 'Player', itemName: itemName, quantity: quantity, cost: totalCost });
                    let remainingQuantity = quantity;
                    while (remainingQuantity > 0) {
                        const quantityForPackage = Math.min(remainingQuantity, MAX_PACKAGE_SIZE);
                        loadingDockPackages.push({ itemName: itemName, quantity: quantityForPackage });
                        remainingQuantity -= quantityForPackage;
                    }
                    updateUI();
                    saveGame();
                    showMessage(`Ordered ${quantity} ${itemName} for $${totalCost.toFixed(2)}!`);
                    const itemCategoryKey = Object.keys(storageCells).find(key => storageCells[key].allowedItems.includes(itemName)) || "Coffee Supplies";
                    openMarketDetailPanel(itemCategoryKey);
                } else {
                    showMessage(`You can't afford this. You need $${totalCost.toFixed(2)}.`);
                }
            };

            document.getElementById('market-deep-dive-back-btn').onclick = () => {
                let itemCategoryKey = "Coffee Supplies";
                const foundCategory = storageCells.find(cell => cell.allowedItems.includes(itemName));
                if (foundCategory) { itemCategoryKey = foundCategory.label; }
                openMarketDetailPanel(itemCategoryKey);
            };

            const canvas = document.getElementById('market-deep-dive-canvas');
            drawDetailedMarketChart(canvas, itemName);
        }

        function openMarketItemDeepDivePanel(itemName) {
            phoneScreenContext = { itemName: itemName, panel: 'market-item-deep-dive-panel' };
            populateMarketItemDeepDivePanel(itemName);
            showScreen('market-item-deep-dive-panel');
        }

        function drawDetailedMarketChart(canvas, itemName) {
            if (!canvas || !canvas.parentElement) return;
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const itemData = priceHistory[itemName];
            if (!itemData || !itemData.history || itemData.history.length < 2) {
                ctx.font = '16px "Patrick Hand"';
                ctx.fillStyle = '#5d4037';
                ctx.textAlign = 'center';
                ctx.fillText("Not enough data for chart.", canvas.width / 2, canvas.height / 2);
                return;
            }

            const history = itemData.history;
            const predictions = itemData.predictions || [];
            const baseCost = originalItemCosts[itemName];
            const fullData = [...history, ...predictions];

            // --- Find high/low points from HISTORY ONLY ---
            const highPoint = { value: -1, index: -1 };
            const lowPoint = { value: Infinity, index: -1 };
            history.forEach((val, index) => {
                if (val > highPoint.value) {
                    highPoint.value = val;
                    highPoint.index = index;
                }
                if (val < lowPoint.value) {
                    lowPoint.value = val;
                    lowPoint.index = index;
                }
            });

            // --- Y-Axis Scaling (include base cost) ---
            const maxVal = Math.max(...fullData, baseCost);
            const minVal = Math.min(...fullData, baseCost);
            const range = (maxVal - minVal === 0) ? 1 : (maxVal - minVal);

            const padding = { top: 10, right: 10, bottom: 20, left: 30 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;

            // Helper to get coordinates
            const getCoords = (value, index) => {
                const x = padding.left + (index / (fullData.length - 1)) * chartWidth;
                const y = padding.top + chartHeight - ((value - minVal) / range) * chartHeight;
                return { x, y };
            };

            // --- Draw Y-Axis Labels ---
            ctx.font = '10px "VT323"';
            ctx.fillStyle = '#5d4037';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(`$${maxVal.toFixed(2)}`, padding.left - 4, padding.top);
            ctx.fillText(`$${minVal.toFixed(2)}`, padding.left - 4, padding.top + chartHeight);

            // --- Draw X-Axis Labels ---
            const labels = [];
            for (let i = 0; i < fullData.length; i++) {
                const dayDiff = i - (history.length - 1);
                if (dayDiff === 0) labels.push("Today");
                else if (dayDiff > 0) labels.push(`+${dayDiff}d`);
                else labels.push(`${dayDiff}d`);
            }
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            labels.forEach((label, index) => {
                const x = getCoords(0, index).x; // Only need x-coord
                ctx.fillText(label, x, canvas.height - padding.bottom + 4);
            });

            // --- Draw Baseline (Base Cost) ---
            const baselineY = getCoords(baseCost, 0).y; // Only need y-coord
            ctx.setLineDash([3, 4]);
            ctx.strokeStyle = 'rgba(93, 64, 55, 0.5)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, baselineY);
            ctx.lineTo(padding.left + chartWidth, baselineY);
            ctx.stroke();
            ctx.setLineDash([]); // Reset

            // --- Draw Historical Data (Solid Line) ---
            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;
            ctx.beginPath();
            history.forEach((point, index) => {
                const { x, y } = getCoords(point, index);
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

             // --- Draw Predicted Data (Dashed Line) ---
            if (predictions.length > 0) {
                ctx.setLineDash([4, 4]);
                ctx.strokeStyle = 'rgba(93, 64, 55, 0.6)';
                ctx.beginPath();
                const { x: startX, y: startY } = getCoords(history[history.length - 1], history.length - 1);
                ctx.moveTo(startX, startY);
                predictions.forEach((point, index) => {
                    const { x, y } = getCoords(point, history.length + index);
                    ctx.lineTo(x, y);
                });
                ctx.stroke();
                ctx.setLineDash([]); // Reset
            }

            // --- Draw Data Points ---
            fullData.forEach((point, index) => {
                const { x, y } = getCoords(point, index);
                ctx.fillStyle = (index < history.length) ? '#5d4037' : 'rgba(93, 64, 55, 0.6)';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // --- Draw High and Low Points ---
            if (highPoint.index !== -1) {
                const { x, y } = getCoords(highPoint.value, highPoint.index);
                ctx.fillStyle = '#ef4444'; // Red
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
            if (lowPoint.index !== -1) {
                const { x, y } = getCoords(lowPoint.value, lowPoint.index);
                ctx.fillStyle = '#22c55e'; // Green
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }

        function populateMarketDetailPanel(categoryKey) {
            const container = document.getElementById('market-items-container');
            const title = document.getElementById('market-detail-title');
            container.innerHTML = '';
            title.textContent = `${categoryKey}`;

            let itemsToList = [];
            if (categoryKey === "Coffee Supplies") {
                itemsToList = ['Beans', 'Milks', 'Sugar', 'Snacks'];
            } else {
                const category = storageCells.find(cell => cell.label === categoryKey);
                if (category) { itemsToList = category.allowedItems; }
            }

            itemsToList.forEach((itemName, index) => {
                const itemButton = document.createElement('button');
                itemButton.id = `market-item-${categoryKey.replace(/\s+/g, '-')}-${index}`;
                itemButton.className = 'w-full p-2 bg-white/50 rounded-md border-2 border-amber-800/20 flex items-center space-x-4 text-left hover:bg-amber-200/50 transition-colors';
                itemButton.addEventListener('click', () => openMarketItemDeepDivePanel(itemName));

                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex-grow';
                infoDiv.innerHTML = `
                    <h3 class="font-handwritten text-xl">${itemName} <span class="text-sm text-gray-500">($${originalItemCosts[itemName].toFixed(2)})</span></h3>
                    <div class="text-sm">Today: <span id="today-price-${itemName.replace(/\s+/g, '-')}" class="font-handwritten">$--.--</span></div>
                    <div class="text-sm">Yesterday: <span id="yesterday-price-${itemName.replace(/\s+/g, '-')}" class="font-handwritten">$--.--</span></div>
                `;

                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'w-32 h-16';
                const canvas = document.createElement('canvas');
                canvas.id = `market-chart-canvas-item-${itemName.replace(/\s+/g, '-')}`;

                canvasContainer.appendChild(canvas);
                itemButton.appendChild(infoDiv);
                itemButton.appendChild(canvasContainer);
                container.appendChild(itemButton);

                setTimeout(() => {
                    drawMarketChart(canvas, itemName);
                    const todayPriceSpan = document.getElementById(`today-price-${itemName.replace(/\s+/g, '-')}`);
                    const yesterdayPriceSpan = document.getElementById(`yesterday-price-${itemName.replace(/\s+/g, '-')}`);

                    const itemHistory = priceHistory[itemName]?.history;
                    if (itemHistory && itemHistory.length > 0) {
                        const todayPrice = itemHistory[itemHistory.length - 1];
                        const idealPrice = originalItemCosts[itemName];
                        if (idealPrice > 0) {
                            const color = todayPrice > idealPrice ? 'text-red-600' : 'text-green-600';
                            todayPriceSpan.className = `font-handwritten font-bold ${color}`;
                        }
                        todayPriceSpan.textContent = `$${todayPrice.toFixed(2)}`;
                        if (itemHistory.length > 1) {
                            yesterdayPriceSpan.textContent = `$${itemHistory[itemHistory.length - 2].toFixed(2)}`;
                        }
                    }
                }, 0);
            });

            const backBtn = document.getElementById('market-detail-back-btn');
            backBtn.onclick = () => { openMarketPanel(); };
        }

        function openMarketDetailPanel(categoryKey) {
            phoneScreenContext = { categoryKey: categoryKey, panel: 'market-detail-panel' };
            populateMarketDetailPanel(categoryKey);
            showScreen('market-detail-panel');
        }

        function populateMarketPanel() {
            const container = document.getElementById('market-categories-container');
            container.innerHTML = ''; // Clear previous reports

            const styleName = marketType.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
            let headerHtml = `<div class="flex justify-between items-center border-b-2 border-amber-800/30 mb-2">`;
            headerHtml += `<h3 class="text-xl font-handwritten">Market Style: ${styleName}</h3>`;
            if (marketType === 'dailyMood' && currentDailyMood) {
                headerHtml += `<button id="market-app-newspaper-btn" class="btn-style p-2" title="Read Today's News">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 20H5a2 2 0 01-2-2V6a2 2 0 012-2h10a2 2 0 012 2v1m2 13a2 2 0 01-2-2V7m2 13a2 2 0 002-2V9a2 2 0 00-2-2h-2m-4-3H9M7 16h6M7 12h6m-6-4h6" /></svg>
                </button>`;
            }
            headerHtml += `</div>`;
            container.innerHTML += headerHtml;

            const allCategories = [...storageCells.map(cell => cell.label), "Coffee Supplies"];
            allCategories.forEach((categoryKey, index) => {
                if (categoryKey === "Coffee Supplies" && !unlocks.facilities.coffeeShop) return;

                const categoryButton = document.createElement('button');
                categoryButton.id = `market-category-${index}`;
                categoryButton.className = 'w-full p-2 bg-white/50 rounded-md border-2 border-amber-800/20 flex items-center space-x-4 text-left hover:bg-amber-200/50 transition-colors';
                categoryButton.addEventListener('click', () => openMarketDetailPanel(categoryKey));

                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex-grow';
                infoDiv.innerHTML = `<h3 class="font-handwritten text-xl">${categoryKey}</h3><div id="percent-change-${index}" class="text-lg font-bold">--%</div>`;

                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'w-32 h-16';
                const canvas = document.createElement('canvas');
                canvas.id = `market-chart-canvas-${index}`;

                canvasContainer.appendChild(canvas);
                categoryButton.appendChild(infoDiv);
                categoryButton.appendChild(canvasContainer);
                container.appendChild(categoryButton);

                setTimeout(() => {
                    const percentChange = drawMarketChart(canvas, categoryKey);
                    const percentDiv = document.getElementById(`percent-change-${index}`);
                    if (percentChange !== null && isFinite(percentChange)) {
                        const sign = percentChange >= 0 ? '+' : '';
                        const color = percentChange >= 0 ? 'text-green-600' : 'text-red-600';
                        percentDiv.textContent = `${sign}${percentChange.toFixed(1)}%`;
                        percentDiv.className = `text-lg font-bold ${color}`;
                    } else {
                        percentDiv.textContent = '...';
                    }
                }, 0);
            });
        }

        function openMarketPanel() {
            populateMarketPanel();
            showScreen('market-panel');
        }

        function openCustomersPanel() {
            const inStoreBtn = document.getElementById('in-store-customers-btn');
            const allBtn = document.getElementById('all-customers-btn');
            const inStoreList = document.getElementById('in-store-customer-list');
            const allList = document.getElementById('all-customer-list');

            function showInStore() {
                inStoreList.classList.remove('hidden');
                allList.classList.add('hidden');
                inStoreBtn.classList.remove('bg-opacity-50');
                allBtn.classList.add('bg-opacity-50');
                populateInStoreCustomers();
            }

            function showAll() {
                inStoreList.classList.add('hidden');
                allList.classList.remove('hidden');
                allList.classList.add('flex'); // Make it a flex container
                inStoreBtn.classList.add('bg-opacity-50');
                allBtn.classList.remove('bg-opacity-50');
                populateAllCustomers();
            }

            inStoreBtn.onclick = showInStore;
            allBtn.onclick = showAll;

            showInStore();
            showAppScreen('customers-panel');
        }

        function openEmployeesPanel() {
            const employeeList = document.getElementById('employee-list');
            employeeList.innerHTML = '';

            const employees = { cashier, stocker, barista, manager, salesperson };
            const shiftOptions = [
                { label: 'Open', value: 'Opening' },
                { label: 'Day', value: 'Day Shift' },
                { label: 'Nite', value: 'Night Shift' },
                { label: 'Close', value: 'Closing' },
                { label: 'Off', value: 'Off' }
            ];

            let anyUnlocked = false;
            for (const empKey in unlocks.employees) {
                if (unlocks.employees[empKey]) {
                    anyUnlocked = true;
                    const employee = employees[empKey];
                    const empDiv = document.createElement('div');
                    empDiv.className = 'space-y-2 p-3 border-2 border-amber-800/50 rounded-lg bg-white/50 mb-2';

                    // Determine Status
                    let statusText = 'Off Duty';
                    const currentShiftPhase = dayPhase.replace('-', ' ');
                    if (employee.onBreak) {
                        statusText = '<span class="text-yellow-600">On Break</span>';
                    } else if (employee.shift.map(s => s.toLowerCase()).includes(currentShiftPhase.toLowerCase())) {
                        statusText = '<span class="text-green-600">Working</span>';
                    } else if (!employee.shift.includes('Off')) {
                        statusText = '<span class="text-gray-500">Waiting for Shift</span>';
                    }

                    empDiv.innerHTML = `
                        <div class="font-bold text-lg">${empKey.charAt(0).toUpperCase() + empKey.slice(1)}</div>

                        <!-- Shift Assignment -->
                        <div class="flex items-center">
                            <label class="text-sm mr-2">Shift:</label>
                            <div class="flex space-x-1 flex-wrap" data-emp-key="${empKey}">
                            </div>
                        </div>

                        <!-- Break Preference Toggle -->
                        <div class="flex items-center">
                             <label id="${empKey}-break-label" for="${empKey}-break-toggle" class="text-sm mr-2 w-16 cursor-pointer">Break:</label>
                            <div class="relative inline-block w-24 mr-2 align-middle select-none transition duration-200 ease-in text-center">
                                <input type="checkbox" name="${empKey}-break-toggle" id="${empKey}-break-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                <label for="${empKey}-break-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                <span class="absolute left-0 top-0.5 w-full text-xs font-bold text-amber-900/70" id="${empKey}-break-text">${employee.breakPreference === 'first' ? 'First' : 'Last'}</span>
                            </div>
                        </div>
                        <div class="text-sm text-center pt-2 border-t border-amber-800/20 mt-1">
                            Status: <span class="font-handwritten">${statusText}</span>
                        </div>
                    `;

                    const shiftButtonContainer = empDiv.querySelector(`div[data-emp-key="${empKey}"]`);
                    shiftOptions.forEach(opt => {
                        const isSelected = employee.shift.includes(opt.value);
                        const selectedClass = isSelected ? 'bg-green-700 !text-white' : 'bg-amber-700/60';
                        const button = document.createElement('button');
                        button.className = `shift-btn btn-style !px-2 !py-1 !text-sm ${selectedClass}`;
                        button.id = `set-shift-${empKey}-${opt.value.replace(/\s+/g, '-')}`;
                        button.dataset.shiftValue = opt.value;
                        button.title = opt.value;
                        button.textContent = opt.label;
                        shiftButtonContainer.appendChild(button);
                    });

                    employeeList.appendChild(empDiv);

                    // Add event listeners
                    shiftButtonContainer.addEventListener('click', (e) => {
                        if (e.target.classList.contains('shift-btn')) {
                            const newShift = e.target.dataset.shiftValue;
                            let currentShifts = employee.shift;

                            if (newShift === 'Off') {
                                employee.shift = ['Off'];
                            } else {
                                // If "Off" was the only shift, clear it before adding the new one.
                                if (currentShifts.length === 1 && currentShifts[0] === 'Off') {
                                    currentShifts = [];
                                }

                                const index = currentShifts.indexOf(newShift);
                                if (index > -1) {
                                    // Remove shift if it's already there
                                    currentShifts.splice(index, 1);
                                } else {
                                    // Add shift if it's not
                                    currentShifts.push(newShift);
                                }

                                // If no shifts are selected, default to "Off"
                                if (currentShifts.length === 0) {
                                    employee.shift = ['Off'];
                                } else {
                                    employee.shift = currentShifts;
                                }
                            }
                            openEmployeesPanel(); // Refresh
                            saveGame();
                        }
                    });

                    const breakToggle = empDiv.querySelector(`#${empKey}-break-toggle`);
                    const breakText = empDiv.querySelector(`#${empKey}-break-text`);
                    breakToggle.addEventListener('change', (e) => {
                        employee.breakPreference = e.target.checked ? 'last' : 'first';
                        breakText.textContent = e.target.checked ? 'Last' : 'First';
                        saveGame();
                    });

                    if (isMandatoryBreak && employee.onBreak) {
                        shiftButtonContainer.querySelectorAll('button').forEach(b => b.disabled = true);
                        breakToggle.disabled = true;
                    }
                }
            }

            if (!anyUnlocked) {
                employeeList.innerHTML = `<p class="text-center p-4">No employees hired yet.</p>`;
            }
            showAppScreen('employees-panel');
        }

        function openShelfAssignmentPanel() {
            const shelfAssignmentGrid = document.getElementById('shelf-assignment-grid');
            shelfAssignmentGrid.innerHTML = ''; // Clear existing buttons

            shelves.forEach((shelf, index) => {
                if (unlocks.shelves[index]) {
                    const shelfButton = document.createElement('button');
                    shelfButton.className = 'btn-style p-4';
                    shelfButton.id = `assign-shelf-${index}`;
                    shelfButton.textContent = `Shelf ${index + 1}`;
                    shelfButton.onclick = () => {
                        showShelfSlotsForAssignment(shelf);
                    };
                    shelfAssignmentGrid.appendChild(shelfButton);
                }
            });

            showAppScreen('shelf-assignment-panel');
        }


        function showShelfSlotsForAssignment(shelf) {
            const shelfAssignmentGrid = document.getElementById('shelf-assignment-grid');
            const shelfAssignmentTitle = document.getElementById('shelf-assignment-title');
            shelfAssignmentGrid.innerHTML = ''; // Clear shelf buttons
            shelfAssignmentTitle.textContent = `Assign to Shelf ${shelves.indexOf(shelf) + 1}`;

            // Add a back button
            const backButton = document.createElement('button');
            backButton.className = 'btn-style bg-amber-700/80 hover:bg-amber-600 col-span-2';
            backButton.id = 'back-to-shelves-btn';
            backButton.textContent = '← Back to Shelves';
            backButton.onclick = openShelfAssignmentPanel;
            shelfAssignmentGrid.appendChild(backButton);

            for (let i = 0; i < 4; i++) {
                const slot = shelf.items[i];
                const slotButton = document.createElement('button');
                slotButton.className = 'btn-style p-4';
                slotButton.id = `assign-shelf-${shelves.indexOf(shelf)}-slot-${i}`;
                let buttonText = `Slot ${i + 1}`;
                if (slot.assignedItem) {
                    buttonText += ` (${slot.assignedItem.substring(0,8)})`;
                } else {
                    buttonText += ` (Empty)`;
                }
                slotButton.textContent = buttonText;
                slotButton.onclick = () => {
                    openProductAssignmentForShelf(shelf, i);
                };
                shelfAssignmentGrid.appendChild(slotButton);
            }
             togglePanel('shelf-assignment', true);
        }



        function takeItemFromPackage(packageIndex) {
            if (player.basket.length >= MAX_BASKET_SIZE) {
                spawnFloatingText("Your basket is full!", player.x, player.y - 90, '#ef4444');
                return;
            }
            const pkg = loadingDockPackages[packageIndex];
            if (pkg && pkg.quantity > 0) {
                player.basket.push(pkg.itemName);
                pkg.quantity--;
                if (pkg.quantity <= 0) {
                    loadingDockPackages.splice(packageIndex, 1);
                }
                updateBasketUI();
            }
        }


        let currentRestockOrder = {};

        function getTotalStock(itemName) {
            let total = 0;
            // Check storage cells
            storageCells.forEach(cell => {
                if (cell.items && cell.items[itemName]) {
                    total += cell.items[itemName];
                }
            });
            // Check loading dock packages
            loadingDockPackages.forEach(pkg => {
                if (pkg.itemName === itemName) {
                    total += pkg.quantity;
                }
            });
            // Check shelves
            shelves.forEach(shelf => {
                shelf.items.forEach(slot => {
                    if (slot.assignedItem === itemName) {
                        total += slot.quantity;
                    }
                });
            });
            return total;
        }

        function getBackroomStock(itemName) {
            let total = 0;
            // Check storage cells
            storageCells.forEach(cell => {
                if (cell.items && cell.items[itemName]) {
                    total += cell.items[itemName];
                }
            });
            // Check loading dock packages
            loadingDockPackages.forEach(pkg => {
                if (pkg.itemName === itemName) {
                    total += pkg.quantity;
                }
            });
            return total;
        }

        function openClipboardPanel() {
            const clipboardPanel = document.getElementById('clipboard-panel');
            clipboardPanel.classList.add('open');
            isPhoneOpen = true;
            showAppGrid(); // Start at the home screen

            const appsGrid = document.getElementById('phone-apps-grid');
            if (appsGrid.children.length > 0) return; // Populate apps only once

            const apps = [
                { name: 'Order', icon: '📦', panelId: 'restock-panel', action: openRestockPanel },
                { name: 'Shelves', icon: '📚', panelId: 'shelf-assignment-panel', action: openShelfAssignmentPanel },
                { name: 'Items', icon: '💡', panelId: 'items-panel', action: openItemsPanel },
                { name: 'Employees', icon: '👥', panelId: 'employees-panel', action: openEmployeesPanel },
                { name: 'Customers', icon: '👤', panelId: 'customers-panel', action: openCustomersPanel },
                { name: 'Unlocks', icon: '🔑', panelId: 'unlocks-panel', action: openUnlocksPanel },
                { name: 'Market', icon: '📈', panelId: 'market-panel', action: openMarketPanel },
                { name: 'Settings', icon: '⚙️', panelId: 'settings-panel', action: () => showAppScreen('settings-panel') },
            ];

            apps.forEach(app => {
                const appButton = document.createElement('button');
                // Add a unique ID for companion mode tracking
                appButton.id = `app-btn-${app.name.toLowerCase()}`;
                appButton.className = 'flex flex-col items-center justify-center space-y-1 text-amber-900 hover:bg-amber-200/50 rounded-lg p-2 transition-colors';
                const iconDiv = document.createElement('div');
                iconDiv.className = 'text-4xl';
                iconDiv.innerHTML = app.icon; // Use innerHTML to render emoji
                const nameSpan = document.createElement('span');
                nameSpan.className = 'text-xs font-medium';
                nameSpan.textContent = app.name;
                appButton.appendChild(iconDiv);
                appButton.appendChild(nameSpan);
                appButton.onclick = () => {
                    // Prepare the panel's content first, then show it.
                    if(app.action) app.action();
                    // For simple panels without a dedicated open function, just show the screen.
                    else showAppScreen(app.panelId);
                };
                appsGrid.appendChild(appButton);
            });
        }
        function openRestockPanel() {
            const restockGrid = document.getElementById('restock-grid');
            restockGrid.innerHTML = '';
            updateRestockTotal();

            const coffeeItems = ['Beans', 'Milks', 'Sugar', 'Snacks'];

            // Helper function to render a list of items for ordering
            const renderOrderList = (title, itemsToRender, container, isInitiallyCollapsed = false) => {
                // MODIFICATION: No longer filtering by enabledItems. Show all unlocked items.
                const availableItems = itemsToRender;
                if (availableItems.length === 0) return;

                const sectionContainer = document.createElement('div');
                container.appendChild(sectionContainer);

                const sectionHeader = document.createElement('h3');
                sectionHeader.className = 'text-xl font-handwritten border-b-2 border-amber-800/30 mb-2 mt-4 flex justify-between items-center cursor-pointer';
                sectionHeader.innerHTML = `<span>${title}</span><span class="text-sm mr-2">[+]</span>`;
                sectionContainer.appendChild(sectionHeader);

                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'item-group-container'; // Add a class for easier selection
                sectionContainer.appendChild(itemsContainer);

                if (isInitiallyCollapsed) {
                    itemsContainer.classList.add('hidden');
                    sectionHeader.querySelector('span:last-child').textContent = '[+]';
                } else {
                    sectionHeader.querySelector('span:last-child').textContent = '[-]';
                }


                sectionHeader.addEventListener('click', () => {
                    const isHidden = itemsContainer.classList.toggle('hidden');
                    sectionHeader.querySelector('span:last-child').textContent = isHidden ? '[+]' : '[-]';
                });


                const headerRow = document.createElement('div');
                 headerRow.className = 'grid grid-cols-6 gap-x-2 border-b-2 border-amber-800/20 pb-2 text-lg font-handwritten';
                 headerRow.innerHTML = `
                    <span class="font-bold col-span-2">Item</span>
                    <span class="text-right font-bold">Stock</span>
                    <span class="col-span-3"></span> <!-- Header for buttons -->
                `;
                itemsContainer.appendChild(headerRow);

                for (const itemName of availableItems) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'grid grid-cols-6 gap-x-2 items-center py-2 border-b border-amber-800/10';
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'text-lg col-span-2';
                    nameSpan.textContent = itemName;

                    const stockSpan = document.createElement('span');
                    stockSpan.className = 'text-right text-lg';
                    stockSpan.textContent = getTotalStock(itemName);

                    const buttonContainer = document.createElement('div');
                    buttonContainer.className = 'flex space-x-1 col-span-3';

                    const orderButton = document.createElement('button');
                    orderButton.className = 'btn-style order-item-btn text-sm px-2 py-1';
                    orderButton.id = `order-item-${itemName.replace(/\s+/g, '-')}`;
                    orderButton.dataset.item = itemName;
                    orderButton.textContent = 'Order';

                    const buyOneButton = document.createElement('button');
                    buyOneButton.className = 'btn-style buy-now-one-btn text-sm px-2 py-1 bg-blue-600 hover:bg-blue-500';
                    buyOneButton.id = `buy-now-one-${itemName.replace(/\s+/g, '-')}`;
                    buyOneButton.dataset.item = itemName;
                    buyOneButton.textContent = 'Buy 1';

                    const buyFiveButton = document.createElement('button');
                    buyFiveButton.className = 'btn-style buy-now-btn text-sm px-2 py-1 bg-green-600 hover:bg-green-500';
                    buyFiveButton.id = `buy-now-five-${itemName.replace(/\s+/g, '-')}`;
                    buyFiveButton.dataset.item = itemName;
                    buyFiveButton.textContent = 'Buy 5';

                    buttonContainer.appendChild(orderButton);
                    buttonContainer.appendChild(buyOneButton);
                    buttonContainer.appendChild(buyFiveButton);

                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(stockSpan);
                    itemDiv.appendChild(buttonContainer);
                    itemsContainer.appendChild(itemDiv);
                }
            };

            // Conditionally render Coffee Supplies
            if (unlocks.facilities.coffeeShop) {
                renderOrderList('Coffee Supplies', coffeeItems, restockGrid);
            }

            // Render Art Supplies, grouped by storage category
            storageCells.forEach((cell, index) => {
                if (unlocks.storage[index]) {
                    // Filter out coffee items, just in case they overlap in the future
                    const artItemsForCell = cell.allowedItems.filter(item => !coffeeItems.includes(item));
                     if (artItemsForCell.length > 0) {
                        renderOrderList(cell.label, artItemsForCell, restockGrid, true); // Collapse by default
                    }
                }
            });


            // Check if any items were rendered at all
            if (restockGrid.children.length === 0) {
                 restockGrid.innerHTML = `<p class="text-center p-4">No items are available for ordering. Unlock more storage.</p>`;
            }

            // Attach event listeners to all generated buttons
            restockGrid.querySelectorAll('.order-item-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const itemName = e.target.dataset.item;
                    openOrderQuantityModal(itemName);
                });
            });

            restockGrid.querySelectorAll('.buy-now-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const itemName = e.target.dataset.item;
                    buyNow(itemName);
                });
            });

            restockGrid.querySelectorAll('.buy-now-one-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const itemName = e.target.dataset.item;
                    buyNowOne(itemName);
                });
            });

            showAppScreen('restock-panel');
        }

        function openOrderQuantityModal(itemName) {
            phoneScreenContext = { itemName: itemName }; // Store context
            const itemData = items[itemName];
            const restockPrice = itemData.cost;

            document.getElementById('order-quantity-item-name').textContent = itemName;
            document.getElementById('order-quantity-item-cost').textContent = `$${restockPrice.toFixed(2)}`;

            const quantityInput = document.getElementById('order-quantity-input');
            quantityInput.value = currentRestockOrder[itemName] || 0;
            quantityInput.dataset.item = itemName;

            showAppScreen('order-quantity-modal');
        }

        function purchaseUnlock(type, key) {
            let cost = 0;
            let prerequisite = true;

            if (type === 'employee') {
                cost = unlockCosts.employees[key];
            } else if (type === 'shelf') {
                key = parseInt(key);
                cost = unlockCosts.shelves[key];
                if (key > 0 && !unlocks.shelves[key - 1]) {
                    prerequisite = false;
                }
            } else if (type === 'facility') {
                cost = unlockCosts.facilities[key];
            } else if (type === 'storage') {
                key = parseInt(key);
                cost = unlockCosts.storage[key];
                // Prerequisite check removed to allow unlocking art styles in any order.
                // if (key > 0 && !unlocks.storage[key - 1]) {
                //     prerequisite = false;
                // }
            }

            if (developerMode) {
                cost = 0;
            }

            if (!prerequisite) {
                showMessage("You must unlock the previous tier first!");
                return;
            }

            if (shopPoints >= cost) {
                shopPoints -= cost;
                if (type === 'employee') {
                    unlocks.employees[key] = true;
                    initializeLayout(); // Recalculate layout for new employee positions
                } else if (type === 'shelf') {
                    unlocks.shelves[key] = true;
                    initializeLayout();
                } else if (type === 'facility') {
                    unlocks.facilities[key] = true;
                    initializeLayout();
                } else if (type === 'storage') {
                    unlocks.storage[key] = true;
                }

                spawnFloatingText('Unlocked!', player.x, player.y - 90, '#f59e0b');
                updateUI();
                saveGame();
                openUnlocksPanel(); // Refresh the panel
            } else {
                showMessage(`You need ${cost} points to unlock this.`);
            }
        }

        function openUnlocksPanel() {
            const empContainer = document.getElementById('unlocks-employees');
            const shelvesContainer = document.getElementById('unlocks-shelves');
            const storageContainer = document.getElementById('unlocks-storage');
            const facilitiesContainer = document.getElementById('unlocks-facilities');
            empContainer.innerHTML = '';
            shelvesContainer.innerHTML = '';
            storageContainer.innerHTML = '';
            facilitiesContainer.innerHTML = '';

            // Employees
            for (const emp in unlockCosts.employees) {
                const cost = developerMode ? 0 : unlockCosts.employees[emp];
                const isUnlocked = unlocks.employees[emp];
                const canAfford = shopPoints >= cost;
                let prerequisiteMet = true;
                let tooltipText = '';

                if (emp === 'barista' && !unlocks.facilities.coffeeShop) {
                    prerequisiteMet = false;
                    tooltipText = 'Requires Coffee Shop';
                }

                const container = document.createElement('div');
                container.className = 'flex items-center justify-between p-2 bg-white/50 rounded-md';

                const textDiv = document.createElement('div');
                textDiv.innerHTML = `
                    <span class="text-lg">${emp.charAt(0).toUpperCase() + emp.slice(1)}</span>
                    <span class="text-sm text-amber-800/80 block">Cost: ${cost} Points</span>
                `;

                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'relative item-tooltip';

                const button = document.createElement('button');
                button.className = 'btn-style px-4 py-1';
                button.id = `unlock-employee-${emp}`;
                button.dataset.type = 'employee';
                button.dataset.key = emp;
                button.disabled = isUnlocked || !canAfford || !prerequisiteMet;
                button.textContent = isUnlocked ? 'Unlocked' : 'Buy';

                buttonContainer.appendChild(button);

                if (tooltipText) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip -top-8 left-1/2 -translate-x-1/2';
                    tooltip.textContent = tooltipText;
                    buttonContainer.appendChild(tooltip);
                }

                container.appendChild(textDiv);
                container.appendChild(buttonContainer);
                empContainer.appendChild(container);
            }


            // Shelves
            for (let i = 1; i < unlockCosts.shelves.length; i++) {
                const cost = developerMode ? 0 : unlockCosts.shelves[i];
                const isUnlocked = unlocks.shelves[i];
                const canAfford = shopPoints >= cost;
                const prerequisiteMet = unlocks.shelves[i - 1];
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 bg-white/50 rounded-md';
                const textDiv = document.createElement('div');
                textDiv.innerHTML = `
                    <span class="text-lg">Shelf ${i + 1}</span>
                    <span class="text-sm text-amber-800/80 block">Cost: ${cost} Points</span>
                `;
                const button = document.createElement('button');
                button.className = 'btn-style px-4 py-1';
                button.id = `unlock-shelf-${i}`;
                button.dataset.type = 'shelf';
                button.dataset.key = i;
                button.disabled = isUnlocked || !prerequisiteMet || !canAfford;
                button.textContent = isUnlocked ? 'Unlocked' : (prerequisiteMet ? 'Buy' : 'Locked');

                div.appendChild(textDiv);
                div.appendChild(button);
                shelvesContainer.appendChild(div);
            }

            // Facilities (Coffee Shop)
            const coffeeShopCost = developerMode ? 0 : unlockCosts.facilities.coffeeShop;
            const isCoffeeShopUnlocked = unlocks.facilities.coffeeShop;
            const canAffordCoffeeShop = shopPoints >= coffeeShopCost;
            const coffeeDiv = document.createElement('div');
            coffeeDiv.className = 'flex items-center justify-between p-2 bg-white/50 rounded-md';
            const coffeeTextDiv = document.createElement('div');
            coffeeTextDiv.innerHTML = `
                <span class="text-lg">Coffee Shop</span>
                <span class="text-sm text-amber-800/80 block">Cost: ${coffeeShopCost} Points</span>
            `;
            const coffeeButton = document.createElement('button');
            coffeeButton.className = 'btn-style px-4 py-1';
            coffeeButton.id = 'unlock-facility-coffeeShop';
            coffeeButton.dataset.type = 'facility';
            coffeeButton.dataset.key = 'coffeeShop';
            coffeeButton.disabled = isCoffeeShopUnlocked || !canAffordCoffeeShop;
            coffeeButton.textContent = isCoffeeShopUnlocked ? 'Unlocked' : 'Buy';

            coffeeDiv.appendChild(coffeeTextDiv);
            coffeeDiv.appendChild(coffeeButton);
            facilitiesContainer.appendChild(coffeeDiv);


            // Storage
            for (let i = 0; i < unlockCosts.storage.length; i++) {
                const cost = developerMode ? 0 : unlockCosts.storage[i];
                const isUnlocked = unlocks.storage[i];
                const canAfford = shopPoints >= cost;
                // Prerequisite check for storage (art styles) has been removed.
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 bg-white/50 rounded-md';
                const textDiv = document.createElement('div');
                textDiv.innerHTML = `
                    <span class="text-lg">${storageCells[i].label} Storage</span>
                    <span class="text-sm text-amber-800/80 block">Cost: ${cost} Points</span>
                `;
                const button = document.createElement('button');
                button.className = 'btn-style px-4 py-1';
                button.id = `unlock-storage-${i}`;
                button.dataset.type = 'storage';
                button.dataset.key = i;
                button.disabled = isUnlocked || !canAfford;
                button.textContent = isUnlocked ? 'Unlocked' : 'Buy';

                div.appendChild(textDiv);
                div.appendChild(button);
                storageContainer.appendChild(div);
            }

            document.getElementById('unlocks-panel').querySelectorAll('button[data-type]').forEach(button => {
                button.addEventListener('click', (e) => {
                    const type = e.currentTarget.dataset.type;
                    const key = e.currentTarget.dataset.key;
                    purchaseUnlock(type, key);
                });
            });
            showAppScreen('unlocks-panel');
        }


        function updateRestockTotal() {
            let total = 0;
            for (const itemName in currentRestockOrder) {
                const quantity = currentRestockOrder[itemName];
                const itemData = items[itemName];
                const restockPrice = itemData.cost;
                total += restockPrice * quantity;
            }
            document.getElementById('restock-total').textContent = total.toFixed(2);
        }

        function buyNow(itemName) {
            const quantity = 5;
            const itemData = items[itemName];
            const restockPrice = itemData.cost;
            const totalCost = restockPrice * quantity;

            const packagesFromOrder = Math.ceil(quantity / MAX_PACKAGE_SIZE);

            if (cash >= totalCost) {
                cash -= totalCost;
                loadingDockPackages.push({ itemName: itemName, quantity: quantity });
                dailyPlayerPurchases[itemName] = (dailyPlayerPurchases[itemName] || 0) + quantity;
                updateUI();
                saveGame();
                spawnFloatingText(`Bought 5 ${itemName}!`, player.x, player.y - 90, '#3b82f6');
            } else {
                showMessage(`You can't afford to buy 5 of ${itemName}! You need $${totalCost.toFixed(2)}.`);
            }
        }

        function buyNowOne(itemName) {
            const quantity = 1;
            const itemData = items[itemName];
            const restockPrice = itemData.cost;
            const totalCost = restockPrice * quantity;

            const packagesFromOrder = Math.ceil(quantity / MAX_PACKAGE_SIZE);

            if (cash >= totalCost) {
                cash -= totalCost;
                loadingDockPackages.push({ itemName: itemName, quantity: quantity });
                dailyPlayerPurchases[itemName] = (dailyPlayerPurchases[itemName] || 0) + quantity;
                updateUI();
                saveGame();
                spawnFloatingText(`Bought 1 ${itemName}!`, player.x, player.y - 90, '#3b82f6');
            } else {
                showMessage(`You can't afford to buy 1 of ${itemName}! You need $${totalCost.toFixed(2)}.`);
            }
        }

        function placeOrder() {
            const orderSource = currentRestockOrder;

            let totalCost = 0;
            let itemsToOrder = 0;
            let packagesFromOrder = 0;

            for (const itemName in orderSource) {
                const quantity = orderSource[itemName];
                if (quantity > 0) {
                    const itemData = items[itemName];
                    const restockPrice = itemData.cost;
                    totalCost += restockPrice * quantity;
                    itemsToOrder++;
                    packagesFromOrder += Math.ceil(quantity / MAX_PACKAGE_SIZE);
                }
            }

            if (itemsToOrder === 0) {
                showMessage("Your order is empty.");
                return;
            }


            if (cash >= totalCost) {
                cash -= totalCost;
                for (const itemName in orderSource) {
                    let quantityToOrder = orderSource[itemName];
                    if (quantityToOrder > 0) {
                        dailyPlayerPurchases[itemName] = (dailyPlayerPurchases[itemName] || 0) + quantityToOrder;
                        const itemData = items[itemName];
                        const restockPrice = itemData.cost;
                        dailySupplyOrders.push({
                            orderedBy: 'Player',
                            itemName: itemName,
                            quantity: quantityToOrder,
                            cost: restockPrice * quantityToOrder
                        });

                        while (quantityToOrder > 0) {
                            const quantityForPackage = Math.min(quantityToOrder, MAX_PACKAGE_SIZE);
                            loadingDockPackages.push({itemName: itemName, quantity: quantityForPackage});
                            quantityToOrder -= quantityForPackage;
                        }
                    }
                }
                currentRestockOrder = {};
                updateUI();
                saveGame();
                // closeClipboard(); // <-- REMOVED to keep phone open
                showMessage(`Order placed for $${totalCost.toFixed(2)}! The supplies have been delivered to the loading dock.`);
                openRestockPanel(); // Refresh the restock panel
            } else {
                showMessage(`You can't afford this order! You need $${totalCost.toFixed(2)} but only have $${cash.toFixed(2)}.`);
            }
        }

        function stockAllRelevantToStorage(cell) {
            const itemsToMove = player.basket.filter(item => cell.allowedItems.includes(item));
            if (itemsToMove.length === 0) return;

            const currentFill = Object.values(cell.items).reduce((a, b) => a + b, 0);
            const capacity = cell.capacity;
            const availableSpace = capacity - currentFill;

            if (itemsToMove.length > availableSpace) {
                showMessage(`Not enough space in ${cell.label} storage. Needs space for ${itemsToMove.length} items, but only has ${availableSpace}.`);
                return;
            }

            const newBasket = player.basket.filter(item => !cell.allowedItems.includes(item));
            itemsToMove.forEach(item => {
                cell.items[item] = (cell.items[item] || 0) + 1;
            });

            player.basket = newBasket;
            updateBasketUI();
            spawnFloatingText(`Stocked ${itemsToMove.length} items!`, player.x, player.y - 90, '#22c55e');
            saveGame();
            openStorageCell(cell); // Refresh the panel
        }

        function openStorageCell(cell) {
            phoneScreenContext = { cellLabel: cell.label }; // Store context
            activeStorageCell = cell;
            const storageGrid = document.getElementById('storage-grid');
            document.getElementById('storage-title').textContent = cell.label;
            storageGrid.innerHTML = '';

            const stockAllButtonContainer = document.createElement('div');
            stockAllButtonContainer.className = 'p-2 col-span-2'; // Span across grid
            const stockAllButton = document.createElement('button');
            stockAllButton.className = 'btn-style w-full py-2';
            stockAllButton.id = `stock-all-storage-${cell.label.replace(/\s+/g, '-')}`;
            stockAllButton.textContent = 'Stock All Relevant from Basket';
            stockAllButton.onclick = () => stockAllRelevantToStorage(cell);
            stockAllButton.disabled = !player.basket.some(item => cell.allowedItems.includes(item));
            stockAllButtonContainer.appendChild(stockAllButton);
            storageGrid.appendChild(stockAllButtonContainer);

            if (cell.allowedItems.length === 0) {
                storageGrid.innerHTML += `<p class="col-span-2 text-center">No items are stored here.</p>`;
            }
            cell.allowedItems.forEach(itemName => {
                const itemDiv = document.createElement('div');
                itemDiv.className = `p-2 text-center border-2 border-amber-900 rounded-lg bg-white shadow-sm`;
                const inStock = cell.items[itemName] > 0;
                const canPutBack = player.basket.includes(itemName);

                const infoDiv = document.createElement('div');
                infoDiv.innerHTML = `
                    <div class="font-handwritten text-xl">${itemName}</div>
                    <div class="text-xs">In Stock: ${cell.items[itemName] || 0}</div>
                `;

                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'mt-2 flex justify-center space-x-2';

                const takeButton = document.createElement('button');
                takeButton.className = 'btn-style px-3 py-1 text-sm';
                takeButton.id = `take-from-storage-${cell.label.replace(/\s+/g, '-')}-${itemName.replace(/\s+/g, '-')}`;
                takeButton.dataset.action = 'take';
                takeButton.dataset.item = itemName;
                takeButton.disabled = !inStock || player.basket.length >= MAX_BASKET_SIZE;
                takeButton.textContent = 'Take 1';

                const putBackButton = document.createElement('button');
                putBackButton.className = 'btn-style px-3 py-1 text-sm';
                putBackButton.id = `put-in-storage-${cell.label.replace(/\s+/g, '-')}-${itemName.replace(/\s+/g, '-')}`;
                putBackButton.dataset.action = 'put_back';
                putBackButton.dataset.item = itemName;
                putBackButton.disabled = !canPutBack;
                putBackButton.textContent = 'Put Back 1';

                buttonContainer.appendChild(takeButton);
                buttonContainer.appendChild(putBackButton);
                itemDiv.appendChild(infoDiv);
                itemDiv.appendChild(buttonContainer);
                storageGrid.appendChild(itemDiv);
            });
            storageGrid.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const action = e.target.dataset.action;
                    const itemName = e.target.dataset.item;
                    if (action === 'take') {
                        takeItemFromStorage(itemName, cell);
                    } else if (action === 'put_back') {
                        putItemInStorage(itemName, cell);
                    }
                });
            });
            showAppScreen('storage-panel');
        }


function openProductAssignmentForShelf(shelf, slotIndex) {
            const assignmentGrid = document.getElementById('assignment-grid');
            const assignmentTitle = document.getElementById('assignment-title');
            assignmentGrid.innerHTML = '';
            assignmentTitle.textContent = `Assign to Shelf ${shelves.indexOf(shelf) + 1} - Slot ${slotIndex + 1}`;

            const currentSlot = shelf.items[slotIndex];

            const backButton = document.createElement('button');
            backButton.className = 'btn-style bg-amber-700/80 hover:bg-amber-600';
            backButton.id = `back-to-shelf-slots-${shelves.indexOf(shelf)}`;
            backButton.textContent = '← Back';
            backButton.onclick = () => showShelfSlotsForAssignment(shelf);
            assignmentGrid.appendChild(backButton);

            const clearButton = document.createElement('button');
            clearButton.className = 'btn-style bg-red-700/80 hover:bg-red-600';
            clearButton.id = `clear-shelf-${shelves.indexOf(shelf)}-slot-${slotIndex}`;
            clearButton.textContent = 'Clear';
            clearButton.onclick = () => {
                const itemToMove = currentSlot.assignedItem;
                const quantityToMove = currentSlot.quantity;

                if (quantityToMove > 0 && itemToMove) {
                    const storageCell = storageCells.find(c => c.allowedItems.includes(itemToMove));
                    if (!storageCell) {
                        showMessage(`Error: No storage cell for ${itemToMove}. Cannot move items.`);
                        return;
                    }
                    const currentFill = Object.values(storageCell.items).reduce((a, b) => a + b, 0);
                    if (currentFill + quantityToMove > storageCell.capacity) {
                        showMessage(`Not enough room in ${storageCell.label} storage to move ${quantityToMove} items.`);
                        return;
                    }
                    storageCell.items[itemToMove] = (storageCell.items[itemToMove] || 0) + quantityToMove;
                }

                currentSlot.assignedItem = null;
                currentSlot.quantity = 0;
                saveGame();
                togglePanel('assignment', false);
                togglePanel('shelf-assignment', true);
                showShelfSlotsForAssignment(shelf);
            };
            assignmentGrid.appendChild(clearButton);

            const unlockedItems = new Set();
            storageCells.forEach((cell, index) => {
                if (unlocks.storage[index]) {
                    cell.allowedItems.forEach(item => unlockedItems.add(item));
                }
            });


            for (const itemName of unlockedItems) {
                const button = document.createElement('button');
                button.className = 'btn-style';
                button.id = `assign-item-${itemName.replace(/\s+/g, '-')}-to-shelf-${shelves.indexOf(shelf)}-slot-${slotIndex}`;
                button.textContent = itemName;
                button.dataset.item = itemName;
                button.onclick = () => {
                    const oldItem = currentSlot.assignedItem;
                    const oldQuantity = currentSlot.quantity;
                    const newItem = itemName;

                    if (oldItem === newItem) {
                        togglePanel('assignment', false);
                        return;
                    }

                    if (oldQuantity > 0 && oldItem) {
                        const storageCell = storageCells.find(c => c.allowedItems.includes(oldItem));
                        if (!storageCell) {
                            showMessage(`Error: No storage cell for ${oldItem}. Cannot move items.`);
                            return;
                        }
                        const currentFill = Object.values(storageCell.items).reduce((a, b) => a + b, 0);
                        if (currentFill + oldQuantity > storageCell.capacity) {
                            showMessage(`Not enough room in ${storageCell.label} storage to move ${oldQuantity} ${oldItem}.`);
                            return;
                        }
                        storageCell.items[oldItem] = (storageCell.items[oldItem] || 0) + oldQuantity;
                        currentSlot.quantity = 0;
                    }

                    currentSlot.assignedItem = newItem;
                    saveGame();
                    togglePanel('assignment', false);
                    togglePanel('shelf-assignment', true);
                    showShelfSlotsForAssignment(shelf);
                };
                assignmentGrid.appendChild(button);
            }
            showAppScreen('assignment-panel');
        }

        function stockAllRelevantFromBasket(shelf) {
            let itemsMoved = 0;
            const basketCounts = player.basket.reduce((acc, item) => {
                acc[item] = (acc[item] || 0) + 1;
                return acc;
            }, {});

            for (const slot of shelf.items) {
                if (slot.assignedItem && basketCounts[slot.assignedItem]) {
                    let canMove = MAX_SHELF_STACK - slot.quantity;
                    let toMove = Math.min(canMove, basketCounts[slot.assignedItem]);

                    if (toMove > 0) {
                        slot.quantity += toMove;
                        basketCounts[slot.assignedItem] -= toMove;
                        itemsMoved += toMove;

                        // Remove items from player's basket
                        let removedCount = 0;
                        for (let i = player.basket.length - 1; i >= 0 && removedCount < toMove; i--) {
                            if (player.basket[i] === slot.assignedItem) {
                                player.basket.splice(i, 1);
                                removedCount++;
                            }
                        }
                    }
                }
            }

            if (itemsMoved > 0) {
                updateBasketUI();
                spawnFloatingText(`Stocked ${itemsMoved} items!`, player.x, player.y - 90, '#22c55e');
                saveGame();
                openShelfPanel(shelf); // Refresh the panel
            }
        }

        function openItemsPanel() {
            const itemsGrid = document.getElementById('items-toggle-grid');
            itemsGrid.innerHTML = '';

            const unlockedItems = new Set();
            // Add items from unlocked storage cells
            unlocks.storage.forEach((isUnlocked, index) => {
                const category = storageCells[index];
                // Ensure the category and its allowedItems exist before access.
                if (isUnlocked && category && category.allowedItems) {
                    category.allowedItems.forEach(item => unlockedItems.add(item));
                }
            });

            if (unlockedItems.size === 0) {
                itemsGrid.innerHTML = `<p class="text-center p-4">Unlock storage to manage items.</p>`;
                showAppScreen('items-panel');
                return;
            }

            for (const itemName of unlockedItems) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'flex items-center justify-between p-2 bg-white/50 rounded-md';
                const isChecked = enabledItems[itemName];
                const sanitizedItemName = itemName.replace(/\s+/g, '-').toLowerCase();


                itemDiv.innerHTML = `
                    <label for="toggle-${sanitizedItemName}" class="text-lg">${itemName}</label>
                    <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="toggle-${sanitizedItemName}" id="toggle-${sanitizedItemName}" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" ${isChecked ? 'checked' : ''}/>
                        <label for="toggle-${sanitizedItemName}" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                `;
                itemsGrid.appendChild(itemDiv);

                const toggle = itemDiv.querySelector(`#toggle-${sanitizedItemName}`);
                toggle.addEventListener('change', (e) => {
                    enabledItems[itemName] = e.target.checked;
                    saveGame();
                });
            }

            showAppScreen('items-panel');
        }

        function openShelfPanel(shelf) {
            phoneScreenContext = { shelfIndex: shelves.indexOf(shelf) }; // Store context
            activeShelf = shelf;
            const shelfGrid = document.getElementById('shelf-grid');
            document.getElementById('shelf-title').textContent = `Manage Shelf ${shelves.indexOf(shelf) + 1}`;
            shelfGrid.innerHTML = '';

            const stockAllButtonContainer = document.createElement('div');
            stockAllButtonContainer.className = 'p-2';
            const stockAllButton = document.createElement('button');
            stockAllButton.className = 'btn-style w-full py-2';
            stockAllButton.id = `stock-all-shelf-${shelves.indexOf(shelf)}`;
            stockAllButton.textContent = 'Stock All Relevant from Basket';
            stockAllButton.onclick = () => stockAllRelevantFromBasket(shelf);

            const hasRelevantItems = player.basket.some(itemInBasket =>
                shelf.items.some(slot => slot.assignedItem === itemInBasket && slot.quantity < MAX_SHELF_STACK)
            );
            stockAllButton.disabled = !hasRelevantItems;

            stockAllButtonContainer.appendChild(stockAllButton);
            shelfGrid.appendChild(stockAllButtonContainer);


            for (let i = 0; i < 4; i++) {
                const slot = shelf.items[i];
                const slotDiv = document.createElement('div');
                slotDiv.className = 'p-2 text-center border-2 border-dashed border-amber-700 rounded-lg flex flex-col justify-between min-h-[100px]';

                if (slot.assignedItem) {
                    const canPlaceMore = player.basket.includes(slot.assignedItem) && slot.quantity < MAX_SHELF_STACK;
                    const canTake = slot.quantity > 0 && player.basket.length < MAX_BASKET_SIZE;

                    const infoDiv = document.createElement('div');
                    infoDiv.innerHTML = `
                        <div class="font-handwritten text-lg">${slot.assignedItem}</div>
                        <div>${slot.quantity} / ${MAX_SHELF_STACK}</div>
                    `;

                    const buttonContainer = document.createElement('div');
                    buttonContainer.className = 'mt-2 flex justify-center space-x-2';

                    const takeButton = document.createElement('button');
                    takeButton.className = 'btn-style px-2 py-1 text-sm';
                    takeButton.id = `take-from-shelf-${shelves.indexOf(shelf)}-slot-${i}`;
                    takeButton.dataset.action = 'take';
                    takeButton.dataset.shelf = shelves.indexOf(shelf);
                    takeButton.dataset.slot = i;
                    takeButton.disabled = !canTake;
                    takeButton.textContent = 'Take';

                    const placeButton = document.createElement('button');
                    placeButton.className = 'btn-style px-2 py-1 text-sm';
                    placeButton.id = `place-on-shelf-${shelves.indexOf(shelf)}-slot-${i}`;
                    placeButton.dataset.action = 'place';
                    placeButton.dataset.shelf = shelves.indexOf(shelf);
                    placeButton.dataset.slot = i;
                    placeButton.disabled = !canPlaceMore;
                    placeButton.textContent = 'Place';

                    buttonContainer.appendChild(takeButton);
                    buttonContainer.appendChild(placeButton);
                    slotDiv.appendChild(infoDiv);
                    slotDiv.appendChild(buttonContainer);
                } else {
                    const assignButton = document.createElement('button');
                    assignButton.className = 'btn-style w-full h-full flex items-center justify-center';
                    assignButton.id = `assign-to-shelf-${shelves.indexOf(shelf)}-slot-${i}`;
                    assignButton.dataset.action = 'assign';
                    assignButton.dataset.shelf = shelves.indexOf(shelf);
                    assignButton.dataset.slot = i;
                    assignButton.textContent = 'Assign Item';
                    slotDiv.appendChild(assignButton);
                }
                shelfGrid.appendChild(slotDiv);
            }

            shelfGrid.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', e => {
                    const shelfIndex = parseInt(e.currentTarget.dataset.shelf, 10);
                    const slotIndex = parseInt(e.currentTarget.dataset.slot, 10);
                    const action = e.currentTarget.dataset.action;
                    const targetShelf = shelves[shelfIndex];

                    if (!targetShelf) return;
                    const targetSlot = targetShelf.items[slotIndex];

                    if (action === 'take') {
                        player.basket.push(targetSlot.assignedItem);
                        targetSlot.quantity--;
                        updateBasketUI();
                        saveGame();
                        openShelfPanel(targetShelf);
                    } else if (action === 'place') {
                        const itemIndex = player.basket.indexOf(targetSlot.assignedItem);
                        if (itemIndex > -1) {
                            player.basket.splice(itemIndex, 1);
                            targetSlot.quantity++;
                            updateBasketUI();
                            saveGame();
                            openShelfPanel(targetShelf);
                        }
                    } else if (action === 'assign') {
                        openBasketAssignmentForShelf(targetShelf, slotIndex);
                    }
                });
            });

            showAppScreen('shelf-panel');
        }

        function openBasketAssignmentForShelf(shelf, slotIndex) {
            if (player.basket.length === 0) {
                showMessage("Your basket is empty. Add items to your basket to assign them to a shelf.");
                return;
            }

            const assignmentGrid = document.getElementById('assignment-grid');
            const assignmentTitle = document.getElementById('assignment-title');
            assignmentGrid.innerHTML = '';
            assignmentTitle.textContent = `Assign from Basket`;

            const backButton = document.createElement('button');
            backButton.className = 'btn-style bg-amber-700/80 hover:bg-amber-600';
            backButton.textContent = '← Back to Shelf';
            backButton.onclick = () => openShelfPanel(shelf);
            assignmentGrid.appendChild(backButton);

            const uniqueItemsInBasket = [...new Set(player.basket)];

            uniqueItemsInBasket.forEach(itemName => {
                const button = document.createElement('button');
                button.className = 'btn-style';
                button.textContent = itemName;
                button.onclick = () => {
                    const targetSlot = shelf.items[slotIndex];
                    const itemIndexInBasket = player.basket.indexOf(itemName);

                    if (itemIndexInBasket > -1) {
                        // Remove item from basket
                        player.basket.splice(itemIndexInBasket, 1);

                        // Assign to shelf and set quantity to 1
                        targetSlot.assignedItem = itemName;
                        targetSlot.quantity = 1;

                        updateBasketUI();
                        saveGame();
                        openShelfPanel(shelf); // Refresh the shelf panel to show the change
                    }
                };
                assignmentGrid.appendChild(button);
            });

            showAppScreen('assignment-panel');
        }

        function takeItemFromStorage(itemName, cell) {
            if (player.basket.length < MAX_BASKET_SIZE) {
                if (cell.items[itemName] > 0) {
                    cell.items[itemName]--;
                    player.basket.push(itemName);
                    updateBasketUI();
                    saveGame();
                    openStorageCell(cell); // Refresh panel
                }
            } else {
                spawnFloatingText("Your basket is full!", player.x, player.y - 90, '#ef4444');
            }
        }

        function putItemInStorage(itemName, cell) {
            const itemIndex = player.basket.indexOf(itemName);
            if (itemIndex > -1) {
                player.basket.splice(itemIndex, 1);
                if (!cell.items[itemName]) cell.items[itemName] = 0;
                cell.items[itemName]++;
                updateBasketUI();
                saveGame();
                openStorageCell(cell); // Refresh panel
            }
        }


        let activePanel = null; // DEPRECATED: Will be replaced by phone-specific logic
        let activePhoneScreen = null; // Tracks the currently open app screen inside the phone
        let phoneScreenContext = {}; // Stores context for screens that need it (e.g., which item is being ordered)
        let isPhoneOpen = false;
        let activeShelf = null;
        let activeStorageCell = null;

        function closeClipboard() {
            const clipboardPanel = document.getElementById('clipboard-panel');
            clipboardPanel.classList.remove('open');
            isPhoneOpen = false;
            activePhoneScreen = null;
            closeNewspaperModal();
        }

        function showAppGrid() {
            document.getElementById('phone-apps-grid').classList.remove('hidden');
            document.getElementById('phone-app-screens').classList.add('hidden');
            activePhoneScreen = null;
            phoneScreenContext = {}; // Clear context when going home
            closeNewspaperModal();

            // Companion-specific UI updates
            if (document.body.classList.contains('companion-mode')) {
                document.getElementById('companion-control-footer').classList.remove('hidden');
                document.getElementById('order-footer').classList.add('hidden');
            }
        }

        function showAppScreen(panelId) {
            closeNewspaperModal();
            const appScreensContainer = document.getElementById('phone-app-screens');

            // Hide all other screens within the container
            const allScreens = appScreensContainer.querySelectorAll('.phone-app-screen');
            allScreens.forEach(screen => screen.classList.add('hidden'));

            // Show the target screen
            const targetScreen = document.getElementById(panelId);
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
            }

            // Show the container and hide the grid
            appScreensContainer.classList.remove('hidden');
            document.getElementById('phone-apps-grid').classList.add('hidden');

            activePhoneScreen = panelId;

            // Show/hide the shared order footer
            const orderFooter = document.getElementById('order-footer');
            const companionFooter = document.getElementById('companion-control-footer');

            if (document.body.classList.contains('companion-mode')) {
                companionFooter.classList.add('hidden');
            }

            if (panelId === 'restock-panel' || panelId === 'order-quantity-modal') {
                orderFooter.classList.remove('hidden');
            } else {
                orderFooter.classList.add('hidden');
            }
        }


        function togglePanel(panelName, forceOpen = false) {
            // This function is now a legacy wrapper. New UI should use the phone functions.
            const targetPanel = document.getElementById(`${panelName}-panel`);
            if (forceOpen) {
                 if (targetPanel) targetPanel.classList.remove('hidden');
                 activePanel = panelName;
            } else {
                 if (targetPanel) targetPanel.classList.add('hidden');
                 activePanel = null;
            }
             if (panelName === 'shelf') activeShelf = null;
             if (panelName === 'storage') activeStorageCell = null;
        }


        function setupDevToggle(toggleId, labelId, onText, offText) {
            const toggle = document.getElementById(toggleId);
            const label = document.getElementById(labelId);
            toggle.addEventListener('change', () => {
                label.textContent = toggle.checked ? onText : offText;
            });
            // Set initial state
            label.textContent = toggle.checked ? onText : offText;
        }

        function resetGameState() {
            // Core Game Loop Control
            isGameActive = false;
            isPaused = false;
            lastTimestamp = 0;

            // Player and Camera
            cameraState = 'store';
            targetCameraX = 0;
            cameraX = 0;
            player.targetX = null;
            player.targetY = null;

            // Time and Day
            day = 1;
            dayTimer = DAY_DURATION;
            dayPhase = 'pre-open';
            dayStarted = false;
            timeMultiplier = 1;

            // Financials and Points
            cash = 100;
            shopPoints = 0;

            // Arrays and Dynamic Objects
            customers = [];
            loadingDockPackages = [];
            floatingTexts = [];
            shelves = []; // This will be repopulated by initializeLayout

            // Daily and Weekly Trackers
            dailySalesReport = [];
            startingDayInventory = {};
            dailySupplyOrders = [];
            dailyLaborCosts = {};
            dailyEmployeeWorkTimes = {};
            currentWeeklyAccruedBill = 0;
            currentWeeklyLaborCost = 0;
            currentWeeklyRentCost = 0;
            currentWeeklyStorageCost = 0;
            currentWeeklyCoffeeCost = 0;
            dayShiftBreakTriggered = false;
            nightShiftBreakTriggered = false;

            // Market State
            marketForecast = [];
            nextMarketForecast = [];
            currentDailyMood = null;
            itemPopularity = {};
            priceHistory = {};
            dailyPlayerPurchases = {};
            // Restore original costs from the master backup
            if (Object.keys(originalItemCosts).length > 0) {
                 Object.keys(items).forEach(key => {
                    items[key].cost = originalItemCosts[key];
                });
            }


            // Game Mode Flags
            developerMode = false;
            continuousMode = false;
            casualNoBreaks = false;
            casualNoDebtPenalty = false;
            marketEnabled = true;
            coffeeShopExists = true;
            CUSTOMER_SPAWN_INTERVAL = 8000;


            // Unlocks and Inventory
            unlocks = {
                employees: { cashier: false, stocker: false, barista: false, manager: false, salesperson: false },
                shelves: [true, false, false, false, false, false],
                facilities: { coffeeShop: false },
                storage: [true, false, false, false, false, false]
            };
            Object.keys(items).forEach(item => inventory[item] = 5);
            Object.keys(items).forEach(item => enabledItems[item] = true);


            // Reset customer and employee data from backups
            customerProfiles = JSON.parse(JSON.stringify(originalCustomerProfiles));
            // employeePayRates is a const, so we must modify its properties instead of reassigning it.
            for (const key in originalEmployeePayRates) {
                employeePayRates[key] = originalEmployeePayRates[key];
            }
            const allEmployees = { cashier, stocker, barista, manager, salesperson };
            for (const empKey in allEmployees) {
                const employee = allEmployees[empKey];
                if (employee) {
                    employee.breakTakenToday = false;
                    employee.onBreak = false;
                    employee.playerInitiatedBreak = false;
                    employee.task = null;
                    employee.state = 'idle';
                    employee.basket = [];
                    employee.stateTimer = 0;
                }
            }


            // UI State
            closeClipboard();
            document.getElementById('start-day-btn').classList.add('hidden');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            if (playIcon && pauseIcon) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            }


            // Finalize Reset
            updateUI();
        }

        function showScreen(screenId) {
            // If we are the host with a connection, send the screen change to the companion.
            if (hostConnection && hostConnection.open) {
                currentModalScreen = screenId;
                sendFullGameStateToCompanion();
                // Don't show the modal on the host screen
                return;
            }
            const screen = document.getElementById(screenId);
            if (screen) screen.classList.remove('hidden');
        }

        function hideScreen(screenId) {
            // If we are the host with a connection, update state for the companion.
            if (hostConnection && hostConnection.open) {
                if (currentModalScreen === screenId) {
                    currentModalScreen = null;
                    sendFullGameStateToCompanion();
                }
            }
            // Always hide the element on the host. This handles cases where a companion
            // disconnects or for non-companion play.
            const screen = document.getElementById(screenId);
            if (screen) screen.classList.add('hidden');
        }

        function startGame(options = {}) {
            // 1. Hide all modal screens & close phone
            if (hostConnection && hostConnection.open) {
                currentModalScreen = null;
                sendFullGameStateToCompanion();
            }
            hideScreen('new-game-screen');
            hideScreen('dev-mode-screen');
            hideScreen('family-store-screen');
            hideScreen('specialty-store-screen');
            hideScreen('casual-mode-screen');
            hideScreen('final-settings-screen');
            closeClipboard();


            // 2. Reset everything
            localStorage.removeItem('artAttackSave');
            resetGameState();

            // 3. Apply options from the config object
            if (options.dev) {
                if (options.dev.freeUnlocks) {
                    Object.keys(unlocks.employees).forEach(k => unlocks.employees[k] = true);
                    unlocks.shelves.fill(true);
                    Object.keys(unlocks.facilities).forEach(k => unlocks.facilities[k] = true);
                    unlocks.storage.fill(true);
                }
                if (options.dev.freeSupplies) {
                    Object.keys(items).forEach(key => {
                        items[key].cost = 0;
                    });
                }
                if (options.dev.startWithDebt) {
                    cash = -1000;
                }
            }

            if (options.family) {
                if (options.family.freeCoffee) {
                    unlocks.facilities.coffeeShop = true;
                    unlocks.employees.barista = true;
                }
                if (options.family.badCosts) {
                    Object.keys(items).forEach(key => {
                        items[key].cost = Math.ceil(items[key].cost * 1.25);
                    });
                }
                if (options.family.freeEmployee) {
                    unlocks.employees[options.family.freeEmployee] = true;
                    employeePayRates[options.family.freeEmployee] = 0;
                }
            }

            if (options.specialty) {
                const { primary, secondary, goodCosts, noCoffee, moreCustomers } = options.specialty;
                const chosenSpecialties = [primary];
                if (secondary) {
                    chosenSpecialties.push(secondary);
                }

                // Unlock only selected specialties' storage
                unlocks.storage.fill(false);
                storageCells.forEach((cell, index) => {
                    if (chosenSpecialties.includes(cell.label)) {
                        unlocks.storage[index] = true;
                    }
                });

                // Disable all items not in the chosen specialties
                const allowedItemsSet = new Set();
                storageCells.forEach((cell, index) => {
                    if (unlocks.storage[index]) { // Check if this specialty is chosen
                        cell.allowedItems.forEach(item => allowedItemsSet.add(item));
                    }
                });

                Object.keys(enabledItems).forEach(item => {
                    enabledItems[item] = allowedItemsSet.has(item);
                });

                // Apply other toggles
                if (goodCosts) {
                     Object.keys(items).forEach(key => {
                        items[key].cost = Math.floor(items[key].cost * 0.9);
                    });
                }
                if (noCoffee) {
                    unlocks.facilities.coffeeShop = false;
                    coffeeShopExists = false;
                }
                if (moreCustomers) {
                    CUSTOMER_SPAWN_INTERVAL = 4000; // Faster customer spawns
                }
            }

            // Apply final settings from the new modal
            marketType = options.marketType || 'classic';
            continuousMode = options.continuousMode || false;
            marketEnabled = marketType !== 'disabled';

            if (options.casual) {
                casualNoBreaks = options.casual.noBreaks;
                casualNoDebtPenalty = options.casual.noDebtPenalty;
            }

        // Generate data if market is enabled, after all options are processed.
        if (marketEnabled) {
            marketForecast = generateMarketForecast();
            nextMarketForecast = generateMarketForecast();
            generateInitialMarketData(); // This now uses the forecast to set day 1 prices.
        }

            // 4. Finalize setup
            initializeLayout();
            // --- FIX: Set initial camera state to prevent panning ---
            cameraState = 'store';
            targetCameraX = -officeWidth;
            cameraX = -officeWidth;
            // --- END FIX ---
            updateUI();
            if (continuousMode) {
                document.getElementById('start-day-btn').click();
            } else {
                dayStarted = false;
                document.getElementById('start-day-btn').classList.remove('hidden');
            }
            isGameActive = true; // Reactivate the game loop
        }

        function saveGame() {
            const employeesToSave = {};
            const employeeObjects = { cashier, stocker, barista, manager, salesperson };
            for (const key in employeeObjects) {
                employeesToSave[key] = {
                    shift: employeeObjects[key].shift,
                    breakPreference: employeeObjects[key].breakPreference
                };
            }

            const gameState = {
                cash, day, shopPoints, itemPopularity,
                inventory, storageCells, shelves,
                unlocks, loadingDockPackages, customerDemand,
                customerProfiles, enabledItems,
                currentWeeklyAccruedBill, currentWeeklyLaborCost,
                employeeWorkTimers,
                employees: employeesToSave,
                priceHistory,
                marketType, marketEnabled,
                continuousMode,
                currentDailyMood,
                marketForecast,
                nextMarketForecast
            };
            localStorage.setItem('artAttackSave', JSON.stringify(gameState));
        }

        function loadGame() {
            const savedState = localStorage.getItem('artAttackSave');
            if (savedState) {
                try {
                    const gameState = JSON.parse(savedState);
                    cash = gameState.cash || 100;
                    day = gameState.day || 1;
                    shopPoints = gameState.shopPoints || 0;
                    itemPopularity = gameState.itemPopularity || {};
                    inventory = gameState.inventory || inventory;
                    storageCells = gameState.storageCells || storageCells;
                    shelves = gameState.shelves || shelves;
                    unlocks = gameState.unlocks || unlocks;
                    if (!unlocks.facilities) {
                        unlocks.facilities = { coffeeShop: false };
                    }
                    loadingDockPackages = gameState.loadingDockPackages || [];
                    customerDemand = gameState.customerDemand || {};
                    enabledItems = gameState.enabledItems || enabledItems;
                    currentWeeklyAccruedBill = gameState.currentWeeklyAccruedBill || 0;
                    currentWeeklyLaborCost = gameState.currentWeeklyLaborCost || 0;
                    employeeWorkTimers = gameState.employeeWorkTimers || { cashier: 0, stocker: 0, barista: 0, manager: 0, salesperson: 0 };

                    if (gameState.employees) {
                        const allEmployees = { cashier, stocker, barista, manager, salesperson };
                        for (const empKey in gameState.employees) {
                            if (allEmployees[empKey]) {
                                Object.assign(allEmployees[empKey], gameState.employees[empKey]);
                                // Backward compatibility: convert string shift to array
                                if (typeof allEmployees[empKey].shift === 'string') {
                                    allEmployees[empKey].shift = [allEmployees[empKey].shift];
                                }
                            }
                        }
                    }

                    // Initialize popularity for any items missing from save
                    Object.keys(items).forEach(item => {
                        if (!itemPopularity[item]) {
                            itemPopularity[item] = 0;
                        }
                    });

                    if (gameState.customerProfiles) {
                        // Deep merge saved profiles into the default ones
                        for (const type in gameState.customerProfiles) {
                            if (customerProfiles[type]) {
                                for (const name in gameState.customerProfiles[type]) {
                                    if (customerProfiles[type][name]) {
                                        Object.assign(customerProfiles[type][name], gameState.customerProfiles[type][name]);
                                    }
                                }
                            }
                        }
                    }


                    // Re-attach draw methods to shelves as they are lost in JSON.
                    shelves.forEach(shelf => {
                         shelf.draw = drawShelf; // REFACTOR: Assign the single draw function
                    });

                    // Load market settings, with fallbacks for older saves
                    marketEnabled = gameState.marketEnabled !== undefined ? gameState.marketEnabled : true;
                    marketType = gameState.marketType || 'classic';
                    marketForecast = gameState.marketForecast || [];
                    nextMarketForecast = gameState.nextMarketForecast || [];

                    continuousMode = gameState.continuousMode || false;
                    currentDailyMood = gameState.currentDailyMood || null;


                } catch (e) {
                    console.error("Failed to parse saved game data:", e);
                    localStorage.removeItem('artAttackSave'); // Clear corrupted save
                }
            }
        }

        function updateBasketUI() {
            const basketCount = document.getElementById('basket-item-count');
            const basketContents = document.getElementById('basket-contents');

            basketCount.textContent = player.basket.length;
            basketContents.innerHTML = ''; // Clear previous contents

            if (player.basket.length === 0) {
                basketContents.innerHTML = '<p class="text-sm text-center text-amber-800/70">Basket is empty</p>';
                return;
            }

            const itemCounts = player.basket.reduce((acc, item) => {
                acc[item] = (acc[item] || 0) + 1;
                return acc;
            }, {});

            for (const item in itemCounts) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-1 border-b border-amber-800/20 flex justify-between items-center';
                itemDiv.innerHTML = `
                    <span class="text-sm">${item}</span>
                    <span class="font-handwritten text-base">x${itemCounts[item]}</span>
                `;
                basketContents.appendChild(itemDiv);
            }
        }

        function toggleBasketExpansion() {
            const basketContents = document.getElementById('basket-contents');
            basketContents.classList.toggle('hidden');
        }

        function togglePause() {
            isPaused = !isPaused;
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            if (isPaused) {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            } else {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            }
        }

        function init() {
            const urlParams = new URLSearchParams(window.location.search);
            const companionId = urlParams.get('companion_id');
            const isCompanion = urlParams.get('mode') === 'companion';
            const isSmallScreen = window.innerWidth < 768;

            // Automatically enter companion mode if a companion_id is present,
            // or via the old methods (small screen / ?mode=companion)
            if (companionId || isCompanion || isSmallScreen) {
                document.body.classList.add('companion-mode');
                openClipboardPanel();

                initializeCompanion(); // This sets up the `peer` object
                setupCompanionActionListeners();

                if (companionId) {
                    // If we have an ID from the QR code, connect immediately.
                    connectToHost(companionId);
                } else {
                    // Otherwise, show the sync screen to wait for a QR scan.
                    showAppScreen('companion-sync-screen');
                    document.getElementById('phone-back-btn').classList.add('hidden');
                }
                return; // Stop normal game initialization for companion
            }

            originalCustomerProfiles = JSON.parse(JSON.stringify(customerProfiles));
            Object.keys(items).forEach(key => {
                // Initialize the dynamic 'cost' property, which will fluctuate with the market.
                items[key].cost = items[key].baseCost;
                // Store the original base cost for market calculations.
                originalItemCosts[key] = items[key].baseCost;
            });
            originalEmployeePayRates = { ...employeePayRates };
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            pieClockCanvas = document.getElementById('pie-clock-canvas');
            pieClockCtx = pieClockCanvas.getContext('2d');

            document.getElementById('pause-play-btn').addEventListener('click', togglePause);
            document.getElementById('basket-icon-container').addEventListener('click', toggleBasketExpansion);
            document.getElementById('double-time-btn').addEventListener('click', toggleDoubleTime);

            // Host listeners
            document.getElementById('companion-sync-btn').addEventListener('click', initializeHost);
            document.getElementById('host-sync-close-btn').addEventListener('click', () => document.getElementById('host-sync-modal').classList.add('hidden'));

            // Companion listeners
            // The manual connection button has been removed, so this listener is no longer needed.
            // document.getElementById('companion-connect-btn').addEventListener('click', () => connectToHost());


            const hasSave = localStorage.getItem('artAttackSave');
            if (hasSave) {
                loadGame();
            } else {
                showScreen('new-game-screen');
            }

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            canvas.addEventListener('click', handleCanvasClick);
            pieClockCanvas.addEventListener('click', handleClockClick);

            document.getElementById('start-day-btn').addEventListener('click', () => {
                if(dayStarted) return;
                dayStarted = true;
                dayTimer = DAY_DURATION;
                timeSinceLastCustomer = 0;
                document.getElementById('start-day-btn').classList.add('hidden');

                // Capture starting inventory and reset daily trackers
                startingDayInventory = {};
                Object.keys(items).forEach(itemName => {
                    startingDayInventory[itemName] = getTotalStock(itemName);
                });
                dailySupplyOrders = [];
                dailyLaborCosts = {};

                // Ensure all idle states are correct before starting
                if (!stocker.task) stocker.state = 'idle';
                if (!cashier.task) cashier.state = 'idle';
                if (!manager.task) manager.state = 'idle';
                if (!salesperson.task) salesperson.state = 'idle';
            });

            // --- New Game Screen Button Listeners ---
            document.getElementById('new-game-standard').addEventListener('click', () => {
                openFinalSettingsScreen({}, 'new-game-screen');
            });
            document.getElementById('new-game-dev').addEventListener('click', () => {
                hideScreen('new-game-screen');
                showScreen('dev-mode-screen');
            });
            document.getElementById('new-game-family').addEventListener('click', () => {
                hideScreen('new-game-screen');
                showScreen('family-store-screen');
            });
            document.getElementById('new-game-specialty').addEventListener('click', () => {
                hideScreen('new-game-screen');
                showScreen('specialty-store-screen');
            });
            document.getElementById('new-game-casual').addEventListener('click', () => {
                hideScreen('new-game-screen');
                showScreen('casual-mode-screen');
            });
             document.getElementById('close-new-game-screen').addEventListener('click', () => {
                if (localStorage.getItem('artAttackSave')) {
                    hideScreen('new-game-screen');
                } else {
                    // If closing with no save, start a default game immediately.
                    startGame({});
                }
            });

            // --- Dev Mode Screen Button Listeners ---
            document.getElementById('dev-back-btn').addEventListener('click', () => {
                hideScreen('dev-mode-screen');
                showScreen('new-game-screen');
            });
            document.getElementById('dev-start-game-btn').addEventListener('click', () => {
                const options = {
                    dev: {
                        freeUnlocks: document.getElementById('dev-unlocks-toggle').checked,
                        freeSupplies: document.getElementById('dev-supplies-toggle').checked,
                        startWithDebt: document.getElementById('dev-debt-toggle').checked
                    }
                };
                openFinalSettingsScreen(options, 'dev-mode-screen');
            });

            // --- Casual Mode Screen Logic ---
            document.getElementById('casual-back-btn').addEventListener('click', () => {
                hideScreen('casual-mode-screen');
                showScreen('new-game-screen');
            });

            document.getElementById('casual-start-game-btn').addEventListener('click', () => {
                const options = {
                    casual: {
                        noBreaks: document.getElementById('casual-breaks-toggle').checked,
                        noDebtPenalty: document.getElementById('casual-debt-toggle').checked
                    }
                };
                openFinalSettingsScreen(options, 'casual-mode-screen');
            });

            // --- Specialty Store Screen Logic ---
            const specialtyOneSelect = document.getElementById('specialty-one-select');
            const specialtyTwoSelect = document.getElementById('specialty-two-select');
            const artTypes = storageCells.map(cell => cell.label);

            function populateSpecialtyDropdowns() {
                specialtyOneSelect.innerHTML = '';
                specialtyTwoSelect.innerHTML = '';

                artTypes.forEach(type => {
                    const option1 = document.createElement('option');
                    option1.value = type;
                    option1.textContent = type;
                    specialtyOneSelect.appendChild(option1);

                    const option2 = document.createElement('option');
                    option2.value = type;
                    option2.textContent = type;
                    specialtyTwoSelect.appendChild(option2);
                });

                const noneOption = document.createElement('option');
                noneOption.value = 'None';
                noneOption.textContent = 'None';
                specialtyTwoSelect.prepend(noneOption);
                specialtyTwoSelect.value = 'None';
            }

            if (specialtyOneSelect.options.length === 0) {
                populateSpecialtyDropdowns();
            }

             function handleSpecialtyChange() {
                const primaryValue = specialtyOneSelect.value;
                const secondaryValue = specialtyTwoSelect.value;

                Array.from(specialtyTwoSelect.options).forEach(opt => {
                    opt.disabled = (opt.value === primaryValue && opt.value !== 'None');
                });
                Array.from(specialtyOneSelect.options).forEach(opt => {
                    opt.disabled = (opt.value === secondaryValue && opt.value !== 'None');
                });

                if (primaryValue === secondaryValue && primaryValue !== 'None') {
                    specialtyTwoSelect.value = 'None';
                }
            }

            specialtyOneSelect.addEventListener('change', handleSpecialtyChange);
            specialtyTwoSelect.addEventListener('change', handleSpecialtyChange);
            handleSpecialtyChange();

            document.getElementById('specialty-back-btn').addEventListener('click', () => {
                hideScreen('specialty-store-screen');
                showScreen('new-game-screen');
            });

            document.getElementById('specialty-start-game-btn').addEventListener('click', () => {
                const options = {
                    specialty: {
                        primary: specialtyOneSelect.value,
                        secondary: specialtyTwoSelect.value === 'None' ? null : specialtyTwoSelect.value,
                        goodCosts: document.getElementById('specialty-costs-toggle').checked,
                        noCoffee: document.getElementById('specialty-coffee-toggle').checked,
                        moreCustomers: document.getElementById('specialty-customers-toggle').checked,
                    }
                };
                openFinalSettingsScreen(options, 'specialty-store-screen');
            });

            // --- Market Style Modal Listeners ---
            document.getElementById('dev-open-market-style-modal-btn').addEventListener('click', openMarketStyleModal);
            document.getElementById('settings-open-market-style-modal-btn').addEventListener('click', openMarketStyleModal);
            document.getElementById('market-style-cancel-btn').addEventListener('click', closeMarketStyleModal);
            document.getElementById('close-manager-report-btn').addEventListener('click', closeManagerReportModal);
            document.getElementById('manager-dev-report-btn').addEventListener('click', openDevReportModal);
            document.getElementById('close-dev-report-btn').addEventListener('click', closeDevReportModal);
            document.getElementById('close-simulated-report-btn').addEventListener('click', closeSimulatedMarketReport);

            // Market Modal Navigation
            document.getElementById('close-market-panel-btn').addEventListener('click', () => hideScreen('market-panel'));
            document.getElementById('close-market-detail-panel-btn').addEventListener('click', () => hideScreen('market-detail-panel'));
            document.getElementById('close-market-deep-dive-panel-btn').addEventListener('click', () => hideScreen('market-item-deep-dive-panel'));


            document.getElementById('market-style-confirm-btn').addEventListener('click', () => {
                marketType = tempMarketStyle;
                marketEnabled = (marketType !== 'disabled');
                saveGame();
                closeMarketStyleModal();
            });

             // Newspaper Modal Listeners
            document.getElementById('close-newspaper-btn').addEventListener('click', closeNewspaperModal);
            document.getElementById('eod-newspaper-btn').addEventListener('click', toggleNewspaperModal);
            document.getElementById('newspaper-hint-btn').addEventListener('click', showHint);
            document.getElementById('market-categories-container').addEventListener('click', (e) => {
                if (e.target.closest('#market-app-newspaper-btn')) {
                    toggleNewspaperModal();
                }
            });

            document.querySelectorAll('.market-style-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    tempMarketStyle = e.target.dataset.style;
                    updateMarketModalUI();
                });
            });

            // Setup Dev Toggles with dynamic labels
            setupDevToggle('dev-unlocks-toggle', 'dev-unlocks-label', 'Free Unlockables', 'Standard');
            setupDevToggle('dev-supplies-toggle', 'dev-supplies-label', 'Free Supplies', 'Standard Costs');
            setupDevToggle('dev-debt-toggle', 'dev-debt-label', 'Start with Debt', 'Standard Debt');

            // --- Family Store Screen Button Listeners ---
            document.getElementById('family-back-btn').addEventListener('click', () => {
                hideScreen('family-store-screen');
                showScreen('new-game-screen');
            });

            const relativeSelect = document.getElementById('family-relative-select');
            if (relativeSelect.options.length === 0) {
                const employeeTypes = Object.keys(unlocks.employees);
                employeeTypes.forEach(emp => {
                    const option = document.createElement('option');
                    option.value = emp;
                    option.textContent = emp.charAt(0).toUpperCase() + emp.slice(1);
                    relativeSelect.appendChild(option);
                });
            }
            document.getElementById('family-start-game-btn').addEventListener('click', () => {
                const options = {
                    family: {
                        freeCoffee: document.getElementById('family-coffee-toggle').checked,
                        badCosts: document.getElementById('family-costs-toggle').checked,
                        badSales: document.getElementById('family-sales-toggle').checked,
                        freeEmployee: relativeSelect.value
                    }
                };
                openFinalSettingsScreen(options, 'family-store-screen');
            });

            // --- Final Settings Screen Listeners ---
            document.getElementById('final-settings-back-btn').addEventListener('click', () => {
                hideScreen('final-settings-screen');
                showScreen(previousNewGameScreen || 'new-game-screen');
            });

            document.getElementById('final-settings-start-game-btn').addEventListener('click', () => {
                const finalMarketType = document.getElementById('final-market-type-select').value;
                const finalContinuousDay = document.getElementById('final-continuous-day-toggle').checked;

                newGameOptions.marketType = finalMarketType;
                newGameOptions.continuousMode = finalContinuousDay;

                startGame(newGameOptions);
            });


            document.getElementById('place-order-btn').addEventListener('click', () => placeOrder(false));
            document.getElementById('new-game-btn').addEventListener('click', () => showScreen('new-game-screen'));

            // Order Quantity Modal Logic
            const quantityInput = document.getElementById('order-quantity-input');
            quantityInput.addEventListener('input', (e) => {
                const itemName = e.target.dataset.item;
                let quantity = parseInt(e.target.value, 10);
                if (isNaN(quantity) || quantity < 0) {
                    quantity = 0;
                    e.target.value = 0;
                }
                if (quantity > 0) {
                    currentRestockOrder[itemName] = quantity;
                } else {
                    delete currentRestockOrder[itemName];
                }
                updateRestockTotal();
            });

            document.getElementById('order-quantity-plus-1').addEventListener('click', () => {
                quantityInput.value = (parseInt(quantityInput.value, 10) || 0) + 1;
                quantityInput.dispatchEvent(new Event('input'));
            });

            document.getElementById('order-quantity-plus-5').addEventListener('click', () => {
                quantityInput.value = (parseInt(quantityInput.value, 10) || 0) + 5;
                quantityInput.dispatchEvent(new Event('input'));
            });

            document.getElementById('order-quantity-minus-1').addEventListener('click', () => {
                const currentValue = (parseInt(quantityInput.value, 10) || 0) - 1;
                quantityInput.value = Math.max(0, currentValue);
                quantityInput.dispatchEvent(new Event('input'));
            });

            document.getElementById('order-quantity-minus-5').addEventListener('click', () => {
                const currentValue = (parseInt(quantityInput.value, 10) || 0) - 5;
                quantityInput.value = Math.max(0, currentValue);
                quantityInput.dispatchEvent(new Event('input'));
            });

            document.getElementById('order-quantity-done-btn').addEventListener('click', () => {
                openRestockPanel();
            });


            // Phone Navigation
            document.getElementById('close-phone').addEventListener('click', closeClipboard);
            document.getElementById('phone-back-btn').addEventListener('click', showAppGrid);

            // Report View Toggling
            const reportToggleButtons = document.querySelectorAll('.report-toggle-btn');
            const reportViews = document.querySelectorAll('.report-view');
            reportToggleButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetViewId = button.id.replace('report-toggle-', 'report-view-');

                    // Toggle views
                    reportViews.forEach(view => {
                        if (view.id === targetViewId) {
                            view.classList.remove('hidden');
                        } else {
                            view.classList.add('hidden');
                        }
                    });

                    // Toggle button styles
                    reportToggleButtons.forEach(btn => {
                        if (btn === button) {
                            btn.classList.remove('bg-opacity-50');
                        } else {
                            btn.classList.add('bg-opacity-50');
                        }
                    });
                });
            });

            // Settings Toggles
            const devToggle = document.getElementById('developer-toggle');
            devToggle.checked = developerMode;
            devToggle.addEventListener('change', (e) => {
                developerMode = e.target.checked;
                updateUI();
            });
            const continuousToggle = document.getElementById('continuous-toggle');
            continuousToggle.checked = continuousMode;
            continuousToggle.addEventListener('change', (e) => {
                continuousMode = e.target.checked;
                saveGame();
            });

            loadSpriteSheet(); // Generate and load player spritesheet
            updateUI();
            requestAnimationFrame(gameLoop);
            document.getElementById('start-day-btn').click();
        }

        window.addEventListener('load', init);

        // --- Companion Mode Networking ---

        // --- REFACTORED ASYNC PEERJS LOGIC ---
        function initializeHost() {
            // This function now just orchestrates the async setup.
            document.getElementById('host-sync-modal').classList.remove('hidden');
            document.getElementById('host-status').textContent = 'Generating connection...';
            document.getElementById('open-in-tab-btn').classList.add('hidden');

            setupHostPeer().then(hostId => {
                console.log(`Host is ready with ID: ${hostId}`);
                displayHostQRCode(hostId);
                listenForCompanionConnections();
            }).catch(error => {
                console.error("Host setup failed:", error);
                document.getElementById('host-status').textContent = `Error: ${error.message || error}`;
            });
        }

        function setupHostPeer() {
            return new Promise((resolve, reject) => {
                if (peer) {
                    peer.destroy();
                }
                peer = new Peer(); // Let PeerJS generate the ID

                peer.on('open', id => {
                    console.log('Host PeerJS object open. ID:', id);
                    resolve(id);
                });

                peer.on('error', err => {
                    console.error("PeerJS error during host setup:", err);
                    reject(err);
                });
            });
        }

        function displayHostQRCode(hostId) {
            document.getElementById('host-status').textContent = 'Waiting for connection...';
            try {
                const baseUrl = window.location.origin + window.location.pathname;
                const companionUrl = `${baseUrl}?companion_id=${hostId}`;

                const openInTabBtn = document.getElementById('open-in-tab-btn');
                openInTabBtn.href = companionUrl;
                openInTabBtn.classList.remove('hidden');

                const qr = qrcode(0, 'L');
                qr.addData(companionUrl);
                qr.make();
                const canvas = document.getElementById('qr-code-canvas');
                const ctx = canvas.getContext('2d');
                const cellSize = 4;
                const margin = cellSize * 4;
                const qrSize = qr.getModuleCount() * cellSize;
                canvas.width = qrSize + margin * 2;
                canvas.height = qrSize + margin * 2;
                ctx.fillStyle = "#f7e7d8";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#5d4037";

                for (let row = 0; row < qr.getModuleCount(); row++) {
                    for (let col = 0; col < qr.getModuleCount(); col++) {
                        if (qr.isDark(row, col)) {
                            ctx.fillRect(margin + col * cellSize, margin + row * cellSize, cellSize, cellSize);
                        }
                    }
                }
            } catch (err) {
                console.error("QR Code generation failed:", err);
                document.getElementById('qr-code-canvas').style.display = 'none';
                document.getElementById('host-status').textContent = 'QR generation failed.';
            }
        }

        function listenForCompanionConnections() {
            peer.on('connection', (conn) => {
                console.log('Companion has connected!');
                hostConnection = conn;
                document.getElementById('host-status').textContent = '✅ Connected!';
                document.getElementById('companion-sync-btn').classList.add('phone-connected');

                // Add a short delay to show the connected message, then hide the modal.
                setTimeout(() => {
                    hideScreen('host-sync-modal');
                }, 1000);

                // This map links button IDs from the companion to functions on the host.
                // This is more reliable than simulating clicks.
                const actionMap = new Map([
                    // Main App Grid
                    ['app-btn-order', openRestockPanel],
                    ['app-btn-shelves', openShelfAssignmentPanel],
                    ['app-btn-items', openItemsPanel],
                    ['app-btn-employees', openEmployeesPanel],
                    ['app-btn-customers', openCustomersPanel],
                    ['app-btn-unlocks', openUnlocksPanel],
                    ['app-btn-market', openMarketPanel],
                    ['app-btn-settings', () => showAppScreen('settings-panel')],
                    // Navigation
                    ['phone-back-btn', showAppGrid],
                    ['market-detail-back-btn', openMarketPanel],
                    // Market Modals
                    ['close-market-panel-btn', () => hideScreen('market-panel')],
                    ['close-market-detail-panel-btn', () => hideScreen('market-detail-panel')],
                    ['close-market-deep-dive-panel-btn', () => hideScreen('market-item-deep-dive-panel')],
                    // Order Screen
                    ['place-order-btn', () => placeOrder(false)],
                    ['order-quantity-done-btn', openRestockPanel],
                    // Settings Screen
                    ['new-game-btn', () => showScreen('new-game-screen')],
                    // Game Controls
                    ['companion-pause-play-btn', togglePause],
                    ['companion-double-time-btn', toggleDoubleTime]
                ]);

                hostConnection.on('data', (data) => {
                    if (data.action === 'click') {
                        const elementId = data.elementId;
                        console.log(`Host received click command for #${elementId}`);
                        const directAction = actionMap.get(elementId);

                        if (directAction) {
                            console.log(`...found direct action, executing function.`);
                            directAction();
                        } else {
                            // Fallback for buttons that are dynamically generated or not in the map
                            const element = document.getElementById(elementId);
                            if (element) {
                                console.log(`...no direct action found, using fallback dispatchEvent.`);
                                element.dispatchEvent(new Event('click', { bubbles: true }));
                            } else {
                                console.warn(`...no element found for ID: #${elementId}`);
                            }
                        }
                        // Always send the latest state back after any action.
                        sendFullGameStateToCompanion();

                    } else if (data.action === 'input') {
                        const element = document.getElementById(data.elementId);
                        if (element) {
                            console.log(`Host processing event for: #${data.elementId} with value ${data.value}`);
                            if (data.type === 'checkbox') {
                                element.checked = data.value;
                            } else {
                                element.value = data.value;
                            }
                            // Dispatch 'change' for toggles and selects, 'input' for number fields
                            const eventType = (data.type === 'checkbox' || data.type === 'select-one') ? 'change' : 'input';
                            element.dispatchEvent(new Event(eventType, { bubbles: true }));
                            sendFullGameStateToCompanion();
                        }
                    }
                });

                sendFullGameStateToCompanion();

                hostConnection.on('close', () => {
                    console.log('Companion disconnected.');
                    document.getElementById('host-status').textContent = 'Companion disconnected.';
                    document.getElementById('companion-sync-btn').classList.remove('phone-connected');
                    hostConnection = null;
                });
            });
        }


        function initializeCompanion() {
            // This function now returns a promise that resolves when the peer is ready.
            return new Promise((resolve, reject) => {
                 if (peer) {
                    peer.destroy();
                }
                peer = new Peer(); // Create a peer with a random ID

                peer.on('open', id => {
                    console.log('Companion PeerJS object open. ID:', id);
                    resolve(); // Resolve the promise when the peer is ready
                });

                 peer.on('error', (err) => {
                    console.error("Companion PeerJS Error:", err);
                    updateCompanionStatus(`Error: ${err.type}`);
                    reject(err);
                });
            });
        }

        async function connectToHost(hostId) {
            if (!hostId) {
                updateCompanionStatus('No connection ID provided. Please scan the QR code again.');
                return;
            }

            try {
                // Wait for the local peer object to be ready before trying to connect.
                await initializeCompanion();
                console.log("Companion peer initialized, now attempting to connect to host.");

                updateCompanionStatus(`Connecting to host...`);
                companionConnection = peer.connect(hostId);

                companionConnection.on('open', () => {
                    console.log('Connection to host established!');
                    updateCompanionStatus('✅ Connected!');
                    document.getElementById('phone-back-btn').classList.remove('hidden');
                    showAppGrid();
                });

                companionConnection.on('data', (data) => {
                    if (data.type === 'fullGameState') {
                        // console.log('Received full game state from host.');
                        applyGameState(data.state);
                    } else if (data.type === 'feedbackMessage') {
                        console.log('Received feedback message:', data.message);
                        showMessage(data.message);
                    }
                });

                companionConnection.on('close', () => {
                    console.log('Disconnected from host.');
                    updateCompanionStatus('Disconnected from host.');
                    showAppScreen('companion-sync-screen');
                });

                companionConnection.on('error', (err) => {
                    console.error("Connection error:", err);
                    updateCompanionStatus(`Connection error: ${err.type}`);
                });

            } catch (error) {
                console.error("Failed to initialize companion peer:", error);
                updateCompanionStatus('Failed to initialize. Please refresh.');
            }
        }

        function updateCompanionStatus(message) {
            document.getElementById('companion-status').textContent = message;
        }

        function sendActionToHost(action) {
            if (companionConnection && companionConnection.open) {
                companionConnection.send(action);
            }
        }

        function applyGameState(state) {
            // DEBUG: Log the state being received by the companion
            console.log(`COMPANION RECEIVED -> activePhoneScreen: ${state.activePhoneScreen}, modal: ${state.currentModalScreen}, context: ${JSON.stringify(state.phoneScreenContext)}`);

            const allModalIds = [
                'new-game-screen', 'dev-mode-screen', 'family-store-screen',
                'specialty-store-screen', 'casual-mode-screen', 'final-settings-screen',
                'market-style-modal', 'host-sync-modal', 'newspaper-modal',
                'end-of-day-panel', 'manager-report-modal', 'dev-report-modal',
                'simulated-market-report-modal',
                'market-panel', 'market-detail-panel', 'market-item-deep-dive-panel'
            ];

            // Apply all the state properties from the host to the companion's game
            activePhoneScreen = state.activePhoneScreen;
            phoneScreenContext = state.phoneScreenContext || {}; // IMPORTANT: Get the context
            currentModalScreen = state.currentModalScreen;
            cash = state.cash;
            day = state.day;
            shopPoints = state.shopPoints;
            unlocks = state.unlocks;
            shelves = state.shelves;
            storageCells = state.storageCells;
            loadingDockPackages = state.loadingDockPackages;
            customerProfiles = state.customerProfiles;
            enabledItems = state.enabledItems;
            priceHistory = state.priceHistory;
            marketType = state.marketType;
            marketEnabled = state.marketEnabled;
            items = state.items;
            developerMode = state.developerMode;
            dayPhase = state.dayPhase;
            continuousMode = state.continuousMode;
            originalItemCosts = state.originalItemCosts;
            player.basket = state.player.basket;
            isMandatoryBreak = state.isMandatoryBreak;
            currentRestockOrder = state.currentRestockOrder;
            isPaused = state.isPaused;
            timeMultiplier = state.isDoubleTime ? 2 : 1;

            const allEmployees = { cashier, stocker, barista, manager, salesperson };
            if (state.employees) {
                for (const empKey in state.employees) {
                    if (allEmployees[empKey]) {
                        allEmployees[empKey].shift = state.employees[empKey].shift;
                        allEmployees[empKey].breakPreference = state.employees[empKey].breakPreference;
                        allEmployees[empKey].onBreak = state.employees[empKey].onBreak;
                    }
                }
            }

            // Update companion UI based on new state
            if (document.body.classList.contains('companion-mode')) {
                document.getElementById('companion-funds').textContent = `Funds: $${Math.round(cash)}`;
                document.getElementById('companion-points').textContent = `Points: ${shopPoints}`;

                // Pause/Play Button
                const playIcon = document.getElementById('companion-play-icon');
                const pauseIcon = document.getElementById('companion-pause-icon');
                const pausePlayText = document.getElementById('companion-pause-play-text');
                if (isPaused) {
                    playIcon.classList.remove('hidden');
                    pauseIcon.classList.add('hidden');
                    pausePlayText.textContent = 'Play';
                } else {
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                    pausePlayText.textContent = 'Pause';
                }

                // Double Time Button
                const doubleTimeBtn = document.getElementById('companion-double-time-btn');
                if (timeMultiplier > 1) {
                    doubleTimeBtn.classList.add('bg-yellow-300');
                } else {
                    doubleTimeBtn.classList.remove('bg-yellow-300');
                }
            }

            shelves.forEach(shelf => shelf.draw = drawShelf);
            updateUI();
            updateBasketUI();

            // REFACTORED: Decouple data population from UI visibility.
            // First, call the functions that populate the data for each panel.
            switch (activePhoneScreen) {
                case 'restock-panel': openRestockPanel(); break;
                case 'unlocks-panel': openUnlocksPanel(); break;
                case 'shelf-assignment-panel': openShelfAssignmentPanel(); break;
                case 'employees-panel': openEmployeesPanel(); break;
                case 'customers-panel': openCustomersPanel(); break;
                case 'market-panel': openMarketPanel(); break;
                case 'items-panel': openItemsPanel(); break;
                case 'order-quantity-modal':
                    if (phoneScreenContext.itemName) openOrderQuantityModal(phoneScreenContext.itemName);
                    break;
                case 'shelf-panel':
                    if (phoneScreenContext.shelfIndex !== undefined && shelves[phoneScreenContext.shelfIndex]) {
                        openShelfPanel(shelves[phoneScreenContext.shelfIndex]);
                    }
                    break;
                case 'storage-panel':
                    if (phoneScreenContext.cellLabel) {
                        const cell = storageCells.find(c => c.label === phoneScreenContext.cellLabel) || coffeeShop.storage;
                        if (cell) openStorageCell(cell);
                    }
                    break;
                case 'market-detail-panel':
                     if (phoneScreenContext.categoryKey) openMarketDetailPanel(phoneScreenContext.categoryKey);
                    break;
                case 'market-item-deep-dive-panel':
                    if (phoneScreenContext.itemName) openMarketItemDeepDivePanel(phoneScreenContext.itemName);
                    break;
            }

            // Second, manage the UI visibility based on the state.
            if (activePhoneScreen) {
                showAppScreen(activePhoneScreen);
            } else {
                showAppGrid();
            }

            // --- Companion Modal Logic ---
            const clipboardPanel = document.getElementById('clipboard-panel');

            // Hide all modals first to prevent overlap
            allModalIds.forEach(id => {
                const modal = document.getElementById(id);
                if (modal) modal.classList.add('hidden');
            });

            // Then show the correct one based on the host's state
            if (currentModalScreen) {
                 // If a modal should be visible, hide the main phone UI
                if (clipboardPanel) clipboardPanel.classList.add('force-hidden');

                const modal = document.getElementById(currentModalScreen);
                if (modal) {
                    // Re-populate dynamic modals if they are the one being shown
                    switch(currentModalScreen) {
                        case 'family-store-screen':
                             const relativeSelect = document.getElementById('family-relative-select');
                            if (relativeSelect.options.length === 0) {
                                const employeeTypes = Object.keys(unlocks.employees);
                                employeeTypes.forEach(emp => {
                                    const option = document.createElement('option');
                                    option.value = emp;
                                    option.textContent = emp.charAt(0).toUpperCase() + emp.slice(1);
                                    relativeSelect.appendChild(option);
                                });
                            }
                            break;
                        case 'specialty-store-screen':
                            populateSpecialtyDropdowns();
                            handleSpecialtyChange();
                            break;
                        case 'market-panel':
                            populateMarketPanel();
                            break;
                        case 'market-detail-panel':
                            if (phoneScreenContext.categoryKey) {
                                populateMarketDetailPanel(phoneScreenContext.categoryKey);
                            }
                            break;
                        case 'market-item-deep-dive-panel':
                            if (phoneScreenContext.itemName) {
                                populateMarketItemDeepDivePanel(phoneScreenContext.itemName);
                            }
                            break;
                    }
                    modal.classList.remove('hidden');
                }
            } else {
                // If no modal is active, ensure the main phone UI is visible
                if (clipboardPanel) clipboardPanel.classList.remove('force-hidden');
            }
        }

        function sendFullGameStateToCompanion() {
            if (hostConnection && hostConnection.open) {
                const employeesToSave = {};
                const employeeObjects = { cashier, stocker, barista, manager, salesperson };
                for (const key in employeeObjects) {
                    if(employeeObjects[key]) {
                        employeesToSave[key] = {
                            shift: employeeObjects[key].shift,
                            breakPreference: employeeObjects[key].breakPreference,
                            onBreak: employeeObjects[key].onBreak
                        };
                    }
                }

                const gameState = {
                    cash, day, shopPoints, itemPopularity,
                    inventory, storageCells, shelves,
                    unlocks, loadingDockPackages, customerDemand,
                    customerProfiles, enabledItems,
                    priceHistory, marketType, marketEnabled, items,
                    developerMode, dayPhase, continuousMode, originalItemCosts,
                    player: { basket: player.basket },
                    employees: employeesToSave,
                    isMandatoryBreak,
                    currentRestockOrder,
                    activePhoneScreen,
                    phoneScreenContext,
                    isPaused,
                    isDoubleTime: timeMultiplier > 1,
                    currentModalScreen
                };

                // DEBUG: Log the state being sent from the host
                console.log(`HOST SENDING -> activePhoneScreen: ${gameState.activePhoneScreen}, modal: ${gameState.currentModalScreen}, context: ${JSON.stringify(gameState.phoneScreenContext)}`);

                // Prune the draw function before sending
                const stateToSend = JSON.parse(JSON.stringify(gameState));

                hostConnection.send({
                    type: 'fullGameState',
                    state: stateToSend
                });
            }
        }

        // This function overrides default event handlers in companion mode
        function setupCompanionActionListeners() {
            // Listen on the entire body to capture clicks on modals outside the clipboard
            document.body.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && button.id) {
                    // Also, if the clicked button is inside the sync screen, let it proceed.
                    if (button.closest('#companion-sync-screen')) {
                        return;
                    }

                    e.stopPropagation(); // Prevent the event from bubbling further
                    e.preventDefault(); // Stop the default action
                    console.log(`Companion sending click for #${button.id}`);
                    sendActionToHost({ action: 'click', elementId: button.id });
                }
            }, true); // Use capture phase to intercept clicks early

            document.body.addEventListener('input', (e) => {
                const input = e.target.closest('input[type="number"], input[type="checkbox"], select');
                 if (input && input.id) {
                    e.stopPropagation();
                    e.preventDefault();
                    console.log(`Companion sending event for #${input.id}`);
                    const eventData = {
                        action: 'input',
                        elementId: input.id,
                        value: input.type === 'checkbox' ? input.checked : input.value,
                        type: input.type
                    };
                    sendActionToHost(eventData);
                 }
            }, true);
        }

    </script>
</body>
</html>


